/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/chat/completions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create chat completion
         * @description Creates a model response for the given chat conversation. Compatible with OpenAI's chat completions API.
         */
        post: operations["createChatCompletion"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/models": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List available models
         * @description Lists the currently available models, and provides basic information about each one.
         */
        get: operations["listModels"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/embeddings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create embeddings
         * @description Creates an embedding vector representing the input text. Note: This endpoint is not fully implemented yet.
         */
        post: operations["createEmbedding"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/images/generations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create image
         * @description Creates an image given a prompt.
         */
        post: operations["createImage"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/completions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create completion (Legacy)
         * @deprecated
         * @description Legacy completions endpoint. Use /chat/completions instead.
         */
        post: operations["createCompletion"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        ChatCompletionRequest: {
            /**
             * @description ID of the model to use
             * @example gpt-4
             */
            model: string;
            /** @description List of messages comprising the conversation so far */
            messages: components["schemas"]["Message"][];
            /**
             * Format: double
             * @description Sampling temperature between 0 and 2
             * @default 1
             */
            temperature: number;
            /**
             * @description Maximum number of tokens to generate
             * @example 1024
             */
            max_tokens?: number;
            /**
             * Format: double
             * @description Nucleus sampling parameter
             * @default 1
             */
            top_p: number;
            /**
             * @description Number of chat completion choices to generate
             * @default 1
             */
            n: number;
            /**
             * @description Whether to stream back partial progress
             * @default false
             */
            stream: boolean;
            /** @description Sequences where the API will stop generating further tokens */
            stop?: string | string[];
            /**
             * Format: double
             * @description Penalize new tokens based on whether they appear in the text so far
             * @default 0
             */
            presence_penalty: number;
            /**
             * Format: double
             * @description Penalize new tokens based on their existing frequency in the text
             * @default 0
             */
            frequency_penalty: number;
            /** @description Modify the likelihood of specified tokens appearing in the completion */
            logit_bias?: {
                [key: string]: number;
            };
            /** @description Unique identifier representing your end-user */
            user?: string;
            /** @description List of tools the model may call */
            tools?: components["schemas"]["Tool"][];
            /** @description Controls which tool is called by the model */
            tool_choice?: ("none" | "auto") | components["schemas"]["ToolChoice"];
            response_format?: components["schemas"]["ResponseFormat"];
            /** @description Random seed for deterministic outputs */
            seed?: number;
        };
        Message: {
            /**
             * @description Role of the message author
             * @enum {string}
             */
            role: "system" | "user" | "assistant" | "function" | "tool";
            /** @description Content of the message */
            content: string | components["schemas"]["ContentPart"][];
            /** @description Name of the function (when role is function) */
            name?: string;
            /** @description Function call made by the assistant */
            function_call?: components["schemas"]["FunctionCall"];
            /** @description Tool calls made by the assistant */
            tool_calls?: components["schemas"]["ToolCall"][];
        };
        ContentPart: {
            /** @enum {string} */
            type: "text";
            text: string;
        } | {
            /** @enum {string} */
            type: "image_url";
            image_url: {
                /** Format: uri */
                url: string;
                /**
                 * @default auto
                 * @enum {string}
                 */
                detail: "auto" | "low" | "high";
            };
        };
        Tool: {
            /** @enum {string} */
            type: "function";
            function: components["schemas"]["FunctionDefinition"];
        };
        FunctionDefinition: {
            /** @description Name of the function */
            name: string;
            /** @description Description of what the function does */
            description?: string;
            /** @description Parameters the function accepts (JSON Schema) */
            parameters?: Record<string, never>;
        };
        ToolChoice: {
            /** @enum {string} */
            type: "function";
            function: {
                name: string;
            };
        };
        ResponseFormat: {
            /** @enum {string} */
            type: "text" | "json_object";
            /** @description JSON Schema for structured outputs */
            schema?: Record<string, never>;
        };
        ChatCompletionResponse: {
            /** @description Unique identifier for the chat completion */
            id: string;
            /** @enum {string} */
            object: "chat.completion";
            /**
             * Format: int64
             * @description Unix timestamp of when the completion was created
             */
            created: number;
            /** @description Model used for the completion */
            model: string;
            /** @description System fingerprint for the model configuration */
            system_fingerprint?: string;
            choices: components["schemas"]["Choice"][];
            usage?: components["schemas"]["Usage"];
        };
        Choice: {
            /** @description Index of the choice in the list */
            index: number;
            message: components["schemas"]["Message"];
            /**
             * @description Reason the model stopped generating tokens
             * @enum {string}
             */
            finish_reason: "stop" | "length" | "tool_calls" | "content_filter" | "function_call";
            /** @description Log probabilities for the output tokens */
            logprobs?: Record<string, never> | null;
        };
        ChatCompletionChunk: {
            id: string;
            /** @enum {string} */
            object: "chat.completion.chunk";
            /** Format: int64 */
            created: number;
            model: string;
            system_fingerprint?: string;
            choices: components["schemas"]["StreamingChoice"][];
        };
        StreamingChoice: {
            index: number;
            delta: components["schemas"]["DeltaContent"];
            /** @enum {string|null} */
            finish_reason?: "stop" | "length" | "tool_calls" | "content_filter" | "function_call" | null;
        };
        DeltaContent: {
            /** @enum {string} */
            role?: "system" | "user" | "assistant" | "function" | "tool";
            content?: string | null;
            function_call?: components["schemas"]["FunctionCall"];
            tool_calls?: components["schemas"]["ToolCall"][];
        };
        FunctionCall: {
            name: string;
            /** @description JSON-encoded arguments */
            arguments: string;
        };
        ToolCall: {
            id: string;
            /** @enum {string} */
            type: "function";
            function: components["schemas"]["FunctionCall"];
        };
        Usage: {
            /** @description Number of tokens in the prompt */
            prompt_tokens: number;
            /** @description Number of tokens in the generated completion */
            completion_tokens: number;
            /** @description Total number of tokens used */
            total_tokens: number;
        };
        Model: {
            /** @description Model identifier */
            id: string;
            /** @enum {string} */
            object: "model";
            /**
             * Format: int64
             * @description Unix timestamp of model creation
             */
            created?: number;
            /** @description Organization that owns the model */
            owned_by?: string;
        };
        EmbeddingRequest: {
            /** @description ID of the model to use */
            model: string;
            /** @description Input text to embed */
            input: string | string[];
            /**
             * @description Format to return embeddings in
             * @default float
             * @enum {string}
             */
            encoding_format: "float" | "base64";
            /** @description Number of dimensions for the output embeddings */
            dimensions?: number;
            /** @description Unique identifier representing your end-user */
            user?: string;
        };
        EmbeddingResponse: {
            /** @enum {string} */
            object: "list";
            data: {
                /** @enum {string} */
                object: "embedding";
                embedding: number[];
                index: number;
            }[];
            model: string;
            usage: {
                prompt_tokens: number;
                total_tokens: number;
            };
        };
        ImageGenerationRequest: {
            /** @description ID of the model to use */
            model: string;
            /** @description Text description of the desired image(s) */
            prompt: string;
            /**
             * @description Number of images to generate
             * @default 1
             */
            n: number;
            /**
             * @description Quality of the image
             * @default standard
             * @enum {string}
             */
            quality: "standard" | "hd";
            /**
             * @description Format in which generated images are returned
             * @default url
             * @enum {string}
             */
            response_format: "url" | "b64_json";
            /**
             * @description Size of the generated images
             * @default 1024x1024
             * @enum {string}
             */
            size: "256x256" | "512x512" | "1024x1024" | "1792x1024" | "1024x1792";
            /**
             * @description Style of the generated images
             * @default vivid
             * @enum {string}
             */
            style: "vivid" | "natural";
            /** @description Unique identifier representing your end-user */
            user?: string;
        };
        ImageGenerationResponse: {
            /**
             * Format: int64
             * @description Unix timestamp of when the images were created
             */
            created: number;
            data: {
                /**
                 * Format: uri
                 * @description URL of the generated image
                 */
                url?: string;
                /** @description Base64-encoded JSON of the generated image */
                b64_json?: string;
                /** @description The prompt that was used to generate the image */
                revised_prompt?: string;
            }[];
        };
        Error: {
            error: string | {
                /** @description Human-readable error message */
                message: string;
                /** @description Error type */
                type: string;
                /** @description Error code */
                code?: string;
                /** @description Parameter related to the error */
                param?: string | null;
            };
        };
    };
    responses: {
        /** @description Bad request */
        BadRequest: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Authentication required */
        Unauthorized: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Rate limit exceeded */
        RateLimitExceeded: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Internal server error */
        InternalServerError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
    };
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    createChatCompletion: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ChatCompletionRequest"];
            };
        };
        responses: {
            /** @description Successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ChatCompletionResponse"];
                    /** @description Server-sent events stream when stream=true */
                    "text/event-stream": components["schemas"]["ChatCompletionChunk"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            429: components["responses"]["RateLimitExceeded"];
            500: components["responses"]["InternalServerError"];
        };
    };
    listModels: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @enum {string} */
                        object: "list";
                        data: components["schemas"]["Model"][];
                    };
                };
            };
            401: components["responses"]["Unauthorized"];
            500: components["responses"]["InternalServerError"];
        };
    };
    createEmbedding: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["EmbeddingRequest"];
            };
        };
        responses: {
            /** @description Successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EmbeddingResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            500: components["responses"]["InternalServerError"];
            /** @description Not implemented */
            501: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    createImage: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ImageGenerationRequest"];
            };
        };
        responses: {
            /** @description Successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ImageGenerationResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            500: components["responses"]["InternalServerError"];
        };
    };
    createCompletion: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Not implemented */
            501: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
}
