{"version":3,"sources":["../src/constants/endpoints.ts","../src/constants/http.ts","../src/constants/validation.ts","../src/client/FetchBasedClient.ts","../src/utils/stream-response.ts","../src/utils/web-streaming.ts","../src/utils/enhanced-web-streaming.ts","../src/services/FetchChatService.ts","../src/services/AudioService.ts","../src/services/HealthService.ts","../src/models/images.ts","../src/utils/validation.ts","../src/services/ImagesService.ts","../src/client/ClientAdapter.ts","../src/models/videos.ts","../src/services/VideosService.ts","../src/services/DiscoveryService.ts","../src/FetchConduitCoreClient.ts","../src/models/chat.ts","../src/models/enhanced-streaming.ts","../src/services/TasksService.ts","../src/services/BatchOperationsService.ts","../src/services/MetricsService.ts","../src/models/discovery.ts","../src/services/ProviderModelsService.ts","../src/signalr/BaseSignalRConnection.ts","../src/models/signalr.ts","../src/signalr/TaskHubClient.ts","../src/signalr/VideoGenerationHubClient.ts","../src/signalr/ImageGenerationHubClient.ts","../src/services/SignalRService.ts","../src/utils/capabilities.ts","../src/models/embeddings.ts","../src/services/EmbeddingsService.ts","../src/services/NotificationsService.ts","../src/models/metadata.ts"],"names":["COMMON_HTTP_HEADERS","COMMON_CONTENT_TYPES","HttpMethod","ModelCapability","CommonBaseSignalRConnection","getDisplayName","subscription"],"mappings":"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","file":"index.mjs","sourcesContent":["/**\n * API endpoint constants for type-safe endpoint management.\n */\nexport const API_ENDPOINTS = {\n  V1: {\n    CHAT: {\n      COMPLETIONS: '/v1/chat/completions',\n    },\n    IMAGES: {\n      GENERATIONS: '/v1/images/generations',\n      ASYNC_GENERATIONS: '/v1/images/generations/async',\n      // Note: The following endpoints are not yet implemented in Core API\n      EDITS: '/v1/images/edits', // Not implemented\n      VARIATIONS: '/v1/images/variations', // Not implemented\n      TASK_STATUS: (taskId: string) => `/v1/images/generations/${encodeURIComponent(taskId)}/status`,\n      CANCEL_TASK: (taskId: string) => `/v1/images/generations/${encodeURIComponent(taskId)}`,\n    },\n    VIDEOS: {\n      // Note: Synchronous video generation endpoint does not exist\n      ASYNC_GENERATIONS: '/v1/videos/generations/async',\n      TASK_STATUS: (taskId: string) => `/v1/videos/generations/tasks/${encodeURIComponent(taskId)}`,\n      CANCEL_TASK: (taskId: string) => `/v1/videos/generations/${encodeURIComponent(taskId)}`,\n    },\n    AUDIO: {\n      TRANSCRIPTIONS: '/v1/audio/transcriptions',\n      TRANSLATIONS: '/v1/audio/translations',\n      SPEECH: '/v1/audio/speech',\n    },\n    MODELS: {\n      BASE: '/v1/models',\n      BY_ID: (modelId: string) => `/v1/models/${encodeURIComponent(modelId)}`,\n    },\n    EMBEDDINGS: {\n      BASE: '/v1/embeddings',\n    },\n    TASKS: {\n      BASE: '/v1/tasks',\n      BY_ID: (taskId: string) => `/v1/tasks/${encodeURIComponent(taskId)}`,\n      CANCEL: (taskId: string) => `/v1/tasks/${encodeURIComponent(taskId)}/cancel`,\n      CLEANUP: '/v1/tasks/cleanup',\n    },\n    BATCH: {\n      // Note: No generic /v1/batch endpoint exists. Use specific batch endpoints:\n      SPEND_UPDATES: '/v1/batch/spend-updates',\n      VIRTUAL_KEY_UPDATES: '/v1/batch/virtual-key-updates',\n      WEBHOOK_SENDS: '/v1/batch/webhook-sends',\n      OPERATIONS: {\n        BY_ID: (operationId: string) => `/v1/batch/operations/${encodeURIComponent(operationId)}`,\n        CANCEL: (operationId: string) => `/v1/batch/operations/${encodeURIComponent(operationId)}/cancel`,\n      },\n    },\n  },\n  ROOT: {\n    HEALTH: '/health',\n    METRICS: '/metrics',\n  },\n} as const;\n\n/**\n * Type-safe endpoint helper functions.\n */\nexport const EndpointHelpers = {\n  /**\n   * Get task status endpoint for any type of task.\n   */\n  getTaskStatusEndpoint: (taskType: 'images' | 'videos', taskId: string): string => {\n    switch (taskType) {\n      case 'images':\n        return API_ENDPOINTS.V1.IMAGES.TASK_STATUS(taskId);\n      case 'videos':\n        return API_ENDPOINTS.V1.VIDEOS.TASK_STATUS(taskId);\n      default:\n        throw new Error(`Unsupported task type: ${taskType as string}`);\n    }\n  },\n\n  /**\n   * Get task cancellation endpoint for any type of task.\n   */\n  getCancelTaskEndpoint: (taskType: 'images' | 'videos', taskId: string): string => {\n    switch (taskType) {\n      case 'images':\n        return API_ENDPOINTS.V1.IMAGES.CANCEL_TASK(taskId);\n      case 'videos':\n        return API_ENDPOINTS.V1.VIDEOS.CANCEL_TASK(taskId);\n      default:\n        throw new Error(`Unsupported task type: ${taskType as string}`);\n    }\n  },\n} as const;","// Import shared HTTP constants from Common package\nimport { \n  HTTP_HEADERS as COMMON_HTTP_HEADERS,\n  CONTENT_TYPES as COMMON_CONTENT_TYPES,\n  HTTP_STATUS,\n  ERROR_CODES,\n  TIMEOUTS,\n  RETRY_CONFIG,\n  HttpMethod\n} from '@knn_labs/conduit-common';\n\n// Re-export for backward compatibility\nexport { \n  HTTP_STATUS, \n  ERROR_CODES, \n  TIMEOUTS, \n  RETRY_CONFIG,\n  HttpMethod \n};\n\n/**\n * HTTP method constants for type-safe method specification.\n * @deprecated Use HttpMethod enum from '@knn_labs/conduit-common' instead\n */\nexport const HTTP_METHODS = {\n  GET: 'GET',\n  POST: 'POST',\n  PUT: 'PUT',\n  DELETE: 'DELETE',\n  PATCH: 'PATCH',\n} as const;\n\n// Re-export HTTP_HEADERS with Core SDK specific overrides\nexport const HTTP_HEADERS = {\n  ...COMMON_HTTP_HEADERS,\n  RETRY_AFTER: 'retry-after', // Core SDK uses lowercase\n} as const;\n\n// Re-export CONTENT_TYPES with Core SDK specific additions\nexport const CONTENT_TYPES = {\n  ...COMMON_CONTENT_TYPES,\n  TEXT_STREAM: 'text/plain; charset=utf-8', // Core SDK specific\n} as const;\n\nexport type ErrorCode = typeof ERROR_CODES[keyof typeof ERROR_CODES];\n\n// Re-export types from other modules to satisfy imports in constants/index.ts\nexport type { TaskStatus, TaskType } from './tasks';\nexport type { ChatRole, ImageResponseFormat, ImageQuality, ImageStyle, ImageSize } from './validation';\nexport type { StreamEvent } from './streaming';\n\n/**\n * Client information constants.\n */\nexport const CLIENT_INFO = {\n  NAME: '@conduit/core',\n  VERSION: '0.1.0', // Could be imported from package.json\n  USER_AGENT: '@conduit/core/0.1.0',\n} as const;","/**\n * Chat message role constants.\n */\nexport const CHAT_ROLES = {\n  SYSTEM: 'system',\n  USER: 'user',\n  ASSISTANT: 'assistant',\n  TOOL: 'tool',\n} as const;\n\nexport type ChatRole = typeof CHAT_ROLES[keyof typeof CHAT_ROLES];\n\n/**\n * Chat role validation helpers.\n */\nexport const ChatRoleHelpers = {\n  /**\n   * Get all valid chat roles.\n   */\n  getAllRoles: (): readonly ChatRole[] => Object.values(CHAT_ROLES),\n\n  /**\n   * Check if a role is valid.\n   */\n  isValidRole: (role: string): role is ChatRole => \n    Object.values(CHAT_ROLES).includes(role as ChatRole),\n\n  /**\n   * Check if a role requires a tool call ID.\n   */\n  requiresToolCallId: (role: string): boolean =>\n    role === CHAT_ROLES.TOOL,\n\n  /**\n   * Validate a role and throw an error if invalid.\n   */\n  validateRole: (role: string): asserts role is ChatRole => {\n    if (!ChatRoleHelpers.isValidRole(role)) {\n      throw new Error(`Invalid chat role: ${role}. Valid roles are: ${Object.values(CHAT_ROLES).join(', ')}`);\n    }\n  },\n} as const;\n\n/**\n * Image response format constants.\n */\nexport const IMAGE_RESPONSE_FORMATS = {\n  URL: 'url',\n  BASE64_JSON: 'b64_json',\n} as const;\n\nexport type ImageResponseFormat = typeof IMAGE_RESPONSE_FORMATS[keyof typeof IMAGE_RESPONSE_FORMATS];\n\n/**\n * Image quality constants.\n */\nexport const IMAGE_QUALITY = {\n  STANDARD: 'standard',\n  HD: 'hd',\n} as const;\n\nexport type ImageQuality = typeof IMAGE_QUALITY[keyof typeof IMAGE_QUALITY];\n\n/**\n * Image style constants.\n */\nexport const IMAGE_STYLE = {\n  VIVID: 'vivid',\n  NATURAL: 'natural',\n} as const;\n\nexport type ImageStyle = typeof IMAGE_STYLE[keyof typeof IMAGE_STYLE];\n\n/**\n * Image size constants.\n */\nexport const IMAGE_SIZES = {\n  SMALL: '256x256',\n  MEDIUM: '512x512',\n  LARGE: '1024x1024',\n  WIDE: '1792x1024',\n  TALL: '1024x1792',\n} as const;\n\nexport type ImageSize = typeof IMAGE_SIZES[keyof typeof IMAGE_SIZES];\n\n/**\n * Image validation helpers.\n */\nexport const ImageValidationHelpers = {\n  /**\n   * Check if response format is valid.\n   */\n  isValidResponseFormat: (format: string): format is ImageResponseFormat =>\n    Object.values(IMAGE_RESPONSE_FORMATS).includes(format as ImageResponseFormat),\n\n  /**\n   * Check if quality is valid.\n   */\n  isValidQuality: (quality: string): quality is ImageQuality =>\n    Object.values(IMAGE_QUALITY).includes(quality as ImageQuality),\n\n  /**\n   * Check if style is valid.\n   */\n  isValidStyle: (style: string): style is ImageStyle =>\n    Object.values(IMAGE_STYLE).includes(style as ImageStyle),\n\n  /**\n   * Check if size is valid.\n   */\n  isValidSize: (size: string): size is ImageSize =>\n    Object.values(IMAGE_SIZES).includes(size as ImageSize),\n\n  /**\n   * Get all valid response formats.\n   */\n  getAllResponseFormats: (): readonly ImageResponseFormat[] => Object.values(IMAGE_RESPONSE_FORMATS),\n\n  /**\n   * Get all valid qualities.\n   */\n  getAllQualities: (): readonly ImageQuality[] => Object.values(IMAGE_QUALITY),\n\n  /**\n   * Get all valid styles.\n   */\n  getAllStyles: (): readonly ImageStyle[] => Object.values(IMAGE_STYLE),\n\n  /**\n   * Get all valid sizes.\n   */\n  getAllSizes: (): readonly ImageSize[] => Object.values(IMAGE_SIZES),\n} as const;","import type { ClientConfig, RequestOptions, RetryConfig, RequestConfig, ResponseInfo } from './types';\nimport type { ErrorResponse } from '../models/common';\nimport { \n  ConduitError, \n  AuthError, \n  RateLimitError, \n  NetworkError,\n} from '../utils/errors';\nimport { HTTP_HEADERS, CONTENT_TYPES, CLIENT_INFO, ERROR_CODES } from '../constants';\nimport { ResponseParser, type ExtendedRequestInit } from './FetchOptions';\nimport { HttpMethod } from './HttpMethod';\n\n/**\n * Type-safe base client using native fetch API\n * Provides all the functionality of HTTP with better type safety\n */\nexport abstract class FetchBasedClient {\n  protected readonly config: Required<Omit<ClientConfig, 'onError' | 'onRequest' | 'onResponse'>> & \n    Pick<ClientConfig, 'onError' | 'onRequest' | 'onResponse'>;\n  protected readonly retryConfig: RetryConfig;\n  protected readonly retryDelays: number[];\n\n  constructor(config: ClientConfig) {\n    this.config = {\n      apiKey: config.apiKey,\n      baseURL: config.baseURL ?? 'https://api.conduit.ai',\n      timeout: config.timeout ?? 60000,\n      maxRetries: config.maxRetries ?? 3,\n      headers: config.headers ?? {},\n      debug: config.debug ?? false,\n      signalR: config.signalR ?? {},\n      retryDelay: config.retryDelay ?? [1000, 2000, 4000, 8000, 16000],\n      onError: config.onError,\n      onRequest: config.onRequest,\n      onResponse: config.onResponse,\n    };\n\n    this.retryConfig = {\n      maxRetries: this.config.maxRetries,\n      initialDelay: 1000,\n      maxDelay: 30000,\n      factor: 2,\n    };\n\n    this.retryDelays = this.config.retryDelay;\n  }\n\n  /**\n   * Type-safe request method with proper request/response typing\n   */\n  protected async request<TResponse = unknown, TRequest = unknown>(\n    url: string,\n    options: RequestOptions & { \n      method?: HttpMethod; \n      body?: TRequest;\n    } = {}\n  ): Promise<TResponse> {\n    const fullUrl = this.buildUrl(url);\n    const controller = new AbortController();\n    \n    // Set up timeout\n    const timeoutId = options.timeout ?? this.config.timeout\n      ? setTimeout(() => controller.abort(), options.timeout ?? this.config.timeout)\n      : undefined;\n\n    try {\n      const requestConfig: RequestConfig = {\n        method: options.method ?? HttpMethod.GET,\n        url: fullUrl,\n        headers: this.buildHeaders(options.headers),\n        data: options.body,\n      };\n\n      // Call onRequest callback if provided\n      if (this.config.onRequest) {\n        await this.config.onRequest(requestConfig);\n      }\n\n\n      if (this.config.debug) {\n        console.warn(`[Conduit] ${requestConfig.method} ${requestConfig.url}`);\n      }\n\n      const response = await this.executeWithRetry<TResponse, TRequest>(\n        fullUrl,\n        {\n          method: requestConfig.method,\n          headers: requestConfig.headers as HeadersInit,\n          body: options.body ? JSON.stringify(options.body) : undefined,\n          signal: options.signal ?? controller.signal,\n          responseType: options.responseType,\n          timeout: options.timeout ?? this.config.timeout,\n        },\n        options\n      );\n\n      return response;\n    } finally {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n    }\n  }\n\n  /**\n   * Type-safe GET request\n   */\n  protected async get<TResponse = unknown>(\n    url: string,\n    options?: RequestOptions\n  ): Promise<TResponse> {\n    return this.request<TResponse>(url, { ...options, method: HttpMethod.GET });\n  }\n\n  /**\n   * Type-safe POST request\n   */\n  protected async post<TResponse = unknown, TRequest = unknown>(\n    url: string,\n    data?: TRequest,\n    options?: RequestOptions\n  ): Promise<TResponse> {\n    return this.request<TResponse, TRequest>(url, { \n      ...options, \n      method: HttpMethod.POST, \n      body: data \n    });\n  }\n\n  /**\n   * Type-safe PUT request\n   */\n  protected async put<TResponse = unknown, TRequest = unknown>(\n    url: string,\n    data?: TRequest,\n    options?: RequestOptions\n  ): Promise<TResponse> {\n    return this.request<TResponse, TRequest>(url, { \n      ...options, \n      method: HttpMethod.PUT, \n      body: data \n    });\n  }\n\n  /**\n   * Type-safe PATCH request\n   */\n  protected async patch<TResponse = unknown, TRequest = unknown>(\n    url: string,\n    data?: TRequest,\n    options?: RequestOptions\n  ): Promise<TResponse> {\n    return this.request<TResponse, TRequest>(url, { \n      ...options, \n      method: HttpMethod.PATCH, \n      body: data \n    });\n  }\n\n  /**\n   * Type-safe DELETE request\n   */\n  protected async delete<TResponse = unknown>(\n    url: string,\n    options?: RequestOptions\n  ): Promise<TResponse> {\n    return this.request<TResponse>(url, { ...options, method: HttpMethod.DELETE });\n  }\n\n  private buildUrl(path: string): string {\n    // If path is already a full URL, return it\n    if (path.startsWith('http://') || path.startsWith('https://')) {\n      return path;\n    }\n    \n    // Ensure baseURL doesn't end with / and path starts with /\n    const baseUrl = this.config.baseURL.replace(/\\/$/, '');\n    const cleanPath = path.startsWith('/') ? path : `/${path}`;\n    \n    return `${baseUrl}${cleanPath}`;\n  }\n\n  private buildHeaders(additionalHeaders?: Record<string, string>): Record<string, string> {\n    return {\n      [HTTP_HEADERS.AUTHORIZATION]: `Bearer ${this.config.apiKey}`,\n      [HTTP_HEADERS.CONTENT_TYPE]: CONTENT_TYPES.JSON,\n      [HTTP_HEADERS.USER_AGENT]: CLIENT_INFO.USER_AGENT,\n      ...this.config.headers,\n      ...additionalHeaders,\n    };\n  }\n\n  private async executeWithRetry<TResponse, TRequest = unknown>(\n    url: string,\n    init: ExtendedRequestInit,\n    options: RequestOptions = {},\n    attempt: number = 1\n  ): Promise<TResponse> {\n    try {\n      const response = await fetch(url, ResponseParser.cleanRequestInit(init));\n      \n      // Call onResponse callback if provided\n      if (this.config.onResponse) {\n        const headers: Record<string, string> = {};\n        response.headers.forEach((value, key) => {\n          headers[key] = value;\n        });\n        \n        const responseInfo: ResponseInfo = {\n          status: response.status,\n          statusText: response.statusText,\n          headers,\n          data: undefined, // Will be populated after parsing\n          config: {\n            method: init.method ?? 'GET',\n            url,\n            headers: init.headers as Record<string, string> ?? {},\n            data: undefined,\n          },\n        };\n        await this.config.onResponse(responseInfo);\n      }\n\n      if (this.config.debug) {\n        console.warn(`[Conduit] Response: ${response.status} ${response.statusText}`);\n      }\n\n      if (!response.ok) {\n        const error = await this.handleErrorResponse(response);\n        throw error;\n      }\n\n      // Parse response using ResponseParser\n      return await ResponseParser.parse<TResponse>(response, init.responseType ?? options.responseType);\n    } catch (error) {\n      \n      // Check if we've exceeded max retries\n      if (attempt > this.retryConfig.maxRetries) {\n        throw this.handleError(error);\n      }\n\n      if (this.shouldRetry(error) && attempt <= this.retryConfig.maxRetries) {\n        const delay = this.calculateDelay(attempt);\n        if (this.config.debug) {\n          console.warn(`[Conduit] Retrying request (attempt ${attempt + 1}) after ${delay}ms`);\n        }\n        await this.sleep(delay);\n        return this.executeWithRetry<TResponse, TRequest>(url, init, options, attempt + 1);\n      }\n\n      throw this.handleError(error);\n    }\n  }\n\n  private async handleErrorResponse(response: Response): Promise<Error> {\n    let errorData: ErrorResponse | undefined;\n    \n    try {\n      const contentType = response.headers.get('content-type');\n      if (contentType?.includes('application/json')) {\n        errorData = await response.json() as unknown as ErrorResponse;\n      }\n    } catch {\n      // Ignore JSON parsing errors\n    }\n\n    const status = response.status;\n    \n    if (status === 401) {\n      return new AuthError(\n        errorData?.error?.message ?? 'Authentication failed',\n        { code: errorData?.error?.code ?? 'auth_error' }\n      );\n    } else if (status === 429) {\n      const retryAfter = response.headers.get('retry-after');\n      return new RateLimitError(\n        errorData?.error?.message ?? 'Rate limit exceeded',\n        retryAfter ? parseInt(retryAfter, 10) : undefined\n      );\n    } else if (status === 400) {\n      return new ConduitError(\n        errorData?.error?.message ?? 'Bad request',\n        status,\n        errorData?.error?.code ?? 'bad_request'\n      );\n    } else if (errorData?.error) {\n      return new ConduitError(\n        errorData.error.message,\n        status,\n        errorData.error.code ?? undefined\n      );\n    } else {\n      return new ConduitError(\n        `Request failed with status ${status}`,\n        status,\n        'http_error'\n      );\n    }\n  }\n\n  private shouldRetry(error: unknown): boolean {\n    if (error instanceof ConduitError) {\n      const status = error.statusCode;\n      return status === 429 || status === 503 || status === 504;\n    }\n    \n    if (error instanceof Error) {\n      // Network errors are retryable\n      return error.name === 'AbortError' || \n             error.message.includes('network') ||\n             error.message.includes('fetch');\n    }\n    \n    return false;\n  }\n\n  private calculateDelay(attempt: number): number {\n    if (this.retryDelays && this.retryDelays.length > 0) {\n      const index = Math.min(attempt - 1, this.retryDelays.length - 1);\n      return this.retryDelays[index];\n    }\n    \n    const delay = Math.min(\n      this.retryConfig.initialDelay * Math.pow(this.retryConfig.factor, attempt - 1),\n      this.retryConfig.maxDelay\n    );\n    return delay + Math.random() * 1000;\n  }\n\n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  private handleError(error: unknown): Error {\n    if (error instanceof Error) {\n      if (error.name === 'AbortError') {\n        const networkError = new NetworkError(\n          'Request timeout',\n          { code: ERROR_CODES.CONNECTION_ABORTED }\n        );\n        if (this.config.onError) {\n          this.config.onError(networkError);\n        }\n        return networkError;\n      }\n      \n      if (this.config.onError) {\n        this.config.onError(error);\n      }\n      return error;\n    }\n    \n    const unknownError = new Error(String(error));\n    if (this.config.onError) {\n      this.config.onError(unknownError);\n    }\n    return unknownError;\n  }\n}","import type { BaseStreamChunk, StreamingResponse } from '../models/streaming';\n\n/**\n * Creates a type-safe streaming response wrapper\n */\nexport class TypedStreamingResponse<T extends BaseStreamChunk> implements StreamingResponse<T> {\n  private readonly stream: AsyncGenerator<T, void, unknown>;\n  private abortController?: AbortController;\n\n  constructor(stream: AsyncGenerator<T, void, unknown>, abortController?: AbortController) {\n    this.stream = stream;\n    this.abortController = abortController;\n  }\n\n  async *[Symbol.asyncIterator](): AsyncIterator<T> {\n    for await (const chunk of this.stream) {\n      yield chunk;\n    }\n  }\n\n  async toArray(): Promise<T[]> {\n    const chunks: T[] = [];\n    for await (const chunk of this) {\n      chunks.push(chunk);\n    }\n    return chunks;\n  }\n\n  async *map<U>(fn: (chunk: T) => U | Promise<U>): AsyncGenerator<U, void, unknown> {\n    for await (const chunk of this) {\n      yield await fn(chunk);\n    }\n  }\n\n  async *filter(predicate: (chunk: T) => boolean | Promise<boolean>): AsyncGenerator<T, void, unknown> {\n    for await (const chunk of this) {\n      if (await predicate(chunk)) {\n        yield chunk;\n      }\n    }\n  }\n\n  async *take(n: number): AsyncGenerator<T, void, unknown> {\n    let count = 0;\n    for await (const chunk of this) {\n      if (count >= n) {\n        break;\n      }\n      yield chunk;\n      count++;\n    }\n  }\n\n  async *skip(n: number): AsyncGenerator<T, void, unknown> {\n    let count = 0;\n    for await (const chunk of this) {\n      if (count >= n) {\n        yield chunk;\n      } else {\n        count++;\n      }\n    }\n  }\n\n  cancel(): void {\n    if (this.abortController) {\n      this.abortController.abort();\n    }\n  }\n}\n\n/**\n * Helper function to create a streaming response\n */\nexport function createStreamingResponse<T extends BaseStreamChunk>(\n  stream: AsyncGenerator<T, void, unknown>,\n  abortController?: AbortController\n): StreamingResponse<T> {\n  return new TypedStreamingResponse(stream, abortController);\n}","import type { StreamingResponse, StreamOptions, BaseStreamChunk } from '../models/streaming';\nimport { StreamError } from './errors';\nimport { createStreamingResponse } from './stream-response';\n\n/**\n * Creates a typed streaming response from a web ReadableStream\n */\nexport function createWebStream<T extends BaseStreamChunk>(\n  stream: ReadableStream<Uint8Array>,\n  options?: StreamOptions\n): StreamingResponse<T> {\n  const abortController = new AbortController();\n  \n  // If the options signal is aborted, abort our controller too\n  if (options?.signal) {\n    options.signal.addEventListener('abort', () => abortController.abort());\n  }\n  \n  const generator = webStreamAsyncIterator<T>(stream, options);\n  return createStreamingResponse(generator, abortController);\n}\n\nasync function* webStreamAsyncIterator<T>(\n  stream: ReadableStream<Uint8Array>,\n  options?: StreamOptions\n): AsyncGenerator<T, void, unknown> {\n  const reader = stream.getReader();\n  const decoder = new TextDecoder();\n  let buffer = '';\n\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n      \n      if (done) {\n        break;\n      }\n\n      buffer += decoder.decode(value, { stream: true });\n      const lines = buffer.split('\\n');\n      \n      // Keep the last line if it's incomplete\n      buffer = lines.pop() ?? '';\n\n      for (const line of lines) {\n        if (line.trim() === '') continue;\n        \n        if (line.startsWith('data: ')) {\n          const data = line.slice(6);\n          \n          if (data === '[DONE]') {\n            return;\n          }\n\n          try {\n            const parsed = JSON.parse(data) as T;\n            yield parsed;\n          } catch (error) {\n            if (options?.onError) {\n              options.onError(new StreamError('Failed to parse SSE message', { cause: error }));\n            }\n          }\n        }\n      }\n    }\n\n    // Process any remaining data in buffer\n    if (buffer.trim() && buffer.startsWith('data: ')) {\n      const data = buffer.slice(6);\n      if (data !== '[DONE]') {\n        try {\n          const parsed = JSON.parse(data) as T;\n          yield parsed;\n        } catch (error) {\n          if (options?.onError) {\n            options.onError(new StreamError('Failed to parse final SSE message', { cause: error }));\n          }\n        }\n      }\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}","import type { StreamOptions } from '../models/streaming';\nimport type { EnhancedStreamEvent, EnhancedSSEEventType } from '../models/enhanced-streaming';\nimport type { EnhancedStreamingResponse } from '../models/enhanced-streaming-response';\nimport { StreamError } from './errors';\n\n/**\n * Creates an enhanced streaming response that preserves SSE event types\n */\nexport function createEnhancedWebStream(\n  stream: ReadableStream<Uint8Array>,\n  options?: StreamOptions\n): EnhancedStreamingResponse<EnhancedStreamEvent> {\n  const abortController = new AbortController();\n  \n  // If the options signal is aborted, abort our controller too\n  if (options?.signal) {\n    options.signal.addEventListener('abort', () => abortController.abort());\n  }\n  \n  const generator = enhancedWebStreamAsyncIterator(stream, options);\n  \n  // Create the enhanced streaming response\n  return {\n    async *[Symbol.asyncIterator]() {\n      yield* generator;\n    },\n    \n    async toArray(): Promise<EnhancedStreamEvent[]> {\n      const events: EnhancedStreamEvent[] = [];\n      for await (const event of generator) {\n        events.push(event);\n      }\n      return events;\n    },\n    \n    cancel(): void {\n      abortController.abort();\n    }\n  };\n}\n\nasync function* enhancedWebStreamAsyncIterator(\n  stream: ReadableStream<Uint8Array>,\n  options?: StreamOptions\n): AsyncGenerator<EnhancedStreamEvent, void, unknown> {\n  const reader = stream.getReader();\n  const decoder = new TextDecoder();\n  let buffer = '';\n  let currentEventType: string | undefined;\n  let currentData = '';\n  let lineNumber = 0;\n  const startTime = Date.now();\n  const timeout = options?.timeout ?? 300000; // 5 minutes default\n\n  try {\n    while (true) {\n      // Check for timeout\n      if (Date.now() - startTime > timeout) {\n        throw new StreamError(`Stream timeout after ${timeout}ms`);\n      }\n\n      const { done, value } = await reader.read();\n      \n      if (done) {\n        break;\n      }\n\n      // Validate chunk size\n      if (value.length > 1048576) { // 1MB limit per chunk\n        throw new StreamError(`Stream chunk too large: ${value.length} bytes`);\n      }\n\n      buffer += decoder.decode(value, { stream: true });\n      const lines = buffer.split('\\n');\n      \n      // Keep the last line if it's incomplete\n      buffer = lines.pop() ?? '';\n\n      for (const line of lines) {\n        lineNumber++;\n        const trimmedLine = line.trim();\n        \n        // Empty line signals end of event\n        if (trimmedLine === '') {\n          if (currentData) {\n            const event = processEvent(currentEventType, currentData, options);\n            if (event) {\n              yield event;\n            }\n            currentEventType = undefined;\n            currentData = '';\n          }\n          continue;\n        }\n        \n        // Parse event type\n        if (line.startsWith('event: ')) {\n          const eventType = line.slice(7).trim();\n          // Validate event type\n          if (eventType.length > 50) {\n            if (options?.onError) {\n              options.onError(new StreamError(`Invalid event type at line ${lineNumber}: too long`));\n            }\n            continue;\n          }\n          currentEventType = eventType;\n        } \n        // Parse data\n        else if (line.startsWith('data: ')) {\n          const data = line.slice(6);\n          // Prevent excessive data accumulation\n          if (currentData.length + data.length > 1048576) { // 1MB limit\n            if (options?.onError) {\n              options.onError(new StreamError(`Data too large at line ${lineNumber}`));\n            }\n            currentData = '';\n            currentEventType = undefined;\n            continue;\n          }\n          if (currentData) {\n            currentData += `\\n${data}`;\n          } else {\n            currentData = data;\n          }\n        }\n        // Ignore other fields or malformed lines\n        else if (!line.startsWith(':')) { // Comments start with :\n          if (options?.onError) {\n            options.onError(new StreamError(`Malformed SSE line at ${lineNumber}: ${line}`));\n          }\n        }\n      }\n    }\n\n    // Process any remaining event\n    if (currentData) {\n      const event = processEvent(currentEventType, currentData, options);\n      if (event) {\n        yield event;\n      }\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\nfunction processEvent(\n  eventType: string | undefined,\n  data: string,\n  options?: StreamOptions\n): EnhancedStreamEvent | null {\n  // Validate data\n  if (!data || data.length === 0) {\n    if (options?.onError) {\n      options.onError(new StreamError('Empty event data'));\n    }\n    return null;\n  }\n\n  // Handle [DONE] marker\n  if (data === '[DONE]') {\n    return {\n      type: 'done' as EnhancedSSEEventType,\n      data: '[DONE]'\n    };\n  }\n\n  // Determine event type\n  let type: EnhancedSSEEventType;\n  switch (eventType) {\n    case 'metrics':\n      type = 'metrics' as EnhancedSSEEventType;\n      break;\n    case 'metrics-final':\n      type = 'metrics-final' as EnhancedSSEEventType;\n      break;\n    case 'error':\n      type = 'error' as EnhancedSSEEventType;\n      break;\n    default:\n      // Default to content event for backwards compatibility\n      type = 'content' as EnhancedSSEEventType;\n  }\n\n  try {\n    const parsed = JSON.parse(data);\n    \n    // Basic validation based on event type\n    if (type === 'content' && parsed && typeof parsed === 'object' && !parsed.object) {\n      if (options?.onError) {\n        options.onError(new StreamError('Invalid content event: missing object field'));\n      }\n      return null;\n    }\n    \n    return {\n      type,\n      data: parsed\n    };\n  } catch (error) {\n    if (options?.onError) {\n      options.onError(new StreamError(`Failed to parse SSE ${type} event: ${error instanceof Error ? error.message : 'Unknown error'}`, { cause: error }));\n    }\n    // For non-critical errors, try to return raw data\n    if (type === 'error') {\n      return {\n        type,\n        data: { message: data, parse_error: true }\n      };\n    }\n    return null;\n  }\n}","import { FetchBasedClient } from '../client/FetchBasedClient';\nimport { HttpMethod } from '../client/HttpMethod';\nimport type { ClientConfig, RequestOptions } from '../client/types';\nimport type { StreamingResponse } from '../models/streaming';\nimport type { EnhancedStreamEvent } from '../models/enhanced-streaming';\nimport type { EnhancedStreamingResponse } from '../models/enhanced-streaming-response';\nimport type { ChatCompletionRequest, ChatCompletionResponse, ChatCompletionChunk } from '../models/chat';\nimport type { ToolParameters } from '../models/metadata';\nimport { API_ENDPOINTS } from '../constants';\nimport { createWebStream } from '../utils/web-streaming';\nimport { createEnhancedWebStream } from '../utils/enhanced-web-streaming';\n\n/**\n * Type-safe Chat service using generated OpenAPI types and native fetch\n */\nexport class FetchChatService extends FetchBasedClient {\n  constructor(config: ClientConfig) {\n    super(config);\n  }\n\n  /**\n   * Create a chat completion with full type safety\n   * Overloaded to handle both streaming and non-streaming responses\n   */\n  async create(\n    request: ChatCompletionRequest & { stream?: false },\n    options?: RequestOptions\n  ): Promise<ChatCompletionResponse>;\n  async create(\n    request: ChatCompletionRequest & { stream: true },\n    options?: RequestOptions\n  ): Promise<StreamingResponse<ChatCompletionChunk>>;\n  async create(\n    request: ChatCompletionRequest,\n    options?: RequestOptions\n  ): Promise<ChatCompletionResponse | StreamingResponse<ChatCompletionChunk>> {\n    // Convert legacy function parameters to tools\n    const processedRequest = this.convertLegacyFunctions(request);\n    \n    // Skip validation for now due to type mismatches with generated types\n    // validateChatCompletionRequest(processedRequest);\n\n    if (processedRequest.stream === true) {\n      return this.createStream(processedRequest as ChatCompletionRequest & { stream: true }, options);\n    }\n\n    return this.createCompletion(processedRequest, options);\n  }\n\n  private async createCompletion(\n    request: ChatCompletionRequest,\n    options?: RequestOptions\n  ): Promise<ChatCompletionResponse> {\n    const response = await this.post<ChatCompletionResponse, ChatCompletionRequest>(\n      API_ENDPOINTS.V1.CHAT.COMPLETIONS,\n      request,\n      options\n    );\n    \n    return response;\n  }\n\n  private async createStream(\n    request: ChatCompletionRequest & { stream: true },\n    options?: RequestOptions\n  ): Promise<StreamingResponse<ChatCompletionChunk>> {\n    const response = await this.createStreamingRequest(request, options);\n    const stream = response.body;\n    \n    if (!stream) {\n      throw new Error('Response body is not a stream');\n    }\n\n    return createWebStream<ChatCompletionChunk>(\n      stream,\n      {\n        signal: options?.signal,\n        timeout: options?.timeout,\n      }\n    );\n  }\n\n  protected async createStreamingRequest(\n    request: ChatCompletionRequest,\n    options?: RequestOptions\n  ): Promise<Response> {\n    const url = `${this.config.baseURL}${API_ENDPOINTS.V1.CHAT.COMPLETIONS}`;\n    const controller = new AbortController();\n    \n    // Set up timeout\n    const timeoutId = options?.timeout ?? this.config.timeout\n      ? setTimeout(() => controller.abort(), options?.timeout ?? this.config.timeout)\n      : undefined;\n\n    try {\n      const response = await fetch(url, {\n        method: HttpMethod.POST,\n        headers: {\n          'Authorization': `Bearer ${this.config.apiKey}`,\n          'Content-Type': 'application/json',\n          'User-Agent': '@conduit/core/1.0.0',\n          ...options?.headers,\n        },\n        body: JSON.stringify(request),\n        signal: options?.signal ?? controller.signal,\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      return response;\n    } finally {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n    }\n  }\n\n\n  /**\n   * Count tokens in messages (placeholder - actual implementation would use tiktoken)\n   */\n  countTokens(\n    messages: ChatCompletionRequest['messages'],\n    _model: string = 'gpt-4'\n  ): number {\n    // Rough estimation: 4 characters per token\n    const text = messages.map(m => \n      typeof m.content === 'string' ? m.content : JSON.stringify(m.content)\n    ).join(' ');\n    return Math.ceil(text.length / 4);\n  }\n\n  /**\n   * Validate that a request fits within model context limits\n   */\n  validateContextLength(\n    request: ChatCompletionRequest,\n    maxTokens?: number\n  ): { valid: boolean; tokens: number; limit: number } {\n    const tokens = this.countTokens(request.messages, request.model);\n    const limit = maxTokens ?? 8192; // Default limit\n    \n    return {\n      valid: tokens <= limit,\n      tokens,\n      limit,\n    };\n  }\n\n  /**\n   * Creates an enhanced streaming chat completion that preserves SSE event types.\n   * This allows access to metrics events and other enhanced streaming features.\n   * \n   * @param request - The chat completion request with stream: true\n   * @param options - Optional request configuration\n   * @returns A streaming response with enhanced events\n   * \n   * @example\n   * const stream = await chatService.createEnhancedStream({\n   *   model: 'gpt-4',\n   *   messages: [{ role: 'user', content: 'Hello!' }],\n   *   stream: true\n   * });\n   * \n   * for await (const event of stream) {\n   *   switch (event.type) {\n   *     case 'content':\n   *       console.log('Content:', event.data);\n   *       break;\n   *     case 'metrics':\n   *       console.log('Metrics:', event.data);\n   *       break;\n   *   }\n   * }\n   */\n  async createEnhancedStream(\n    request: ChatCompletionRequest & { stream: true },\n    options?: RequestOptions\n  ): Promise<EnhancedStreamingResponse<EnhancedStreamEvent>> {\n    const processedRequest = this.convertLegacyFunctions(request);\n    \n    const response = await this.createStreamingRequest(processedRequest, options);\n    const stream = response.body;\n    \n    if (!stream) {\n      throw new Error('Response body is not a stream');\n    }\n\n    return createEnhancedWebStream(\n      stream,\n      {\n        signal: options?.signal,\n        timeout: options?.timeout,\n      }\n    );\n  }\n  \n  /**\n   * Converts legacy function parameters to the tools format\n   * for backward compatibility\n   */\n  protected convertLegacyFunctions(request: ChatCompletionRequest): ChatCompletionRequest {\n    if (request.functions && !request.tools) {\n      request.tools = request.functions.map((fn: { name: string; description?: string; parameters?: ToolParameters }) => ({\n        type: 'function' as const,\n        function: fn\n      }));\n      delete request.functions;\n    }\n    \n    if (request.function_call && !request.tool_choice) {\n      if (typeof request.function_call === 'string') {\n        request.tool_choice = request.function_call as 'none' | 'auto';\n      } else {\n        request.tool_choice = {\n          type: 'function',\n          function: request.function_call\n        };\n      }\n      delete request.function_call;\n    }\n    \n    return request;\n  }\n}","import { FetchBasedClient } from '../client/FetchBasedClient';\nimport { HttpMethod } from '../client/HttpMethod';\nimport type { RequestOptions } from '../client/types';\nimport type {\n  AudioTranscriptionRequest,\n  AudioTranscriptionResponse,\n  AudioTranslationRequest,\n  AudioTranslationResponse,\n  TextToSpeechRequest,\n  TextToSpeechResponse,\n  HybridAudioRequest,\n  HybridAudioResponse,\n  AudioFile,\n  AudioFormat,\n  TranscriptionModel,\n  TextToSpeechModel,\n  Voice,\n  AudioMetadata\n} from '../models/audio';\n\n/**\n * Service for audio operations including speech-to-text, text-to-speech, and audio translation.\n * Provides OpenAI-compatible audio API endpoints for transcription, translation, and speech synthesis.\n * \n * @example\n * ```typescript\n * // Initialize the service\n * const audio = client.audio;\n * \n * // Transcribe audio\n * const transcription = await audio.transcribe({\n *   file: AudioUtils.fromBuffer(audioBuffer, 'speech.mp3'),\n *   model: 'whisper-1'\n * });\n * \n * // Generate speech\n * const speech = await audio.generateSpeech({\n *   model: 'tts-1',\n *   input: 'Hello, world!',\n *   voice: 'alloy'\n * });\n * ```\n */\nexport class AudioService extends FetchBasedClient {\n  constructor(client: FetchBasedClient) {\n    // @ts-expect-error Accessing protected property from another instance\n    super(client.config);\n  }\n\n  /**\n   * Transcribes audio to text using speech-to-text models.\n   * Supports multiple audio formats and languages with customizable output formats.\n   * \n   * @param request - The transcription request\n   * @param options - Optional request options\n   * @returns Promise resolving to transcription response\n   * \n   * @example\n   * ```typescript\n   * // Basic transcription\n   * const result = await audio.transcribe({\n   *   file: AudioUtils.fromBuffer(audioBuffer, 'audio.mp3'),\n   *   model: 'whisper-1'\n   * });\n   * console.log(result.text);\n   * \n   * // With language and timestamps\n   * const detailed = await audio.transcribe({\n   *   file: AudioUtils.fromBuffer(audioBuffer, 'audio.mp3'),\n   *   model: 'whisper-1',\n   *   language: 'en',\n   *   response_format: 'verbose_json',\n   *   timestamp_granularities: ['word', 'segment']\n   * });\n   * ```\n   */\n  async transcribe(\n    request: AudioTranscriptionRequest,\n    options?: RequestOptions\n  ): Promise<AudioTranscriptionResponse> {\n    this.validateTranscriptionRequest(request);\n\n    const formData = this.createAudioFormData(request.file, {\n      model: request.model,\n      language: request.language,\n      prompt: request.prompt,\n      response_format: request.response_format,\n      temperature: request.temperature,\n      timestamp_granularities: request.timestamp_granularities,\n    });\n\n    return this.request<AudioTranscriptionResponse>(\n      '/v1/audio/transcriptions',\n      {\n        method: HttpMethod.POST,\n        body: formData as BodyInit,\n        headers: {\n          'Content-Type': 'multipart/form-data',\n        },\n        ...options\n      }\n    );\n  }\n\n  /**\n   * Translates audio to English text using speech-to-text models.\n   * @param request The translation request\n   * @param options Optional request options\n   * @returns Promise resolving to translation response\n   */\n  async translate(\n    request: AudioTranslationRequest,\n    options?: RequestOptions\n  ): Promise<AudioTranslationResponse> {\n    this.validateTranslationRequest(request);\n\n    const formData = this.createAudioFormData(request.file, {\n      model: request.model,\n      prompt: request.prompt,\n      response_format: request.response_format,\n      temperature: request.temperature,\n    });\n\n    return this.request<AudioTranslationResponse>(\n      '/v1/audio/translations',\n      {\n        method: HttpMethod.POST,\n        body: formData as BodyInit,\n        headers: {\n          'Content-Type': 'multipart/form-data',\n        },\n        ...options\n      }\n    );\n  }\n\n  /**\n   * Generates speech from text using text-to-speech models.\n   * Supports multiple voices and audio formats with adjustable speed.\n   * \n   * @param request - The speech generation request\n   * @param options - Optional request options\n   * @returns Promise resolving to speech response with audio data\n   * \n   * @example\n   * ```typescript\n   * // Generate speech with default settings\n   * const speech = await audio.generateSpeech({\n   *   model: 'tts-1',\n   *   input: 'Welcome to our service!',\n   *   voice: 'nova'\n   * });\n   * \n   * // High quality with specific format\n   * const hdSpeech = await audio.generateSpeech({\n   *   model: 'tts-1-hd',\n   *   input: 'This is high quality audio.',\n   *   voice: 'alloy',\n   *   response_format: 'mp3',\n   *   speed: 1.0\n   * });\n   * \n   * // Save to file\n   * fs.writeFileSync('output.mp3', speech.audio);\n   * ```\n   */\n  async generateSpeech(\n    request: TextToSpeechRequest,\n    options?: RequestOptions\n  ): Promise<TextToSpeechResponse> {\n    this.validateSpeechRequest(request);\n\n    const response = await this.request<ArrayBuffer>(\n      '/v1/audio/speech',\n      {\n        method: HttpMethod.POST,\n        body: request,\n        responseType: 'arraybuffer',\n        ...options\n      }\n    );\n\n    // Convert ArrayBuffer to Buffer for Node.js compatibility\n    const audioBuffer = Buffer.from(response);\n    \n    return {\n      audio: audioBuffer,\n      format: request.response_format ?? 'mp3',\n      metadata: {\n        size: audioBuffer.length,\n      },\n    };\n  }\n\n  /**\n   * Processes audio through the hybrid pipeline (STT + LLM + TTS).\n   * @param request The hybrid audio processing request\n   * @param options Optional request options\n   * @returns Promise resolving to hybrid audio response\n   */\n  async processHybrid(\n    request: HybridAudioRequest,\n    options?: RequestOptions\n  ): Promise<HybridAudioResponse> {\n    this.validateHybridRequest(request);\n\n    const formData = this.createAudioFormData(request.file, {\n      models: request.models,\n      voice: request.voice,\n      system_prompt: request.system_prompt,\n      context: request.context,\n      language: request.language,\n      temperature: request.temperature,\n      voice_settings: request.voice_settings,\n      session_id: request.session_id,\n    });\n\n    const response = await this.request<ArrayBuffer>(\n      '/v1/audio/hybrid/process',\n      {\n        method: HttpMethod.POST,\n        body: formData as BodyInit,\n        headers: {\n          'Content-Type': 'multipart/form-data',\n        },\n        responseType: 'arraybuffer',\n        ...options\n      }\n    );\n\n    // Parse the hybrid response (assuming it includes metadata in headers)\n    // This would need to be adapted based on the actual API response format\n    const audioBuffer = Buffer.from(response);\n    \n    return {\n      audio: audioBuffer,\n      transcription: '', // Would be populated from response headers or separate endpoint\n      llm_response: '', // Would be populated from response headers or separate endpoint\n      stages: {\n        transcription: { duration: 0 },\n        llm: { duration: 0, tokens_used: 0, model_used: request.models.chat },\n        speech: { duration: 0, audio_duration: 0, format: 'mp3' as AudioFormat },\n      },\n      usage: {\n        llm_tokens: { prompt_tokens: 0, completion_tokens: 0, total_tokens: 0 },\n        total_processing_time_ms: 0,\n      },\n    };\n  }\n\n  /**\n   * Creates a simple transcription request for quick speech-to-text conversion.\n   * @param audioFile The audio file to transcribe\n   * @param model Optional model to use (defaults to 'whisper-1')\n   * @param language Optional language code\n   * @returns Promise resolving to transcription text\n   */\n  async quickTranscribe(\n    audioFile: AudioFile,\n    model: TranscriptionModel = 'whisper-1',\n    language?: string\n  ): Promise<string> {\n    const request: AudioTranscriptionRequest = {\n      file: audioFile,\n      model,\n      language,\n      response_format: 'text',\n    };\n\n    const response = await this.transcribe(request);\n    return response.text;\n  }\n\n  /**\n   * Creates a simple speech generation request for quick text-to-speech conversion.\n   * @param text The text to convert to speech\n   * @param voice Optional voice to use (defaults to 'alloy')\n   * @param model Optional model to use (defaults to 'tts-1')\n   * @returns Promise resolving to audio buffer\n   */\n  async quickSpeak(\n    text: string,\n    voice: Voice = 'alloy',\n    model: TextToSpeechModel = 'tts-1'\n  ): Promise<Buffer> {\n    const request: TextToSpeechRequest = {\n      model,\n      input: text,\n      voice,\n      response_format: 'mp3',\n    };\n\n    const response = await this.generateSpeech(request);\n    return response.audio;\n  }\n\n  /**\n   * Validates an audio transcription request.\n   * @private\n   */\n  private validateTranscriptionRequest(request: AudioTranscriptionRequest): void {\n    if (!request.file) {\n      throw new Error('Audio file is required for transcription');\n    }\n\n    if (!request.model) {\n      throw new Error('Model is required for transcription');\n    }\n\n    if (request.temperature !== undefined && (request.temperature < 0 || request.temperature > 1)) {\n      throw new Error('Temperature must be between 0 and 1');\n    }\n\n    this.validateAudioFile(request.file);\n  }\n\n  /**\n   * Validates an audio translation request.\n   * @private\n   */\n  private validateTranslationRequest(request: AudioTranslationRequest): void {\n    if (!request.file) {\n      throw new Error('Audio file is required for translation');\n    }\n\n    if (!request.model) {\n      throw new Error('Model is required for translation');\n    }\n\n    if (request.temperature !== undefined && (request.temperature < 0 || request.temperature > 1)) {\n      throw new Error('Temperature must be between 0 and 1');\n    }\n\n    this.validateAudioFile(request.file);\n  }\n\n  /**\n   * Validates a text-to-speech request.\n   * @private\n   */\n  private validateSpeechRequest(request: TextToSpeechRequest): void {\n    if (!request.input || request.input.trim().length === 0) {\n      throw new Error('Input text is required for speech generation');\n    }\n\n    if (request.input.length > 4096) {\n      throw new Error('Input text must be 4096 characters or less');\n    }\n\n    if (!request.model) {\n      throw new Error('Model is required for speech generation');\n    }\n\n    if (!request.voice) {\n      throw new Error('Voice is required for speech generation');\n    }\n\n    if (request.speed !== undefined && (request.speed < 0.25 || request.speed > 4.0)) {\n      throw new Error('Speed must be between 0.25 and 4.0');\n    }\n  }\n\n  /**\n   * Validates a hybrid audio request.\n   * @private\n   */\n  private validateHybridRequest(request: HybridAudioRequest): void {\n    if (!request.file) {\n      throw new Error('Audio file is required for hybrid processing');\n    }\n\n    if (!request.models) {\n      throw new Error('Models configuration is required for hybrid processing');\n    }\n\n    if (!request.models.transcription) {\n      throw new Error('Transcription model is required for hybrid processing');\n    }\n\n    if (!request.models.chat) {\n      throw new Error('Chat model is required for hybrid processing');\n    }\n\n    if (!request.models.speech) {\n      throw new Error('Speech model is required for hybrid processing');\n    }\n\n    if (!request.voice) {\n      throw new Error('Voice is required for hybrid processing');\n    }\n\n    this.validateAudioFile(request.file);\n  }\n\n  /**\n   * Validates an audio file.\n   * @private\n   */\n  private validateAudioFile(file: AudioFile): void {\n    if (!file.data) {\n      throw new Error('Audio file data is required');\n    }\n\n    if (!file.filename) {\n      throw new Error('Audio filename is required');\n    }\n\n    // Validate file extension\n    const extension = file.filename.toLowerCase().split('.').pop();\n    const supportedExtensions = ['mp3', 'wav', 'flac', 'ogg', 'aac', 'opus', 'pcm', 'm4a', 'webm'];\n    \n    if (!extension || !supportedExtensions.includes(extension)) {\n      throw new Error(`Unsupported audio format. Supported formats: ${supportedExtensions.join(', ')}`);\n    }\n\n    // Validate file size (25MB limit for most providers)\n    const maxSize = 25 * 1024 * 1024; // 25MB\n    let fileSize = 0;\n\n    if (Buffer.isBuffer(file.data)) {\n      fileSize = file.data.length;\n    } else if (file.data instanceof Blob) {\n      fileSize = file.data.size;\n    } else if (typeof file.data === 'string') {\n      // Assume base64 string\n      fileSize = Math.ceil(file.data.length * 0.75); // Approximate decoded size\n    }\n\n    if (fileSize > maxSize) {\n      throw new Error(`Audio file too large. Maximum size is ${maxSize / (1024 * 1024)}MB`);\n    }\n  }\n\n  /**\n   * Creates FormData for audio file uploads.\n   * @private\n   */\n  private createAudioFormData(file: AudioFile, additionalFields: Record<string, unknown>): FormData {\n    const formData = new FormData();\n    \n    // Handle different file data types\n    let fileBlob: Blob;\n    \n    if (Buffer.isBuffer(file.data)) {\n      fileBlob = new Blob([file.data], { type: file.contentType ?? 'audio/mpeg' });\n    } else if (file.data instanceof Blob) {\n      fileBlob = file.data;\n    } else if (typeof file.data === 'string') {\n      // Assume base64 string\n      const binaryString = atob(file.data);\n      const bytes = new Uint8Array(binaryString.length);\n      for (let i = 0; i < binaryString.length; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n      }\n      fileBlob = new Blob([bytes], { type: file.contentType ?? 'audio/mpeg' });\n    } else {\n      throw new Error('Unsupported file data type');\n    }\n\n    formData.append('file', fileBlob, file.filename);\n\n    // Add additional fields\n    Object.entries(additionalFields).forEach(([key, value]) => {\n      if (value !== undefined) {\n        if (typeof value === 'object') {\n          formData.append(key, JSON.stringify(value));\n        } else {\n          formData.append(key, String(value));\n        }\n      }\n    });\n\n    return formData;\n  }\n}\n\n/**\n * Audio utility functions for working with audio files.\n * Provides helper methods for creating AudioFile objects from various sources.\n * \n * @example\n * ```typescript\n * // From Buffer (Node.js)\n * const audioFile = AudioUtils.fromBuffer(buffer, 'audio.mp3', 'audio/mpeg');\n * \n * // From Blob (Browser)\n * const audioFile = AudioUtils.fromBlob(blob, 'recording.wav');\n * \n * // From Base64\n * const audioFile = AudioUtils.fromBase64(base64String, 'speech.mp3');\n * ```\n */\nexport class AudioUtils {\n  /**\n   * Creates an AudioFile from a Buffer with specified filename.\n   */\n  static fromBuffer(data: Buffer, filename: string, contentType?: string): AudioFile {\n    return {\n      data,\n      filename,\n      contentType,\n    };\n  }\n\n  /**\n   * Creates an AudioFile from a Blob with specified filename.\n   */\n  static fromBlob(data: Blob, filename: string): AudioFile {\n    return {\n      data,\n      filename,\n      contentType: data.type,\n    };\n  }\n\n  /**\n   * Creates an AudioFile from a base64 string with specified filename.\n   */\n  static fromBase64(data: string, filename: string, contentType?: string): AudioFile {\n    return {\n      data,\n      filename,\n      contentType,\n    };\n  }\n\n  /**\n   * Gets audio file metadata (basic validation).\n   */\n  static getBasicMetadata(file: AudioFile): AudioMetadata {\n    let size = 0;\n    \n    if (Buffer.isBuffer(file.data)) {\n      size = file.data.length;\n    } else if (file.data instanceof Blob) {\n      size = file.data.size;\n    } else if (typeof file.data === 'string') {\n      size = Math.ceil(file.data.length * 0.75);\n    }\n\n    const extension = file.filename.toLowerCase().split('.').pop() ?? 'unknown';\n    \n    return {\n      duration: 0, // Would need audio analysis library to determine\n      size,\n      format: extension as AudioFormat,\n      sample_rate: 0, // Would need audio analysis\n      channels: 0, // Would need audio analysis\n    };\n  }\n\n  /**\n   * Validates if the audio format is supported.\n   */\n  static isFormatSupported(format: string): boolean {\n    const supportedFormats = ['mp3', 'wav', 'flac', 'ogg', 'aac', 'opus', 'pcm', 'm4a', 'webm'];\n    return supportedFormats.includes(format.toLowerCase());\n  }\n\n  /**\n   * Gets the appropriate content type for an audio format.\n   */\n  static getContentType(format: AudioFormat): string {\n    const contentTypes: Record<AudioFormat, string> = {\n      mp3: 'audio/mpeg',\n      wav: 'audio/wav',\n      flac: 'audio/flac',\n      ogg: 'audio/ogg',\n      aac: 'audio/aac',\n      opus: 'audio/opus',\n      pcm: 'audio/pcm',\n      m4a: 'audio/mp4',\n      webm: 'audio/webm',\n    };\n    \n    return contentTypes[format] || 'audio/mpeg';\n  }\n}","import { FetchBasedClient } from '../client/FetchBasedClient';\nimport type { HealthCheckResponse, HealthCheckOptions, WaitForHealthOptions } from '../models/health';\n\nexport class HealthService extends FetchBasedClient {\n  constructor(client: FetchBasedClient) {\n    // @ts-expect-error Accessing protected property from another instance\n    super(client.config);\n  }\n\n  async check(options?: HealthCheckOptions): Promise<HealthCheckResponse> {\n    return this.get<HealthCheckResponse>('/health', options);\n  }\n\n  async waitForHealth(options?: WaitForHealthOptions): Promise<HealthCheckResponse> {\n    const timeout = options?.timeout ?? 30000;\n    const pollingInterval = options?.pollingInterval ?? 1000;\n    const maxAttempts = Math.floor(timeout / pollingInterval);\n\n    for (let i = 0; i < maxAttempts; i++) {\n      try {\n        const response = await this.check(options);\n        if (response.status === 'Healthy') {\n          return response;\n        }\n      } catch {\n        // Continue trying - error is intentionally ignored\n      }\n\n      if (i < maxAttempts - 1) {\n        await new Promise(resolve => setTimeout(resolve, pollingInterval));\n      }\n    }\n\n    throw new Error(`Health check failed after ${maxAttempts} attempts`);\n  }\n}","/**\n * Image generation models and interfaces for OpenAI-compatible API\n */\n\nexport interface ImageGenerationRequest {\n  /**\n   * A text description of the desired image(s). The maximum length is 1000 characters for dall-e-2 and 4000 characters for dall-e-3.\n   */\n  prompt: string;\n\n  /**\n   * The model to use for image generation.\n   */\n  model?: string;\n\n  /**\n   * The number of images to generate. Must be between 1 and 10. For dall-e-3, only n=1 is supported.\n   */\n  n?: number;\n\n  /**\n   * The quality of the image that will be generated. hd creates images with finer details and greater consistency across the image. This param is only supported for dall-e-3.\n   */\n  quality?: 'standard' | 'hd';\n\n  /**\n   * The format in which the generated images are returned. Must be one of url or b64_json.\n   */\n  response_format?: 'url' | 'b64_json';\n\n  /**\n   * The size of the generated images. Must be one of 256x256, 512x512, or 1024x1024 for dall-e-2. Must be one of 1024x1024, 1792x1024, or 1024x1792 for dall-e-3 models.\n   */\n  size?: '256x256' | '512x512' | '1024x1024' | '1792x1024' | '1024x1792';\n\n  /**\n   * The style of the generated images. Must be one of vivid or natural. Vivid causes the model to lean towards generating hyper-real and dramatic images. Natural causes the model to produce more natural, less hyper-real looking images. This param is only supported for dall-e-3.\n   */\n  style?: 'vivid' | 'natural';\n\n  /**\n   * A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. Learn more.\n   */\n  user?: string;\n}\n\nexport interface ImageData {\n  /**\n   * The base64-encoded JSON of the generated image, if response_format is b64_json.\n   */\n  b64_json?: string;\n\n  /**\n   * The URL of the generated image, if response_format is url (default).\n   */\n  url?: string;\n\n  /**\n   * The prompt that was used to generate the image, if there was any revision to the prompt.\n   */\n  revised_prompt?: string;\n}\n\nexport interface ImageGenerationResponse {\n  /**\n   * The Unix timestamp (in seconds) when the image was created.\n   */\n  created: number;\n\n  /**\n   * The list of generated images.\n   */\n  data: ImageData[];\n}\n\nexport interface ImageEditRequest {\n  /**\n   * The image to edit. Must be a valid PNG file, less than 4MB, and square. If mask is not provided, image must have transparency, which will be used as the mask.\n   */\n  image: File | Blob;\n\n  /**\n   * A text description of the desired image(s). The maximum length is 1000 characters.\n   */\n  prompt: string;\n\n  /**\n   * An additional image whose fully transparent areas (e.g. where alpha is zero) indicate where image should be edited. Must be a valid PNG file, less than 4MB, and have the same dimensions as image.\n   */\n  mask?: File | Blob;\n\n  /**\n   * The model to use for image editing. Only dall-e-2 is supported at this time.\n   */\n  model?: string;\n\n  /**\n   * The number of images to generate. Must be between 1 and 10.\n   */\n  n?: number;\n\n  /**\n   * The format in which the generated images are returned. Must be one of url or b64_json.\n   */\n  response_format?: 'url' | 'b64_json';\n\n  /**\n   * The size of the generated images. Must be one of 256x256, 512x512, or 1024x1024.\n   */\n  size?: '256x256' | '512x512' | '1024x1024';\n\n  /**\n   * A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse.\n   */\n  user?: string;\n}\n\nexport interface ImageVariationRequest {\n  /**\n   * The image to use as the basis for the variation(s). Must be a valid PNG file, less than 4MB, and square.\n   */\n  image: File | Blob;\n\n  /**\n   * The model to use for image variation. Only dall-e-2 is supported at this time.\n   */\n  model?: string;\n\n  /**\n   * The number of images to generate. Must be between 1 and 10.\n   */\n  n?: number;\n\n  /**\n   * The format in which the generated images are returned. Must be one of url or b64_json.\n   */\n  response_format?: 'url' | 'b64_json';\n\n  /**\n   * The size of the generated images. Must be one of 256x256, 512x512, or 1024x1024.\n   */\n  size?: '256x256' | '512x512' | '1024x1024';\n\n  /**\n   * A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse.\n   */\n  user?: string;\n}\n\nexport type ImageEditResponse = ImageGenerationResponse;\nexport type ImageVariationResponse = ImageGenerationResponse;\n\n/**\n * Supported image generation models\n */\nexport const IMAGE_MODELS = {\n  DALL_E_2: 'dall-e-2',\n  DALL_E_3: 'dall-e-3',\n  MINIMAX_IMAGE: 'minimax-image',\n} as const;\n\nexport type ImageModel = typeof IMAGE_MODELS[keyof typeof IMAGE_MODELS];\n\n/**\n * Model-specific capabilities and constraints\n */\nexport const IMAGE_MODEL_CAPABILITIES = {\n  [IMAGE_MODELS.DALL_E_2]: {\n    maxPromptLength: 1000,\n    supportedSizes: ['256x256', '512x512', '1024x1024'] as const,\n    supportedQualities: ['standard'] as const,\n    supportedStyles: [] as const,\n    maxImages: 10,\n    supportsEdit: true,\n    supportsVariation: true,\n  },\n  [IMAGE_MODELS.DALL_E_3]: {\n    maxPromptLength: 4000,\n    supportedSizes: ['1024x1024', '1792x1024', '1024x1792'] as const,\n    supportedQualities: ['standard', 'hd'] as const,\n    supportedStyles: ['vivid', 'natural'] as const,\n    maxImages: 1,\n    supportsEdit: false,\n    supportsVariation: false,\n  },\n  [IMAGE_MODELS.MINIMAX_IMAGE]: {\n    maxPromptLength: 2000,\n    supportedSizes: ['1024x1024', '1792x1024', '1024x1792'] as const,\n    supportedQualities: ['standard', 'hd'] as const,\n    supportedStyles: ['vivid', 'natural'] as const,\n    maxImages: 4,\n    supportsEdit: false,\n    supportsVariation: false,\n  },\n} as const;\n\n/**\n * Default values for image generation requests\n */\nexport const IMAGE_DEFAULTS = {\n  model: IMAGE_MODELS.DALL_E_3,\n  n: 1,\n  quality: 'standard' as const,\n  response_format: 'url' as const,\n  size: '1024x1024' as const,\n  style: 'vivid' as const,\n} as const;\n\n/**\n * Async image generation request extending the basic generation request\n */\nexport interface AsyncImageGenerationRequest extends ImageGenerationRequest {\n  /**\n   * The webhook URL to receive the result when generation is complete\n   */\n  webhook_url?: string;\n\n  /**\n   * Additional metadata to include with the webhook callback\n   */\n  webhook_metadata?: Record<string, unknown>;\n\n  /**\n   * The timeout for the generation task in seconds (1-3600)\n   */\n  timeout_seconds?: number;\n}\n\n/**\n * Task status for async operations\n */\nexport type TaskStatus = \n  | 'pending' \n  | 'running' \n  | 'completed' \n  | 'failed' \n  | 'cancelled' \n  | 'timedout';\n\n/**\n * Response from an async image generation request\n */\nexport interface AsyncImageGenerationResponse {\n  /**\n   * The unique task identifier\n   */\n  task_id: string;\n\n  /**\n   * The current status of the task\n   */\n  status: TaskStatus;\n\n  /**\n   * The progress percentage (0-100)\n   */\n  progress: number;\n\n  /**\n   * An optional progress message\n   */\n  message?: string;\n\n  /**\n   * The estimated time to completion in seconds\n   */\n  estimated_time_to_completion?: number;\n\n  /**\n   * When the task was created\n   */\n  created_at: string;\n\n  /**\n   * When the task was last updated\n   */\n  updated_at: string;\n\n  /**\n   * The generation result, available when status is 'completed'\n   */\n  result?: ImageGenerationResponse;\n\n  /**\n   * Error information if the task failed\n   */\n  error?: string;\n}\n\n/**\n * Options for polling task status\n */\nexport interface TaskPollingOptions {\n  /**\n   * The polling interval in milliseconds (default: 1000)\n   */\n  intervalMs?: number;\n\n  /**\n   * The maximum polling timeout in milliseconds (default: 300000 - 5 minutes)\n   */\n  timeoutMs?: number;\n\n  /**\n   * Whether to use exponential backoff for polling intervals (default: true)\n   */\n  useExponentialBackoff?: boolean;\n\n  /**\n   * The maximum interval between polls in milliseconds when using exponential backoff (default: 10000)\n   */\n  maxIntervalMs?: number;\n}\n\n/**\n * Default polling options\n */\nexport const DEFAULT_POLLING_OPTIONS: Required<TaskPollingOptions> = {\n  intervalMs: 1000,\n  timeoutMs: 300000, // 5 minutes\n  useExponentialBackoff: true,\n  maxIntervalMs: 10000, // 10 seconds\n} as const;\n\n/**\n * Image generation streaming chunk\n */\nexport interface ImageGenerationChunk {\n  id: string;\n  object: 'image.generation.chunk';\n  created: number;\n  data: Partial<ImageData>[];\n  progress?: number;\n  message?: string;\n}","import type { ChatCompletionRequest, TextContent, ImageContent } from '../models/chat';\nimport { ValidationError } from './errors';\nimport { IMAGE_MODEL_CAPABILITIES, type ImageGenerationRequest } from '../models/images';\nimport { ChatRoleHelpers, ImageValidationHelpers } from '../constants';\n\n/**\n * Validates multi-modal content array\n */\nfunction validateMultiModalContent(content: Array<TextContent | ImageContent>, messageIndex: number): void {\n  if (content.length === 0) {\n    throw new ValidationError(\n      `Message at index ${messageIndex} has empty content array`,\n      { field: 'messages' }\n    );\n  }\n\n  let imageCount = 0;\n\n  for (let j = 0; j < content.length; j++) {\n    const part = content[j];\n    \n    if (!part || typeof part !== 'object') {\n      throw new ValidationError(\n        `Content part at index ${j} in message ${messageIndex} must be an object`,\n        { field: 'messages' }\n      );\n    }\n\n    if (!part.type) {\n      throw new ValidationError(\n        `Content part at index ${j} in message ${messageIndex} must have a type`,\n        { field: 'messages' }\n      );\n    }\n\n    if (part.type === 'text') {\n      const textPart = part;\n      if (typeof textPart.text !== 'string') {\n        throw new ValidationError(\n          `Text content at index ${j} in message ${messageIndex} must have a string 'text' property`,\n          { field: 'messages' }\n        );\n      }\n    } else if (part.type === 'image_url') {\n      const imagePart = part;\n      if (!imagePart.image_url || typeof imagePart.image_url !== 'object') {\n        throw new ValidationError(\n          `Image content at index ${j} in message ${messageIndex} must have an 'image_url' object`,\n          { field: 'messages' }\n        );\n      }\n      \n      if (!imagePart.image_url.url || typeof imagePart.image_url.url !== 'string') {\n        throw new ValidationError(\n          `Image URL at index ${j} in message ${messageIndex} must have a string 'url' property`,\n          { field: 'messages' }\n        );\n      }\n\n      // Validate image URL format (either http(s) URL or base64 data URL)\n      const url = imagePart.image_url.url;\n      if (!url.startsWith('http://') && !url.startsWith('https://') && !url.startsWith('data:image/')) {\n        throw new ValidationError(\n          `Image URL at index ${j} in message ${messageIndex} must be an HTTP(S) URL or base64 data URL`,\n          { field: 'messages' }\n        );\n      }\n\n      // Validate detail level if provided\n      if (imagePart.image_url.detail !== undefined) {\n        const validDetails = ['low', 'high', 'auto'];\n        if (!validDetails.includes(imagePart.image_url.detail)) {\n          throw new ValidationError(\n            `Image detail at index ${j} in message ${messageIndex} must be one of: ${validDetails.join(', ')}`,\n            { field: 'messages' }\n          );\n        }\n      }\n\n      imageCount++;\n    } else {\n      throw new ValidationError(\n        `Unknown content type '${(part as Record<string, unknown>).type}' at index ${j} in message ${messageIndex}. Must be 'text' or 'image_url'`,\n        { field: 'messages' }\n      );\n    }\n  }\n\n  // Warn if there are many images (but don't fail validation)\n  if (imageCount > 10) {\n    console.warn(`Message at index ${messageIndex} contains ${imageCount} images. This may impact performance and token usage.`);\n  }\n}\n\nexport function validateChatCompletionRequest(request: ChatCompletionRequest): void {\n  if (!request.model) {\n    throw new ValidationError('Model is required', { field: 'model' });\n  }\n\n  if (!request.messages || !Array.isArray(request.messages)) {\n    throw new ValidationError('Messages must be an array', { field: 'messages' });\n  }\n\n  if (request.messages.length === 0) {\n    throw new ValidationError('Messages array cannot be empty', { field: 'messages' });\n  }\n\n  for (let i = 0; i < request.messages.length; i++) {\n    const message = request.messages[i];\n    \n    if (!message.role) {\n      throw new ValidationError(`Message at index ${i} must have a role`, { field: 'messages' });\n    }\n\n    if (!ChatRoleHelpers.isValidRole(message.role)) {\n      throw new ValidationError(\n        `Invalid role '${String(message.role)}' at index ${i}. Must be one of: ${ChatRoleHelpers.getAllRoles().join(', ')}`,\n        { field: 'messages' }\n      );\n    }\n\n    // Validate content\n    if (message.content === null && !message.tool_calls) {\n      throw new ValidationError(\n        `Message at index ${i} must have content or tool_calls`,\n        { field: 'messages' }\n      );\n    }\n\n    // Validate multi-modal content if it's an array\n    if (Array.isArray(message.content)) {\n      validateMultiModalContent(message.content, i);\n    }\n\n    if (message.role === 'tool' && !message.tool_call_id) {\n      throw new ValidationError(\n        `Tool message at index ${i} must have tool_call_id`,\n        { field: 'messages' }\n      );\n    }\n  }\n\n  if (request.temperature !== undefined) {\n    if (request.temperature < 0 || request.temperature > 2) {\n      throw new ValidationError('Temperature must be between 0 and 2', { field: 'temperature' });\n    }\n  }\n\n  if (request.top_p !== undefined) {\n    if (request.top_p < 0 || request.top_p > 1) {\n      throw new ValidationError('top_p must be between 0 and 1', { field: 'top_p' });\n    }\n  }\n\n  if (request.frequency_penalty !== undefined) {\n    if (request.frequency_penalty < -2 || request.frequency_penalty > 2) {\n      throw new ValidationError('frequency_penalty must be between -2 and 2', { field: 'frequency_penalty' });\n    }\n  }\n\n  if (request.presence_penalty !== undefined) {\n    if (request.presence_penalty < -2 || request.presence_penalty > 2) {\n      throw new ValidationError('presence_penalty must be between -2 and 2', { field: 'presence_penalty' });\n    }\n  }\n\n  if (request.n !== undefined && request.n < 1) {\n    throw new ValidationError('n must be at least 1', { field: 'n' });\n  }\n\n  if (request.max_tokens !== undefined && request.max_tokens < 1) {\n    throw new ValidationError('max_tokens must be at least 1', { field: 'max_tokens' });\n  }\n}\n\nexport function validateImageGenerationRequest(request: ImageGenerationRequest): void {\n  if (!request.prompt) {\n    throw new ValidationError('Prompt is required', { field: 'prompt' });\n  }\n\n  if (request.prompt.trim().length === 0) {\n    throw new ValidationError('Prompt cannot be empty', { field: 'prompt' });\n  }\n\n  // Validate model-specific constraints\n  if (request.model && IMAGE_MODEL_CAPABILITIES[request.model as keyof typeof IMAGE_MODEL_CAPABILITIES]) {\n    const capabilities = IMAGE_MODEL_CAPABILITIES[request.model as keyof typeof IMAGE_MODEL_CAPABILITIES];\n    \n    if (request.prompt.length > capabilities.maxPromptLength) {\n      throw new ValidationError(\n        `Prompt exceeds maximum length of ${capabilities.maxPromptLength} characters for model ${request.model}`,\n        { field: 'prompt' }\n      );\n    }\n\n    if (request.n !== undefined && request.n > capabilities.maxImages) {\n      throw new ValidationError(\n        `Number of images (${request.n}) exceeds maximum of ${capabilities.maxImages} for model ${request.model}`,\n        { field: 'n' }\n      );\n    }\n\n    if (request.size && !(capabilities.supportedSizes as readonly string[]).includes(request.size)) {\n      throw new ValidationError(\n        `Size '${request.size}' is not supported for model ${request.model}. Supported sizes: ${capabilities.supportedSizes.join(', ')}`,\n        { field: 'size' }\n      );\n    }\n\n    if (request.quality && !(capabilities.supportedQualities as readonly string[]).includes(request.quality)) {\n      throw new ValidationError(\n        `Quality '${request.quality}' is not supported for model ${request.model}. Supported qualities: ${capabilities.supportedQualities.join(', ')}`,\n        { field: 'quality' }\n      );\n    }\n\n    if (request.style && capabilities.supportedStyles.length > 0 && !(capabilities.supportedStyles as readonly string[]).includes(request.style)) {\n      throw new ValidationError(\n        `Style '${request.style}' is not supported for model ${request.model}. Supported styles: ${capabilities.supportedStyles.join(', ')}`,\n        { field: 'style' }\n      );\n    }\n  }\n\n  // General validations\n  if (request.n !== undefined && (request.n < 1 || request.n > 10)) {\n    throw new ValidationError('Number of images must be between 1 and 10', { field: 'n' });\n  }\n\n  if (request.response_format && !ImageValidationHelpers.isValidResponseFormat(request.response_format)) {\n    throw new ValidationError(`response_format must be one of: ${ImageValidationHelpers.getAllResponseFormats().join(', ')}`, { field: 'response_format' });\n  }\n\n  if (request.quality && !ImageValidationHelpers.isValidQuality(request.quality)) {\n    throw new ValidationError(`quality must be one of: ${ImageValidationHelpers.getAllQualities().join(', ')}`, { field: 'quality' });\n  }\n\n  if (request.style && !ImageValidationHelpers.isValidStyle(request.style)) {\n    throw new ValidationError(`style must be one of: ${ImageValidationHelpers.getAllStyles().join(', ')}`, { field: 'style' });\n  }\n\n  if (request.size && !ImageValidationHelpers.isValidSize(request.size)) {\n    throw new ValidationError(\n      `size must be one of: ${ImageValidationHelpers.getAllSizes().join(', ')}`,\n      { field: 'size' }\n    );\n  }\n}","import { FetchBasedClient } from '../client/FetchBasedClient';\nimport type { RequestOptions } from '../client/types';\nimport { \n  type ImageGenerationRequest, \n  type ImageGenerationResponse,\n  type ImageEditRequest,\n  type ImageEditResponse,\n  type ImageVariationRequest,\n  type ImageVariationResponse,\n  type AsyncImageGenerationRequest,\n  type AsyncImageGenerationResponse,\n  type TaskPollingOptions,\n  DEFAULT_POLLING_OPTIONS\n} from '../models/images';\nimport { validateImageGenerationRequest } from '../utils/validation';\nimport { API_ENDPOINTS, CONTENT_TYPES } from '../constants';\n\n/**\n * Service for image generation, editing, and variation operations.\n * Provides OpenAI-compatible image API endpoints for DALL-E and other image models.\n * \n * @example\n * ```typescript\n * // Initialize the service\n * const images = client.images;\n * \n * // Generate an image\n * const result = await images.generate({\n *   prompt: 'A sunset over mountains',\n *   size: '1024x1024',\n *   quality: 'hd'\n * });\n * \n * // Edit an image\n * const edited = await images.edit({\n *   image: imageFile,\n *   prompt: 'Add a rainbow to the sky',\n *   mask: maskFile\n * });\n * ```\n */\nexport class ImagesService extends FetchBasedClient {\n  constructor(client: FetchBasedClient) {\n    // Access the protected config property through inheritance\n    // @ts-expect-error Accessing protected property from another instance\n    super(client.config);\n  }\n\n  /**\n   * Creates an image given a text prompt.\n   * Supports various sizes, styles, and quality settings based on the model.\n   * \n   * @param request - The image generation request\n   * @param options - Optional request options\n   * @returns Promise resolving to image generation response\n   * \n   * @example\n   * ```typescript\n   * // Basic image generation\n   * const result = await images.generate({\n   *   prompt: 'A serene lake at sunset',\n   *   n: 1\n   * });\n   * console.log(result.data[0].url);\n   * \n   * // High quality with specific size\n   * const hdResult = await images.generate({\n   *   prompt: 'A futuristic city skyline',\n   *   model: 'dall-e-3',\n   *   size: '1792x1024',\n   *   quality: 'hd',\n   *   style: 'vivid'\n   * });\n   * \n   * // Get base64 encoded image\n   * const base64Result = await images.generate({\n   *   prompt: 'Abstract art',\n   *   response_format: 'b64_json'\n   * });\n   * ```\n   */\n  async generate(\n    request: ImageGenerationRequest,\n    options?: RequestOptions\n  ): Promise<ImageGenerationResponse> {\n    validateImageGenerationRequest(request);\n\n    return this.post<ImageGenerationResponse, ImageGenerationRequest>(\n      API_ENDPOINTS.V1.IMAGES.GENERATIONS,\n      request,\n      options\n    );\n  }\n\n  /**\n   * Creates an edited or extended image given an original image and a prompt.\n   * The mask specifies which areas should be edited. Transparent areas in the mask indicate where edits should be applied.\n   * \n   * @param request - The image edit request\n   * @param options - Optional request options\n   * @returns Promise resolving to image edit response\n   * \n   * @example\n   * ```typescript\n   * // Edit with a mask\n   * const edited = await images.edit({\n   *   image: originalImageFile,\n   *   mask: maskFile,\n   *   prompt: 'Replace the sky with a starry night',\n   *   n: 1\n   * });\n   * \n   * // Edit using image transparency as mask\n   * const result = await images.edit({\n   *   image: transparentPngFile,\n   *   prompt: 'Add a garden in the transparent area',\n   *   size: '512x512'\n   * });\n   * ```\n   */\n  async edit(\n    request: ImageEditRequest,\n    options?: RequestOptions\n  ): Promise<ImageEditResponse> {\n    const formData = new FormData();\n    formData.append('image', request.image);\n    formData.append('prompt', request.prompt);\n    \n    if (request.mask) {\n      formData.append('mask', request.mask);\n    }\n    if (request.model) {\n      formData.append('model', request.model);\n    }\n    if (request.n !== undefined) {\n      formData.append('n', request.n.toString());\n    }\n    if (request.response_format) {\n      formData.append('response_format', request.response_format);\n    }\n    if (request.size) {\n      formData.append('size', request.size);\n    }\n    if (request.user) {\n      formData.append('user', request.user);\n    }\n\n    return this.post<ImageEditResponse, FormData>(\n      API_ENDPOINTS.V1.IMAGES.EDITS,\n      formData,\n      {\n        ...options,\n        headers: {\n          ...options?.headers,\n          'Content-Type': CONTENT_TYPES.FORM_DATA,\n        },\n      }\n    );\n  }\n\n  /**\n   * Creates a variation of a given image.\n   * Generates new images that maintain the same general composition but with variations.\n   * \n   * @param request - The image variation request\n   * @param options - Optional request options\n   * @returns Promise resolving to image variation response\n   * \n   * @example\n   * ```typescript\n   * // Create variations\n   * const variations = await images.createVariation({\n   *   image: originalImageFile,\n   *   n: 3,\n   *   size: '1024x1024'\n   * });\n   * \n   * // Get variations as base64\n   * const base64Variations = await images.createVariation({\n   *   image: imageFile,\n   *   n: 2,\n   *   response_format: 'b64_json'\n   * });\n   * ```\n   */\n  async createVariation(\n    request: ImageVariationRequest,\n    options?: RequestOptions\n  ): Promise<ImageVariationResponse> {\n    const formData = new FormData();\n    formData.append('image', request.image);\n    \n    if (request.model) {\n      formData.append('model', request.model);\n    }\n    if (request.n !== undefined) {\n      formData.append('n', request.n.toString());\n    }\n    if (request.response_format) {\n      formData.append('response_format', request.response_format);\n    }\n    if (request.size) {\n      formData.append('size', request.size);\n    }\n    if (request.user) {\n      formData.append('user', request.user);\n    }\n\n    return this.post<ImageVariationResponse, FormData>(\n      API_ENDPOINTS.V1.IMAGES.VARIATIONS,\n      formData,\n      {\n        ...options,\n        headers: {\n          ...options?.headers,\n          'Content-Type': CONTENT_TYPES.FORM_DATA,\n        },\n      }\n    );\n  }\n\n  /**\n   * Creates an image asynchronously given a text prompt.\n   * @param request The async image generation request\n   * @param options Optional request options\n   * @returns Promise resolving to async task information\n   */\n  async generateAsync(\n    request: AsyncImageGenerationRequest,\n    options?: RequestOptions\n  ): Promise<AsyncImageGenerationResponse> {\n    validateImageGenerationRequest(request);\n\n    // Validate async-specific fields\n    if (request.timeout_seconds !== undefined && \n        (request.timeout_seconds < 1 || request.timeout_seconds > 3600)) {\n      throw new Error('Timeout must be between 1 and 3600 seconds');\n    }\n\n    if (request.webhook_url) {\n      try {\n        const url = new URL(request.webhook_url);\n        if (!['http:', 'https:'].includes(url.protocol)) {\n          throw new Error('WebhookUrl must be a valid HTTP or HTTPS URL');\n        }\n      } catch {\n        throw new Error('WebhookUrl must be a valid HTTP or HTTPS URL');\n      }\n    }\n\n    return this.post<AsyncImageGenerationResponse, AsyncImageGenerationRequest>(\n      API_ENDPOINTS.V1.IMAGES.ASYNC_GENERATIONS,\n      request,\n      options\n    );\n  }\n\n  /**\n   * Gets the status of an async image generation task.\n   * @param taskId The task identifier\n   * @param options Optional request options\n   * @returns Promise resolving to the current task status\n   */\n  async getTaskStatus(\n    taskId: string,\n    options?: RequestOptions\n  ): Promise<AsyncImageGenerationResponse> {\n    if (!taskId?.trim()) {\n      throw new Error('Task ID is required');\n    }\n\n    return this.get<AsyncImageGenerationResponse>(\n      API_ENDPOINTS.V1.IMAGES.TASK_STATUS(taskId),\n      options\n    );\n  }\n\n  /**\n   * Cancels a pending or running async image generation task.\n   * @param taskId The task identifier\n   * @param options Optional request options\n   */\n  async cancelTask(\n    taskId: string,\n    options?: RequestOptions\n  ): Promise<void> {\n    if (!taskId?.trim()) {\n      throw new Error('Task ID is required');\n    }\n\n    await this.delete<void>(\n      API_ENDPOINTS.V1.IMAGES.CANCEL_TASK(taskId),\n      options\n    );\n  }\n\n  /**\n   * Polls an async image generation task until completion or timeout.\n   * Automatically handles retries with configurable intervals and backoff.\n   * \n   * @param taskId - The task identifier\n   * @param pollingOptions - Polling configuration options\n   * @param requestOptions - Optional request options\n   * @returns Promise resolving to the final generation result\n   * \n   * @example\n   * ```typescript\n   * // Start async generation\n   * const task = await images.generateAsync({\n   *   prompt: 'Complex artistic scene',\n   *   quality: 'hd',\n   *   size: '1792x1024'\n   * });\n   * \n   * // Poll until complete with default settings\n   * const result = await images.pollTaskUntilCompletion(task.task_id);\n   * \n   * // Custom polling configuration\n   * const customResult = await images.pollTaskUntilCompletion(\n   *   task.task_id,\n   *   {\n   *     intervalMs: 2000,\n   *     timeoutMs: 300000, // 5 minutes\n   *     useExponentialBackoff: true\n   *   }\n   * );\n   * ```\n   */\n  async pollTaskUntilCompletion(\n    taskId: string,\n    pollingOptions?: TaskPollingOptions,\n    requestOptions?: RequestOptions\n  ): Promise<ImageGenerationResponse> {\n    if (!taskId?.trim()) {\n      throw new Error('Task ID is required');\n    }\n\n    const options = { ...DEFAULT_POLLING_OPTIONS, ...pollingOptions };\n    const startTime = Date.now();\n    let currentInterval = options.intervalMs;\n\n    for (;;) {\n      // Check timeout\n      if (Date.now() - startTime > options.timeoutMs) {\n        throw new Error(`Task polling timed out after ${options.timeoutMs}ms`);\n      }\n\n      const status = await this.getTaskStatus(taskId, requestOptions);\n\n      switch (status.status) {\n        case 'completed':\n          if (!status.result) {\n            throw new Error('Task completed but no result was provided');\n          }\n          return status.result;\n\n        case 'failed':\n          throw new Error(`Task failed: ${status.error ?? 'Unknown error'}`);\n\n        case 'cancelled':\n          throw new Error('Task was cancelled');\n\n        case 'timedout':\n          throw new Error('Task timed out');\n\n        case 'pending':\n        case 'running':\n          // Continue polling\n          break;\n\n        default:\n          throw new Error(`Unknown task status: ${String(status.status)}`);\n      }\n\n      // Wait before next poll\n      await new Promise(resolve => setTimeout(resolve, currentInterval));\n\n      // Apply exponential backoff if enabled\n      if (options.useExponentialBackoff) {\n        currentInterval = Math.min(currentInterval * 2, options.maxIntervalMs);\n      }\n    }\n  }\n}","import type { FetchBasedClient } from './FetchBasedClient';\nimport type { RequestOptions } from './types';\nimport type { HttpMethod } from './HttpMethod';\n\n/**\n * Interface exposing the protected methods of FetchBasedClient\n * This is used by services that need to access the client's methods\n */\nexport interface IFetchBasedClientAdapter {\n  request<TResponse = unknown>(\n    urlOrConfig: string | { method: HttpMethod; url: string; body?: unknown },\n    options?: RequestOptions & { method?: HttpMethod; body?: unknown }\n  ): Promise<TResponse>;\n  \n  get<TResponse = unknown>(\n    url: string,\n    options?: RequestOptions\n  ): Promise<TResponse>;\n  \n  post<TResponse = unknown, TRequest = unknown>(\n    url: string,\n    data?: TRequest,\n    options?: RequestOptions\n  ): Promise<TResponse>;\n  \n  put<TResponse = unknown, TRequest = unknown>(\n    url: string,\n    data?: TRequest,\n    options?: RequestOptions\n  ): Promise<TResponse>;\n  \n  patch<TResponse = unknown, TRequest = unknown>(\n    url: string,\n    data?: TRequest,\n    options?: RequestOptions\n  ): Promise<TResponse>;\n  \n  delete<TResponse = unknown>(\n    url: string,\n    options?: RequestOptions\n  ): Promise<TResponse>;\n}\n\n/**\n * Type guard to check if a client has the required methods\n */\nexport function isClientAdapter(client: unknown): client is IFetchBasedClientAdapter {\n  return (\n    client !== null &&\n    typeof client === 'object' &&\n    'request' in client &&\n    'get' in client &&\n    'post' in client &&\n    'put' in client &&\n    'patch' in client &&\n    'delete' in client\n  );\n}\n\n/**\n * Internal interface to access protected methods of FetchBasedClient\n * This avoids using 'any' while maintaining type safety\n */\ninterface IFetchBasedClientInternal {\n  request<TResponse = unknown>(\n    urlOrConfig: string | { method: HttpMethod; url: string; body?: unknown },\n    options?: RequestOptions & { method?: HttpMethod; body?: unknown }\n  ): Promise<TResponse>;\n  \n  get<TResponse = unknown>(\n    url: string,\n    options?: RequestOptions\n  ): Promise<TResponse>;\n  \n  post<TResponse = unknown, TRequest = unknown>(\n    url: string,\n    data?: TRequest,\n    options?: RequestOptions\n  ): Promise<TResponse>;\n  \n  put<TResponse = unknown, TRequest = unknown>(\n    url: string,\n    data?: TRequest,\n    options?: RequestOptions\n  ): Promise<TResponse>;\n  \n  patch<TResponse = unknown, TRequest = unknown>(\n    url: string,\n    data?: TRequest,\n    options?: RequestOptions\n  ): Promise<TResponse>;\n  \n  delete<TResponse = unknown>(\n    url: string,\n    options?: RequestOptions\n  ): Promise<TResponse>;\n}\n\n/**\n * Adapter to safely access protected methods of FetchBasedClient\n */\nexport function createClientAdapter(client: FetchBasedClient): IFetchBasedClientAdapter {\n  // Cast to internal interface to access protected methods with proper typing\n  const internalClient = client as unknown as IFetchBasedClientInternal;\n  \n  return {\n    request: <TResponse = unknown>(urlOrConfig: string | { method: HttpMethod; url: string; body?: unknown }, options?: RequestOptions & { method?: HttpMethod; body?: unknown }) => \n      internalClient.request<TResponse>(urlOrConfig, options),\n    get: <TResponse = unknown>(url: string, options?: RequestOptions) => \n      internalClient.get<TResponse>(url, options),\n    post: <TResponse = unknown, TRequest = unknown>(url: string, data?: TRequest, options?: RequestOptions) => \n      internalClient.post<TResponse, TRequest>(url, data, options),\n    put: <TResponse = unknown, TRequest = unknown>(url: string, data?: TRequest, options?: RequestOptions) => \n      internalClient.put<TResponse, TRequest>(url, data, options),\n    patch: <TResponse = unknown, TRequest = unknown>(url: string, data?: TRequest, options?: RequestOptions) => \n      internalClient.patch<TResponse, TRequest>(url, data, options),\n    delete: <TResponse = unknown>(url: string, options?: RequestOptions) => \n      internalClient.delete<TResponse>(url, options),\n  };\n}","/**\n * Video generation models and types for the Conduit Core API\n */\n\nimport type { VideoWebhookMetadata } from './metadata';\n\n/**\n * Request for generating a video from a text prompt\n */\nexport interface VideoGenerationRequest {\n  /** The text prompt that describes what video to generate */\n  prompt: string;\n  \n  /** The model to use for video generation (e.g., \"minimax-video\") */\n  model?: string;\n  \n  /** The duration of the video in seconds. Defaults to 5 seconds */\n  duration?: number;\n  \n  /** The size/resolution of the video (e.g., \"1920x1080\", \"1280x720\") */\n  size?: string;\n  \n  /** Frames per second for the video. Common values: 24, 30, 60 */\n  fps?: number;\n  \n  /** The style or aesthetic of the video generation */\n  style?: string;\n  \n  /** The format in which the generated video is returned. Options: \"url\" (default) or \"b64_json\" */\n  response_format?: 'url' | 'b64_json';\n  \n  /** A unique identifier representing your end-user */\n  user?: string;\n  \n  /** Optional seed for deterministic generation */\n  seed?: number;\n  \n  /** The number of videos to generate. Defaults to 1 */\n  n?: number;\n}\n\n/**\n * Response from a video generation request\n */\nexport interface VideoGenerationResponse {\n  /** Unix timestamp of when the response was created */\n  created: number;\n  \n  /** List of generated video data */\n  data: VideoData[];\n  \n  /** The model used for generation */\n  model?: string;\n  \n  /** Usage information if available */\n  usage?: VideoUsage;\n}\n\n/**\n * A single generated video\n */\nexport interface VideoData {\n  /** The URL of the generated video, if response_format is \"url\" */\n  url?: string;\n  \n  /** The base64-encoded video data, if response_format is \"b64_json\" */\n  b64_json?: string;\n  \n  /** The revised prompt that was used for generation */\n  revised_prompt?: string;\n  \n  /** Additional metadata about the generated video */\n  metadata?: VideoMetadata;\n}\n\n/**\n * Usage statistics for video generation\n */\nexport interface VideoUsage {\n  /** The number of prompt tokens used */\n  prompt_tokens: number;\n  \n  /** The total number of tokens used */\n  total_tokens: number;\n  \n  /** The duration processed in seconds */\n  duration_seconds?: number;\n  \n  /** The total processing time in seconds */\n  processing_time_seconds?: number;\n}\n\n/**\n * Metadata about a generated video\n */\nexport interface VideoMetadata {\n  /** The actual duration of the generated video in seconds */\n  duration?: number;\n  \n  /** The resolution of the generated video */\n  resolution?: string;\n  \n  /** The frames per second of the generated video */\n  fps?: number;\n  \n  /** The file size in bytes */\n  file_size_bytes?: number;\n  \n  /** The video format/codec */\n  format?: string;\n  \n  /** The video codec used for encoding */\n  codec?: string;\n  \n  /** The audio codec used for encoding */\n  audio_codec?: string;\n  \n  /** The bitrate of the video */\n  bitrate?: number;\n  \n  /** The MIME type of the video file */\n  mime_type?: string;\n  \n  /** The seed used for generation, if any */\n  seed?: number;\n}\n\n/**\n * Request for async video generation\n */\nexport interface AsyncVideoGenerationRequest extends VideoGenerationRequest {\n  /** The webhook URL to receive the result when generation is complete */\n  webhook_url?: string;\n  \n  /** Additional metadata to include with the webhook callback */\n  webhook_metadata?: VideoWebhookMetadata;\n  \n  /** Additional headers to include with the webhook callback */\n  webhook_headers?: Record<string, string>;\n  \n  /** The timeout for the generation task in seconds */\n  timeout_seconds?: number;\n}\n\n/**\n * Response from an async video generation request\n */\nexport interface AsyncVideoGenerationResponse {\n  /** The unique task identifier */\n  task_id: string;\n  \n  /** The current status of the task */\n  status: VideoTaskStatus;\n  \n  /** The progress percentage (0-100) */\n  progress: number;\n  \n  /** An optional progress message */\n  message?: string;\n  \n  /** The estimated time to completion in seconds */\n  estimated_time_to_completion?: number;\n  \n  /** When the task was created */\n  created_at: string;\n  \n  /** When the task was last updated */\n  updated_at: string;\n  \n  /** The generation result, available when status is Completed */\n  result?: VideoGenerationResponse;\n  \n  /** Error information if the task failed */\n  error?: string;\n}\n\n/**\n * The status of an async video generation task\n */\nexport enum VideoTaskStatus {\n  /** Task is waiting to be processed */\n  Pending = 'Pending',\n  \n  /** Task is currently being processed */\n  Running = 'Running',\n  \n  /** Task completed successfully */\n  Completed = 'Completed',\n  \n  /** Task failed with an error */\n  Failed = 'Failed',\n  \n  /** Task was cancelled */\n  Cancelled = 'Cancelled',\n  \n  /** Task timed out */\n  TimedOut = 'TimedOut'\n}\n\n/**\n * Options for polling video task status\n */\nexport interface VideoTaskPollingOptions {\n  /** The polling interval in milliseconds */\n  intervalMs?: number;\n  \n  /** The maximum polling timeout in milliseconds */\n  timeoutMs?: number;\n  \n  /** Whether to use exponential backoff for polling intervals */\n  useExponentialBackoff?: boolean;\n  \n  /** The maximum interval between polls in milliseconds when using exponential backoff */\n  maxIntervalMs?: number;\n}\n\n/**\n * Common video models supported by Conduit\n */\nexport const VideoModels = {\n  /** MiniMax video generation model */\n  MINIMAX_VIDEO: 'minimax-video',\n  \n  /** Default video model */\n  DEFAULT: 'minimax-video'\n} as const;\n\n/**\n * Common video resolutions\n */\nexport const VideoResolutions = {\n  /** 720p resolution (1280x720) */\n  HD: '1280x720',\n  \n  /** 1080p resolution (1920x1080) */\n  FULL_HD: '1920x1080',\n  \n  /** Vertical 720p (720x1280) */\n  VERTICAL_HD: '720x1280',\n  \n  /** Vertical 1080p (1080x1920) */\n  VERTICAL_FULL_HD: '1080x1920',\n  \n  /** Square format (720x720) */\n  SQUARE: '720x720'\n} as const;\n\n/**\n * Video response formats\n */\nexport const VideoResponseFormats = {\n  /** Return video as URL (default) */\n  URL: 'url',\n  \n  /** Return video as base64-encoded JSON */\n  BASE64_JSON: 'b64_json'\n} as const;\n\n/**\n * Default values for video generation\n */\nexport const VideoDefaults = {\n  /** Default duration in seconds */\n  DURATION: 5,\n  \n  /** Default resolution */\n  RESOLUTION: VideoResolutions.HD,\n  \n  /** Default frames per second */\n  FPS: 30,\n  \n  /** Default response format */\n  RESPONSE_FORMAT: VideoResponseFormats.URL,\n  \n  /** Default polling interval in milliseconds */\n  POLLING_INTERVAL_MS: 2000,\n  \n  /** Default polling timeout in milliseconds */\n  POLLING_TIMEOUT_MS: 600000, // 10 minutes\n  \n  /** Default maximum polling interval in milliseconds */\n  MAX_POLLING_INTERVAL_MS: 30000 // 30 seconds\n} as const;\n\n/**\n * Capabilities of a video generation model\n */\nexport interface VideoModelCapabilities {\n  /** Maximum duration in seconds */\n  maxDuration: number;\n  \n  /** Supported resolutions */\n  supportedResolutions: string[];\n  \n  /** Supported FPS values */\n  supportedFps: number[];\n  \n  /** Whether the model supports custom styles */\n  supportsCustomStyles: boolean;\n  \n  /** Whether the model supports seed-based generation */\n  supportsSeed: boolean;\n  \n  /** Maximum number of videos that can be generated in one request */\n  maxVideos: number;\n}\n\n/**\n * Gets the capabilities for a specific video model\n */\nexport function getVideoModelCapabilities(model: string): VideoModelCapabilities {\n  const modelLower = model.toLowerCase();\n  \n  switch (modelLower) {\n    case 'minimax-video':\n    case 'minimax-video-01':\n      return {\n        maxDuration: 6,\n        supportedResolutions: [\n          VideoResolutions.HD,\n          VideoResolutions.FULL_HD,\n          VideoResolutions.VERTICAL_HD,\n          VideoResolutions.VERTICAL_FULL_HD,\n          '720x480'\n        ],\n        supportedFps: [24, 30],\n        supportsCustomStyles: true,\n        supportsSeed: true,\n        maxVideos: 1\n      };\n    \n    default:\n      return {\n        maxDuration: 60,\n        supportedResolutions: [\n          VideoResolutions.HD,\n          VideoResolutions.FULL_HD,\n          VideoResolutions.SQUARE\n        ],\n        supportedFps: [24, 30, 60],\n        supportsCustomStyles: true,\n        supportsSeed: true,\n        maxVideos: 10\n      };\n  }\n}\n\n/**\n * Validates a video generation request\n */\nexport function validateVideoGenerationRequest(request: VideoGenerationRequest): void {\n  if (!request.prompt || request.prompt.trim().length === 0) {\n    throw new Error('Prompt is required');\n  }\n  \n  if (request.n !== undefined && (request.n <= 0 || request.n > 10)) {\n    throw new Error('Number of videos must be between 1 and 10');\n  }\n  \n  if (request.duration !== undefined && (request.duration <= 0 || request.duration > 60)) {\n    throw new Error('Duration must be between 1 and 60 seconds');\n  }\n  \n  if (request.fps !== undefined && (request.fps <= 0 || request.fps > 120)) {\n    throw new Error('FPS must be between 1 and 120');\n  }\n  \n  if (request.response_format && \n      request.response_format !== VideoResponseFormats.URL && \n      request.response_format !== VideoResponseFormats.BASE64_JSON) {\n    throw new Error(`Response format must be '${String(VideoResponseFormats.URL)}' or '${String(VideoResponseFormats.BASE64_JSON)}'`);\n  }\n}\n\n/**\n * Validates an async video generation request\n */\nexport function validateAsyncVideoGenerationRequest(request: AsyncVideoGenerationRequest): void {\n  // First validate the base video generation request\n  validateVideoGenerationRequest(request);\n  \n  // Additional validation for async-specific fields\n  if (request.timeout_seconds !== undefined && \n      (request.timeout_seconds <= 0 || request.timeout_seconds > 3600)) {\n    throw new Error('Timeout must be between 1 and 3600 seconds');\n  }\n  \n  if (request.webhook_url && !isValidUrl(request.webhook_url)) {\n    throw new Error('WebhookUrl must be a valid HTTP or HTTPS URL');\n  }\n}\n\n/**\n * Helper function to validate URLs\n */\nfunction isValidUrl(url: string): boolean {\n  try {\n    const parsedUrl = new URL(url);\n    return parsedUrl.protocol === 'http:' || parsedUrl.protocol === 'https:';\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Base interface for webhook payloads sent by Conduit\n */\nexport interface WebhookPayloadBase {\n  /** The unique identifier for this webhook event */\n  event_id: string;\n  \n  /** The type of webhook event */\n  event_type: string;\n  \n  /** The timestamp when the event occurred */\n  timestamp: string;\n  \n  /** The task ID associated with this event */\n  task_id: string;\n  \n  /** Optional metadata provided in the original request */\n  metadata?: VideoWebhookMetadata;\n}\n\n/**\n * Webhook payload sent when video generation is completed\n */\nexport interface VideoCompletionWebhookPayload extends WebhookPayloadBase {\n  /** The final status of the video generation task */\n  status: VideoTaskStatus;\n  \n  /** The generated video result, if successful */\n  result?: VideoGenerationResponse;\n  \n  /** Error information if the task failed */\n  error?: string;\n  \n  /** The total processing time in seconds */\n  processing_time_seconds?: number;\n}\n\n/**\n * Webhook payload sent to provide progress updates during video generation\n */\nexport interface VideoProgressWebhookPayload extends WebhookPayloadBase {\n  /** The current status of the video generation task */\n  status: VideoTaskStatus;\n  \n  /** The progress percentage (0-100) */\n  progress: number;\n  \n  /** An optional progress message */\n  message?: string;\n  \n  /** The estimated time to completion in seconds */\n  estimated_time_to_completion?: number;\n}","import type { FetchBasedClient } from '../client/FetchBasedClient';\nimport { createClientAdapter, type IFetchBasedClientAdapter } from '../client/ClientAdapter';\nimport type { VideoApiRequest, AsyncVideoApiRequest } from '../models/common-types';\nimport {\n  VideoTaskStatus,\n  VideoDefaults,\n  VideoModels,\n  VideoResponseFormats,\n  validateAsyncVideoGenerationRequest,\n  getVideoModelCapabilities,\n  type VideoGenerationRequest,\n  type VideoGenerationResponse,\n  type AsyncVideoGenerationRequest,\n  type AsyncVideoGenerationResponse,\n  type VideoTaskPollingOptions,\n  type VideoModelCapabilities\n} from '../models/videos';\nimport { ConduitError } from '../utils/errors';\nimport type { VideoWebhookMetadata } from '../models/metadata';\n\n/**\n * Service for video generation operations using the Conduit Core API\n */\nexport class VideosService {\n  // Note: /v1/videos/generations endpoint does not exist - only async generation is supported\n  private static readonly ASYNC_GENERATIONS_ENDPOINT = '/v1/videos/generations/async';\n  private readonly clientAdapter: IFetchBasedClientAdapter;\n\n  constructor(client: FetchBasedClient) {\n    this.clientAdapter = createClientAdapter(client);\n  }\n\n  /**\n   * @deprecated The synchronous video generation endpoint does not exist. Use generateAsync() instead.\n   * This method has been removed to prevent runtime errors.\n   */\n  // Removed synchronous generate method - endpoint does not exist\n\n  /**\n   * Generates videos asynchronously from a text prompt\n   */\n  async generateAsync(\n    request: AsyncVideoGenerationRequest,\n    options?: { signal?: AbortSignal }\n  ): Promise<AsyncVideoGenerationResponse> {\n    try {\n      validateAsyncVideoGenerationRequest(request);\n\n      // Convert to API request format\n      const apiRequest = this.convertToAsyncApiRequest(request);\n\n      const response = await this.clientAdapter.post<AsyncVideoGenerationResponse, AsyncVideoApiRequest>(\n        VideosService.ASYNC_GENERATIONS_ENDPOINT,\n        apiRequest,\n        options\n      );\n\n      return response;\n    } catch (error) {\n      if (error instanceof ConduitError) {\n        throw error;\n      }\n      throw new ConduitError(\n        `Async video generation failed: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  /**\n   * Gets the status of an async video generation task\n   */\n  async getTaskStatus(\n    taskId: string,\n    options?: { signal?: AbortSignal }\n  ): Promise<AsyncVideoGenerationResponse> {\n    try {\n      if (!taskId || taskId.trim().length === 0) {\n        throw new Error('Task ID is required');\n      }\n\n      const endpoint = `/v1/videos/generations/tasks/${encodeURIComponent(taskId)}`;\n\n      const response = await this.clientAdapter.get<AsyncVideoGenerationResponse>(\n        endpoint,\n        options\n      );\n\n      return response;\n    } catch (error) {\n      if (error instanceof ConduitError) {\n        throw error;\n      }\n      throw new ConduitError(\n        `Failed to get task status: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  /**\n   * Cancels a pending or running async video generation task\n   */\n  async cancelTask(\n    taskId: string,\n    options?: { signal?: AbortSignal }\n  ): Promise<void> {\n    try {\n      if (!taskId || taskId.trim().length === 0) {\n        throw new Error('Task ID is required');\n      }\n\n      const endpoint = `/v1/videos/generations/${encodeURIComponent(taskId)}`;\n\n      await this.clientAdapter.delete<void>(\n        endpoint,\n        options\n      );\n    } catch (error) {\n      if (error instanceof ConduitError) {\n        throw error;\n      }\n      throw new ConduitError(\n        `Failed to cancel task: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  /**\n   * Polls an async video generation task until completion or timeout\n   */\n  async pollTaskUntilCompletion(\n    taskId: string,\n    pollingOptions?: VideoTaskPollingOptions,\n    options?: { signal?: AbortSignal }\n  ): Promise<VideoGenerationResponse> {\n    const opts: Required<VideoTaskPollingOptions> = {\n      intervalMs: pollingOptions?.intervalMs ?? VideoDefaults.POLLING_INTERVAL_MS,\n      timeoutMs: pollingOptions?.timeoutMs ?? VideoDefaults.POLLING_TIMEOUT_MS,\n      useExponentialBackoff: pollingOptions?.useExponentialBackoff ?? true,\n      maxIntervalMs: pollingOptions?.maxIntervalMs ?? VideoDefaults.MAX_POLLING_INTERVAL_MS,\n    };\n\n    if (!taskId || taskId.trim().length === 0) {\n      throw new Error('Task ID is required');\n    }\n\n    const startTime = Date.now();\n    let currentInterval = opts.intervalMs;\n\n    // Note: Starting to poll task\n\n    // Poll until task completes or fails\n    for (;;) {\n      // Check if operation was cancelled\n      if (options?.signal?.aborted) {\n        throw new ConduitError('Operation was cancelled');\n      }\n\n      // Check timeout\n      if (Date.now() - startTime > opts.timeoutMs) {\n        throw new ConduitError(\n          `Task polling timed out after ${opts.timeoutMs}ms`\n        );\n      }\n\n      const status = await this.getTaskStatus(taskId, options);\n\n      switch (status.status) {\n        case VideoTaskStatus.Completed:\n          if (!status.result) {\n            throw new ConduitError(\n              'Task completed but no result was provided'\n            );\n          }\n\n          // Task completed successfully\n          return status.result;\n\n        case VideoTaskStatus.Failed:\n          throw new ConduitError(\n            `Task failed: ${status.error ?? 'Unknown error'}`\n          );\n\n        case VideoTaskStatus.Cancelled:\n          throw new ConduitError('Task was cancelled');\n\n        case VideoTaskStatus.TimedOut:\n          throw new ConduitError('Task timed out');\n\n        case VideoTaskStatus.Pending:\n        case VideoTaskStatus.Running:\n          // Continue polling\n          break;\n\n        default:\n          throw new ConduitError(\n            `Unknown task status: ${status.status as unknown as string}`\n          );\n      }\n\n      // Wait before next poll\n      await new Promise(resolve => setTimeout(resolve, currentInterval));\n\n      // Apply exponential backoff if enabled\n      if (opts.useExponentialBackoff) {\n        currentInterval = Math.min(currentInterval * 2, opts.maxIntervalMs);\n      }\n    }\n  }\n\n  /**\n   * Gets the capabilities of a video model\n   */\n  getModelCapabilities(model: string): VideoModelCapabilities {\n    return getVideoModelCapabilities(model);\n  }\n\n\n  /**\n   * Converts a VideoGenerationRequest to the API request format\n   */\n  private convertToApiRequest(request: VideoGenerationRequest): VideoApiRequest {\n    return {\n      prompt: request.prompt,\n      model: request.model ?? VideoModels.DEFAULT,\n      duration: request.duration,\n      size: request.size,\n      fps: request.fps,\n      style: request.style,\n      response_format: request.response_format ?? VideoResponseFormats.URL,\n      user: request.user,\n      seed: request.seed,\n      n: request.n ?? 1,\n    };\n  }\n\n  /**\n   * Converts an AsyncVideoGenerationRequest to the API request format\n   */\n  private convertToAsyncApiRequest(request: AsyncVideoGenerationRequest): AsyncVideoApiRequest {\n    const baseRequest = this.convertToApiRequest(request);\n\n    return {\n      ...baseRequest,\n      webhook_url: request.webhook_url,\n      webhook_metadata: request.webhook_metadata,\n      webhook_headers: request.webhook_headers,\n      timeout_seconds: request.timeout_seconds,\n    };\n  }\n}\n\n/**\n * Helper functions for video generation\n */\nexport const VideoHelpers = {\n  /**\n   * Creates a simple video generation request\n   */\n  createRequest(\n    prompt: string,\n    options?: {\n      model?: string;\n      duration?: number;\n      size?: string;\n      fps?: number;\n      style?: string;\n    }\n  ): VideoGenerationRequest {\n    return {\n      prompt,\n      model: options?.model,\n      duration: options?.duration,\n      size: options?.size,\n      fps: options?.fps,\n      style: options?.style,\n      n: 1,\n    };\n  },\n\n  /**\n   * Creates an async video generation request with webhook\n   */\n  createAsyncRequest(\n    prompt: string,\n    webhookUrl?: string,\n    options?: {\n      model?: string;\n      duration?: number;\n      size?: string;\n      fps?: number;\n      style?: string;\n      timeoutSeconds?: number;\n      webhookMetadata?: VideoWebhookMetadata;\n    }\n  ): AsyncVideoGenerationRequest {\n    return {\n      prompt,\n      model: options?.model,\n      duration: options?.duration,\n      size: options?.size,\n      fps: options?.fps,\n      style: options?.style,\n      webhook_url: webhookUrl,\n      webhook_metadata: options?.webhookMetadata,\n      timeout_seconds: options?.timeoutSeconds,\n      n: 1,\n    };\n  },\n\n  /**\n   * Creates polling options with sensible defaults\n   */\n  createPollingOptions(\n    options?: Partial<VideoTaskPollingOptions>\n  ): VideoTaskPollingOptions {\n    return {\n      intervalMs: options?.intervalMs ?? VideoDefaults.POLLING_INTERVAL_MS,\n      timeoutMs: options?.timeoutMs ?? VideoDefaults.POLLING_TIMEOUT_MS,\n      useExponentialBackoff: options?.useExponentialBackoff ?? true,\n      maxIntervalMs: options?.maxIntervalMs ?? VideoDefaults.MAX_POLLING_INTERVAL_MS,\n    };\n  },\n};","import type { FetchBasedClient } from '../client/FetchBasedClient';\nimport { createClientAdapter, type IFetchBasedClientAdapter } from '../client/ClientAdapter';\nimport type { RequestOptions } from '../client/types';\nimport type { \n  ModelsDiscoveryResponse, \n  ProviderModelsDiscoveryResponse, \n  CapabilityTestResponse,\n  BulkCapabilityTestRequest,\n  BulkCapabilityTestResponse,\n  BulkModelDiscoveryRequest,\n  BulkModelDiscoveryResponse,\n  ModelCapability,\n  CapabilityTest\n} from '../models/discovery';\n\n\n/**\n * Service for discovering model capabilities and provider features.\n */\nexport class DiscoveryService {\n  private readonly baseEndpoint = '/v1/discovery';\n  private readonly clientAdapter: IFetchBasedClientAdapter;\n\n  constructor(client: FetchBasedClient) {\n    this.clientAdapter = createClientAdapter(client);\n  }\n\n  /**\n   * Gets all discovered models and their capabilities.\n   */\n  async getModels(options?: RequestOptions): Promise<ModelsDiscoveryResponse> {\n    const response = await this.clientAdapter.get<ModelsDiscoveryResponse>(\n      `${this.baseEndpoint}/models`,\n      options\n    );\n    return response;\n  }\n\n  /**\n   * Gets models for a specific provider.\n   */\n  async getProviderModels(provider: string, options?: RequestOptions): Promise<ProviderModelsDiscoveryResponse> {\n    if (!provider?.trim()) {\n      throw new Error('Provider name is required');\n    }\n\n    const response = await this.clientAdapter.get<ProviderModelsDiscoveryResponse>(\n      `${this.baseEndpoint}/providers/${encodeURIComponent(provider)}/models`,\n      options\n    );\n    return response;\n  }\n\n  /**\n   * Tests if a model supports a specific capability.\n   */\n  async testModelCapability(\n    model: string, \n    capability: ModelCapability | string,\n    options?: RequestOptions\n  ): Promise<CapabilityTestResponse> {\n    if (!model?.trim()) {\n      throw new Error('Model name is required');\n    }\n\n    const response = await this.clientAdapter.get<CapabilityTestResponse>(\n      `${this.baseEndpoint}/models/${encodeURIComponent(model)}/capabilities/${capability}`,\n      options\n    );\n    return response;\n  }\n\n  /**\n   * Tests multiple model capabilities in a single request.\n   */\n  async testBulkCapabilities(\n    request: BulkCapabilityTestRequest,\n    options?: RequestOptions\n  ): Promise<BulkCapabilityTestResponse> {\n    // Validate request\n    if (!request.tests || request.tests.length === 0) {\n      throw new Error('At least one test is required');\n    }\n    \n    const response = await this.clientAdapter.post<BulkCapabilityTestResponse, BulkCapabilityTestRequest>(\n      `${this.baseEndpoint}/bulk/capabilities`,\n      request,\n      options\n    );\n    return response;\n  }\n\n  /**\n   * Gets discovery information for multiple models in a single request.\n   */\n  async getBulkModels(\n    request: BulkModelDiscoveryRequest,\n    options?: RequestOptions\n  ): Promise<BulkModelDiscoveryResponse> {\n    // Validate request\n    if (!request.models || request.models.length === 0) {\n      throw new Error('At least one model is required');\n    }\n    \n    const response = await this.clientAdapter.post<BulkModelDiscoveryResponse, BulkModelDiscoveryRequest>(\n      `${this.baseEndpoint}/bulk/models`,\n      request,\n      options\n    );\n    return response;\n  }\n\n  /**\n   * Refreshes the capability cache for all providers.\n   * Requires admin/master key access.\n   */\n  async refreshCapabilities(options?: RequestOptions): Promise<void> {\n    await this.clientAdapter.post(\n      `${this.baseEndpoint}/refresh`,\n      undefined,\n      options\n    );\n  }\n\n  /**\n   * Static validation helper to test capabilities without making API calls.\n   */\n  static validateCapabilityTest(test: CapabilityTest): void {\n    if (!test.model?.trim()) {\n      throw new Error('Model name is required');\n    }\n    if (!test.capability?.trim()) {\n      throw new Error('Capability name is required');\n    }\n  }\n\n  /**\n   * Static validation helper for bulk requests.\n   */\n  static validateBulkCapabilityRequest(request: BulkCapabilityTestRequest): void {\n    if (!request.tests || request.tests.length === 0) {\n      throw new Error('At least one test is required');\n    }\n    request.tests.forEach((test, index) => {\n      try {\n        DiscoveryService.validateCapabilityTest(test);\n      } catch (error) {\n        throw new Error(`Invalid test at index ${index}: ${error instanceof Error ? error.message : String(error)}`);\n      }\n    });\n  }\n\n  /**\n   * Static validation helper for bulk model discovery requests.\n   */\n  static validateBulkModelRequest(request: BulkModelDiscoveryRequest): void {\n    if (!request.models || request.models.length === 0) {\n      throw new Error('At least one model is required');\n    }\n    request.models.forEach((model, index) => {\n      if (!model?.trim()) {\n        throw new Error(`Invalid model at index ${index}: Model name is required`);\n      }\n    });\n  }\n}","import { FetchBasedClient } from './client/FetchBasedClient';\nimport { FetchChatService } from './services/FetchChatService';\nimport { AudioService } from './services/AudioService';\nimport { HealthService } from './services/HealthService';\nimport { ImagesService } from './services/ImagesService';\nimport { VideosService } from './services/VideosService';\nimport { DiscoveryService } from './services/DiscoveryService';\nimport type { ClientConfig } from './client/types';\nimport { ConduitError } from './utils/errors';\n\n/**\n * Type-safe Conduit Core Client using native fetch\n * \n * Provides full type safety for all operations with TypeScript generics\n * and OpenAPI-generated types, without the complexity of HTTP.\n * \n * @example\n * ```typescript\n * const client = new FetchConduitCoreClient({\n *   apiKey: 'your-api-key',\n *   baseURL: 'https://api.conduit.ai'\n * });\n * \n * // All operations are fully typed\n * const response = await client.chat.create({\n *   model: 'gpt-4',\n *   messages: [{ role: 'user', content: 'Hello' }]\n * });\n * ```\n */\nexport class FetchConduitCoreClient extends FetchBasedClient {\n  public readonly chat: FetchChatService;\n  public readonly audio: AudioService;\n  public readonly health: HealthService;\n  public readonly images: ImagesService;\n  public readonly videos: VideosService;\n  public readonly discovery: DiscoveryService;\n\n  constructor(config: ClientConfig) {\n    super(config);\n\n    // Initialize services\n    this.chat = new FetchChatService(config);\n    this.audio = new AudioService(this);\n    this.health = new HealthService(this);\n    this.images = new ImagesService(this);\n    this.videos = new VideosService(this);\n    this.discovery = new DiscoveryService(this);\n  }\n\n  /**\n   * Type guard for checking if an error is a ConduitError\n   */\n  isConduitError(error: unknown): error is ConduitError {\n    return error instanceof ConduitError;\n  }\n\n  /**\n   * Type guard for checking if an error is an authentication error\n   */\n  isAuthError(error: unknown): error is ConduitError {\n    return this.isConduitError(error) && error.statusCode === 401;\n  }\n\n  /**\n   * Type guard for checking if an error is a rate limit error\n   */\n  isRateLimitError(error: unknown): error is ConduitError {\n    return this.isConduitError(error) && error.statusCode === 429;\n  }\n\n  /**\n   * Type guard for checking if an error is a validation error\n   */\n  isValidationError(error: unknown): error is ConduitError {\n    return this.isConduitError(error) && error.statusCode === 400;\n  }\n\n  /**\n   * Type guard for checking if an error is a not found error\n   */\n  isNotFoundError(error: unknown): error is ConduitError {\n    return this.isConduitError(error) && error.statusCode === 404;\n  }\n\n  /**\n   * Type guard for checking if an error is a server error\n   */\n  isServerError(error: unknown): error is ConduitError {\n    return this.isConduitError(error) && \n           error.statusCode !== undefined && \n           error.statusCode >= 500;\n  }\n\n  /**\n   * Type guard for checking if an error is a network error\n   */\n  isNetworkError(error: unknown): error is ConduitError {\n    return this.isConduitError(error) && \n           (error.code === 'ECONNABORTED' || error.code === 'network_error');\n  }\n}\n\n// Export the fetch-based client as the default\nexport default FetchConduitCoreClient;\n\n// Re-export types for convenience\nexport type { \n  ClientConfig,\n  RequestOptions,\n  RetryConfig,\n} from './client/types';\n\n// Re-export generated types\nexport type { components, operations, paths } from './generated/core-api';\n\n// Re-export error types\nexport { \n  ConduitError,\n  AuthError,\n  RateLimitError,\n  NetworkError,\n} from './utils/errors';","import type { Usage, ResponseFormat, Tool, ToolCall, FinishReason, PerformanceMetrics } from './common';\nimport type { ToolParameters } from './metadata';\n\n/**\n * Text content part for multi-modal messages\n */\nexport interface TextContent {\n  type: 'text';\n  text: string;\n}\n\n/**\n * Image content part for multi-modal messages\n */\nexport interface ImageContent {\n  type: 'image_url';\n  image_url: {\n    /**\n     * URL of the image or base64 encoded image data\n     * For base64, use format: \"data:image/jpeg;base64,{base64_data}\"\n     */\n    url: string;\n    /**\n     * Level of detail for image processing\n     * - 'low': Faster processing, lower token usage\n     * - 'high': More detailed analysis, higher token usage\n     * - 'auto': Let the model decide (default)\n     */\n    detail?: 'low' | 'high' | 'auto';\n  };\n}\n\n/**\n * Content can be a simple string, null, or an array of content parts for multi-modal messages\n */\nexport type MessageContent = string | null | Array<TextContent | ImageContent>;\n\nexport interface ChatCompletionMessage {\n  role: 'system' | 'user' | 'assistant' | 'tool';\n  content: MessageContent;\n  name?: string;\n  tool_calls?: ToolCall[];\n  tool_call_id?: string;\n}\n\nexport interface ChatCompletionRequest {\n  model: string;\n  messages: ChatCompletionMessage[];\n  frequency_penalty?: number;\n  logit_bias?: Record<string, number>;\n  logprobs?: boolean;\n  top_logprobs?: number;\n  max_tokens?: number;\n  n?: number;\n  presence_penalty?: number;\n  response_format?: ResponseFormat;\n  seed?: number;\n  stop?: string | string[];\n  stream?: boolean;\n  temperature?: number;\n  top_p?: number;\n  /**\n   * Limits the number of tokens to consider for each step of generation.\n   * Only the top K most likely tokens are considered for sampling.\n   * @minimum 1\n   * @maximum 100\n   */\n  top_k?: number;\n  tools?: Tool[];\n  tool_choice?: 'none' | 'auto' | { type: 'function'; function: { name: string } };\n  user?: string;\n  /**\n   * @deprecated Use 'tools' instead. Functions are converted to tools internally.\n   */\n  functions?: Array<{\n    name: string;\n    description?: string;\n    parameters?: ToolParameters;\n  }>;\n  /**\n   * @deprecated Use 'tool_choice' instead.\n   */\n  function_call?: 'none' | 'auto' | { name: string };\n}\n\nexport interface ChatCompletionChoice {\n  index: number;\n  message: ChatCompletionMessage;\n  logprobs?: unknown;\n  finish_reason: FinishReason;\n}\n\nexport interface ChatCompletionResponse {\n  id: string;\n  object: 'chat.completion';\n  created: number;\n  model: string;\n  system_fingerprint?: string;\n  choices: ChatCompletionChoice[];\n  usage: Usage;\n  performance?: PerformanceMetrics;\n}\n\nexport interface ChatCompletionChunkChoice {\n  index: number;\n  delta: Partial<ChatCompletionMessage>;\n  logprobs?: unknown;\n  finish_reason: FinishReason;\n}\n\nexport interface ChatCompletionChunk {\n  id: string;\n  object: 'chat.completion.chunk';\n  created: number;\n  model: string;\n  system_fingerprint?: string;\n  choices: ChatCompletionChunkChoice[];\n  usage?: Usage;\n  performance?: PerformanceMetrics;\n}\n\n/**\n * Helper functions for working with multi-modal content\n */\nexport const ContentHelpers = {\n  /**\n   * Creates a text content part\n   */\n  text(text: string): TextContent {\n    return { type: 'text', text };\n  },\n\n  /**\n   * Creates an image content part from a URL\n   */\n  imageUrl(url: string, detail?: 'low' | 'high' | 'auto'): ImageContent {\n    return {\n      type: 'image_url',\n      image_url: { url, detail }\n    };\n  },\n\n  /**\n   * Creates an image content part from base64 data\n   */\n  imageBase64(base64Data: string, mimeType: string = 'image/jpeg', detail?: 'low' | 'high' | 'auto'): ImageContent {\n    return {\n      type: 'image_url',\n      image_url: {\n        url: `data:${mimeType};base64,${base64Data}`,\n        detail\n      }\n    };\n  },\n\n  /**\n   * Checks if content contains images\n   */\n  hasImages(content: MessageContent): boolean {\n    if (!Array.isArray(content)) return false;\n    return content.some(part => part.type === 'image_url');\n  },\n\n  /**\n   * Extracts text from multi-modal content\n   */\n  extractText(content: MessageContent): string {\n    if (typeof content === 'string') return content;\n    if (!content) return '';\n    if (!Array.isArray(content)) return '';\n    \n    return content\n      .filter((part): part is TextContent => part.type === 'text')\n      .map(part => part.text)\n      .join(' ');\n  },\n\n  /**\n   * Extracts images from multi-modal content\n   */\n  extractImages(content: MessageContent): ImageContent[] {\n    if (!Array.isArray(content)) return [];\n    return content.filter((part): part is ImageContent => part.type === 'image_url');\n  }\n};\n\n/**\n * Alias for ChatCompletionRequest to maintain compatibility with existing imports\n */\nexport type ChatCompletionCreateParams = ChatCompletionRequest;","import type { ChatCompletionChunk } from './chat';\n\n/**\n * Enhanced SSE (Server-Sent Events) event types supported by Conduit.\n * These event types allow for richer streaming responses that include\n * performance metrics and other metadata alongside content.\n * \n * @enum {string}\n * @since 0.3.0\n */\nexport enum EnhancedSSEEventType {\n  /** Regular content event containing chat completion chunks */\n  Content = 'content',\n  /** Live performance metrics during streaming */\n  Metrics = 'metrics', \n  /** Final performance metrics at stream completion */\n  MetricsFinal = 'metrics-final',\n  /** Error events during streaming */\n  Error = 'error',\n  /** Stream completion marker */\n  Done = 'done',\n}\n\n/**\n * Performance metrics sent during streaming (matches Core API format).\n * These metrics provide real-time insights into the streaming performance.\n * \n * @interface StreamingMetrics\n * @since 0.3.0\n * \n * @example\n * ```typescript\n * {\n *   request_id: 'req-123',\n *   elapsed_ms: 1500,\n *   tokens_generated: 25,\n *   current_tokens_per_second: 16.67,\n *   time_to_first_token_ms: 120,\n *   avg_inter_token_latency_ms: 60\n * }\n * ```\n */\nexport interface StreamingMetrics {\n  /** Unique identifier for the streaming request */\n  request_id?: string;\n  /** Total elapsed time in milliseconds since stream start */\n  elapsed_ms?: number;\n  /** Number of tokens generated so far */\n  tokens_generated?: number;\n  /** Current token generation rate (tokens per second) */\n  current_tokens_per_second?: number;\n  /** Time to first token in milliseconds */\n  time_to_first_token_ms?: number;\n  /** Average latency between tokens in milliseconds */\n  avg_inter_token_latency_ms?: number;\n}\n\n/**\n * Final performance metrics sent at the end of a streaming response.\n * Provides comprehensive performance statistics for the entire request.\n * \n * @interface FinalMetrics\n * @since 0.3.0\n * \n * @example\n * ```typescript\n * {\n *   total_latency_ms: 2500,\n *   time_to_first_token_ms: 150,\n *   tokens_per_second: 42.0,\n *   prompt_tokens_per_second: 200,\n *   completion_tokens_per_second: 42.0,\n *   provider: 'openai',\n *   model: 'gpt-4',\n *   streaming: true,\n *   avg_inter_token_latency_ms: 59.5,\n *   prompt_tokens: 50,\n *   completion_tokens: 105,\n *   total_tokens: 155\n * }\n * ```\n */\nexport interface FinalMetrics {\n  /** Total end-to-end latency in milliseconds */\n  total_latency_ms?: number;\n  /** Time to first token in milliseconds */\n  time_to_first_token_ms?: number;\n  /** Overall tokens per second for the completion */\n  tokens_per_second?: number;\n  /** Processing speed for prompt tokens (tokens/second) */\n  prompt_tokens_per_second?: number;\n  /** Generation speed for completion tokens (tokens/second) */\n  completion_tokens_per_second?: number;\n  /** LLM provider name (e.g., 'openai', 'anthropic') */\n  provider?: string;\n  /** Model identifier (e.g., 'gpt-4', 'claude-3') */\n  model?: string;\n  /** Whether streaming was used for this request */\n  streaming?: boolean;\n  /** Average latency between consecutive tokens in milliseconds */\n  avg_inter_token_latency_ms?: number;\n  // Usage data\n  /** Number of tokens in the prompt */\n  prompt_tokens?: number;\n  /** Number of tokens in the completion */\n  completion_tokens?: number;\n  /** Total token count (prompt + completion) */\n  total_tokens?: number;\n}\n\n/**\n * Enhanced streaming event that preserves SSE event types.\n * Wraps different types of data (content, metrics, errors) with their event type.\n * Does not extend BaseStreamChunk as it represents wrapped events.\n * \n * @interface EnhancedStreamEvent\n * @since 0.3.0\n * \n * @example\n * ```typescript\n * // Content event\n * {\n *   type: 'content',\n *   data: { id: 'chatcmpl-123', object: 'chat.completion.chunk', ... }\n * }\n * \n * // Metrics event\n * {\n *   type: 'metrics',\n *   data: { current_tokens_per_second: 42.5, tokens_generated: 30 }\n * }\n * ```\n */\nexport interface EnhancedStreamEvent {\n  /** The type of SSE event */\n  type: EnhancedSSEEventType;\n  /** The event data, type depends on the event type */\n  data: ChatCompletionChunk | StreamingMetrics | FinalMetrics | string;\n}\n\n/**\n * Type guard to check if data is a ChatCompletionChunk.\n * \n * @param {unknown} data - The data to check\n * @returns {boolean} True if data is a ChatCompletionChunk\n * @since 0.3.0\n * \n * @example\n * ```typescript\n * if (isChatCompletionChunk(event.data)) {\n *   // TypeScript now knows event.data is ChatCompletionChunk\n *   console.log(event.data.choices[0].delta.content);\n * }\n * ```\n */\nexport function isChatCompletionChunk(data: unknown): data is ChatCompletionChunk {\n  return (\n    typeof data === 'object' &&\n    data !== null &&\n    'object' in data &&\n    (data as Record<string, unknown>).object === 'chat.completion.chunk'\n  );\n}\n\n/**\n * Type guard to check if data is StreamingMetrics.\n * \n * @param {unknown} data - The data to check\n * @returns {boolean} True if data is StreamingMetrics\n * @since 0.3.0\n * \n * @example\n * ```typescript\n * if (isStreamingMetrics(event.data)) {\n *   // TypeScript now knows event.data is StreamingMetrics\n *   console.log(`Speed: ${event.data.current_tokens_per_second} tokens/sec`);\n * }\n * ```\n */\nexport function isStreamingMetrics(data: unknown): data is StreamingMetrics {\n  return (\n    typeof data === 'object' &&\n    data !== null &&\n    ('current_tokens_per_second' in data || 'tokens_generated' in data || 'elapsed_ms' in data)\n  );\n}\n\n/**\n * Type guard to check if data is FinalMetrics.\n * \n * @param {unknown} data - The data to check\n * @returns {boolean} True if data is FinalMetrics\n * @since 0.3.0\n * \n * @example\n * ```typescript\n * if (isFinalMetrics(event.data)) {\n *   // TypeScript now knows event.data is FinalMetrics\n *   console.log(`Total tokens: ${event.data.total_tokens}`);\n *   console.log(`Average speed: ${event.data.tokens_per_second} tokens/sec`);\n * }\n * ```\n */\nexport function isFinalMetrics(data: unknown): data is FinalMetrics {\n  return (\n    typeof data === 'object' &&\n    data !== null &&\n    ('tokens_per_second' in data || 'total_latency_ms' in data || 'completion_tokens' in data)\n  );\n}","import type { FetchBasedClient } from '../client/FetchBasedClient';\nimport { createClientAdapter, type IFetchBasedClientAdapter } from '../client/ClientAdapter';\nimport type { RequestOptions } from '../client/types';\nimport type { TaskResult } from '../models/common-types';\nimport { ConduitError } from '../utils/errors';\nimport { API_ENDPOINTS, TASK_STATUS } from '../constants';\n\n/**\n * Service for general task management operations using the Conduit Core API\n */\nexport class TasksService {\n  private readonly clientAdapter: IFetchBasedClientAdapter;\n\n  constructor(client: FetchBasedClient) {\n    this.clientAdapter = createClientAdapter(client);\n  }\n\n  /**\n   * Gets the status of any task by its ID\n   */\n  async getTaskStatus(\n    taskId: string,\n    options?: RequestOptions\n  ): Promise<TaskStatusResponse> {\n    try {\n      if (!taskId || taskId.trim().length === 0) {\n        throw new Error('Task ID is required');\n      }\n\n      const response = await this.clientAdapter.get<TaskStatusResponse>(\n        API_ENDPOINTS.V1.TASKS.BY_ID(taskId),\n        options\n      );\n\n      return response;\n    } catch (error) {\n      if (error instanceof ConduitError) {\n        throw error;\n      }\n      throw new ConduitError(\n        `Failed to get task status: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  /**\n   * Cancels a pending or running task\n   */\n  async cancelTask(\n    taskId: string,\n    options?: RequestOptions\n  ): Promise<void> {\n    try {\n      if (!taskId || taskId.trim().length === 0) {\n        throw new Error('Task ID is required');\n      }\n\n      await this.clientAdapter.post<void>(\n        API_ENDPOINTS.V1.TASKS.CANCEL(taskId),\n        {},\n        options\n      );\n    } catch (error) {\n      if (error instanceof ConduitError) {\n        throw error;\n      }\n      throw new ConduitError(\n        `Failed to cancel task: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  /**\n   * Polls a task until completion or timeout\n   */\n  async pollTaskUntilCompletion<T = unknown>(\n    taskId: string,\n    pollingOptions?: TaskPollingOptions,\n    options?: RequestOptions\n  ): Promise<T> {\n    const opts: Required<TaskPollingOptions> = {\n      intervalMs: pollingOptions?.intervalMs ?? TaskDefaults.POLLING_INTERVAL_MS,\n      timeoutMs: pollingOptions?.timeoutMs ?? TaskDefaults.POLLING_TIMEOUT_MS,\n      useExponentialBackoff: pollingOptions?.useExponentialBackoff ?? true,\n      maxIntervalMs: pollingOptions?.maxIntervalMs ?? TaskDefaults.MAX_POLLING_INTERVAL_MS,\n    };\n\n    if (!taskId || taskId.trim().length === 0) {\n      throw new Error('Task ID is required');\n    }\n\n    const startTime = Date.now();\n    let currentInterval = opts.intervalMs;\n\n    // Poll until task completes or fails\n    for (;;) {\n      // Check timeout\n      if (Date.now() - startTime > opts.timeoutMs) {\n        throw new ConduitError(\n          `Task polling timed out after ${opts.timeoutMs}ms`\n        );\n      }\n\n      const status = await this.getTaskStatus(taskId, options);\n\n      switch (status.status?.toLowerCase()) {\n        case TASK_STATUS.COMPLETED:\n          if (!status.result) {\n            throw new ConduitError(\n              'Task completed but no result was provided'\n            );\n          }\n          return status.result as T;\n\n        case TASK_STATUS.FAILED:\n          throw new ConduitError(\n            `Task failed: ${status.error ?? 'Unknown error'}`\n          );\n\n        case TASK_STATUS.CANCELLED:\n          throw new ConduitError('Task was cancelled');\n\n        case TASK_STATUS.TIMEDOUT:\n          throw new ConduitError('Task timed out');\n\n        case TASK_STATUS.PENDING:\n        case TASK_STATUS.RUNNING:\n          // Continue polling\n          break;\n\n        default:\n          throw new ConduitError(\n            `Unknown task status: ${status.status}`\n          );\n      }\n\n      // Wait before next poll\n      await this.sleep(currentInterval);\n\n      // Apply exponential backoff if enabled\n      if (opts.useExponentialBackoff) {\n        currentInterval = Math.min(currentInterval * 2, opts.maxIntervalMs);\n      }\n    }\n  }\n\n  /**\n   * Requests cleanup of old completed tasks (admin operation)\n   */\n  async cleanupOldTasks(\n    olderThanHours: number = 24,\n    options?: RequestOptions\n  ): Promise<number> {\n    try {\n      const request = { older_than_hours: olderThanHours };\n\n      const response = await this.clientAdapter.post<CleanupTasksResponse>(\n        API_ENDPOINTS.V1.TASKS.CLEANUP,\n        request,\n        options\n      );\n\n      return response.tasks_removed;\n    } catch (error) {\n      if (error instanceof ConduitError) {\n        throw error;\n      }\n      throw new ConduitError(\n        `Failed to cleanup old tasks: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  /**\n   * Helper method to sleep for a specified duration\n   */\n  private sleep(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n}\n\n/**\n * Response from a general task status request\n */\nexport interface TaskStatusResponse {\n  /** The unique task identifier */\n  task_id: string;\n\n  /** The current status of the task */\n  status?: string;\n\n  /** The task type */\n  task_type?: string;\n\n  /** The progress percentage (0-100) */\n  progress: number;\n\n  /** An optional progress message */\n  message?: string;\n\n  /** When the task was created */\n  created_at: string;\n\n  /** When the task was last updated */\n  updated_at: string;\n\n  /** The task result, available when status is completed */\n  result?: TaskResult;\n\n  /** Error information if the task failed */\n  error?: string;\n}\n\n/**\n * Options for polling task status\n */\nexport interface TaskPollingOptions {\n  /** The polling interval in milliseconds */\n  intervalMs?: number;\n\n  /** The maximum polling timeout in milliseconds */\n  timeoutMs?: number;\n\n  /** Whether to use exponential backoff for polling intervals */\n  useExponentialBackoff?: boolean;\n\n  /** The maximum interval between polls in milliseconds when using exponential backoff */\n  maxIntervalMs?: number;\n}\n\n/**\n * Response from a cleanup tasks request\n */\nexport interface CleanupTasksResponse {\n  /** The number of tasks that were removed */\n  tasks_removed: number;\n}\n\n/**\n * Default values for task operations\n */\nexport const TaskDefaults = {\n  /** Default polling interval in milliseconds */\n  POLLING_INTERVAL_MS: 2000,\n\n  /** Default polling timeout in milliseconds */\n  POLLING_TIMEOUT_MS: 600000, // 10 minutes\n\n  /** Default maximum polling interval in milliseconds */\n  MAX_POLLING_INTERVAL_MS: 30000, // 30 seconds\n} as const;\n\n/**\n * Helper functions for task management\n */\nexport const TaskHelpers = {\n  /**\n   * Creates polling options with sensible defaults\n   */\n  createPollingOptions(\n    options?: Partial<TaskPollingOptions>\n  ): TaskPollingOptions {\n    return {\n      intervalMs: options?.intervalMs ?? TaskDefaults.POLLING_INTERVAL_MS,\n      timeoutMs: options?.timeoutMs ?? TaskDefaults.POLLING_TIMEOUT_MS,\n      useExponentialBackoff: options?.useExponentialBackoff ?? true,\n      maxIntervalMs: options?.maxIntervalMs ?? TaskDefaults.MAX_POLLING_INTERVAL_MS,\n    };\n  },\n};","import type { FetchBasedClient } from '../client/FetchBasedClient';\nimport { createClientAdapter, type IFetchBasedClientAdapter } from '../client/ClientAdapter';\nimport {\n  type BatchSpendUpdateRequest,\n  type BatchVirtualKeyUpdateRequest,\n  type BatchWebhookSendRequest,\n  type BatchOperationStartResponse,\n  type BatchOperationStatusResponse,\n  type SpendUpdateDto,\n  type VirtualKeyUpdateDto,\n  type WebhookSendDto,\n  type BatchOperationPollOptions,\n  type BatchValidationOptions,\n  type BatchValidationResult,\n  BatchOperationStatusEnum\n} from '../models/batchOperations';\n\n/**\n * Service for performing batch operations on the Conduit Core API\n */\nexport class BatchOperationsService {\n  private readonly clientAdapter: IFetchBasedClientAdapter;\n\n  constructor(client: FetchBasedClient) {\n    this.clientAdapter = createClientAdapter(client);\n  }\n\n  /**\n   * Performs a batch spend update operation\n   * \n   * @param request - The batch spend update request containing up to 10,000 spend updates\n   * @returns Promise<BatchOperationStartResponse> The batch operation start response\n   * @throws {ConduitCoreError} When the API request fails or request validation fails\n   * \n   * @example\n   * ```typescript\n   * const spendUpdates = [\n   *   { virtualKeyId: 1, amount: 10.50, model: 'gpt-4', provider: 'openai' },\n   *   { virtualKeyId: 2, amount: 5.25, model: 'claude-3', provider: 'anthropic' }\n   * ];\n   * \n   * const startResponse = await coreClient.batchOperations.batchSpendUpdate({\n   *   spendUpdates\n   * });\n   * \n   * console.log(`Started batch operation: ${startResponse.operationId}`);\n   * console.log(`Track progress with task ID: ${startResponse.taskId}`);\n   * ```\n   */\n  async batchSpendUpdate(request: BatchSpendUpdateRequest): Promise<BatchOperationStartResponse> {\n    // Validate request\n    if (request.spendUpdates.length > 10000) {\n      throw new Error('Batch spend updates cannot exceed 10,000 items');\n    }\n\n    if (request.spendUpdates.length === 0) {\n      throw new Error('Cannot create empty batch spend update request');\n    }\n\n    return this.clientAdapter.post<BatchOperationStartResponse>(\n      '/v1/batch/spend-updates',\n      request\n    );\n  }\n\n  /**\n   * Performs a batch virtual key update operation (requires admin permissions)\n   * \n   * @param request - The batch virtual key update request containing up to 1,000 virtual key updates\n   * @returns Promise<BatchOperationStartResponse> The batch operation start response\n   * @throws {ConduitCoreError} When the API request fails or request validation fails\n   * \n   * @example\n   * ```typescript\n   * const virtualKeyUpdates = [\n   *   { virtualKeyId: 1, maxBudget: 1000, isEnabled: true },\n   *   { virtualKeyId: 2, allowedModels: ['gpt-4', 'gpt-3.5-turbo'] }\n   * ];\n   * \n   * const startResponse = await coreClient.batchOperations.batchVirtualKeyUpdate({\n   *   virtualKeyUpdates\n   * });\n   * \n   * console.log(`Started virtual key batch operation: ${startResponse.operationId}`);\n   * ```\n   */\n  async batchVirtualKeyUpdate(request: BatchVirtualKeyUpdateRequest): Promise<BatchOperationStartResponse> {\n    // Validate request\n    if (request.virtualKeyUpdates.length > 1000) {\n      throw new Error('Batch virtual key updates cannot exceed 1,000 items');\n    }\n\n    if (request.virtualKeyUpdates.length === 0) {\n      throw new Error('Cannot create empty batch virtual key update request');\n    }\n\n    return this.clientAdapter.post<BatchOperationStartResponse>(\n      '/v1/batch/virtual-key-updates',\n      request\n    );\n  }\n\n  /**\n   * Performs a batch webhook send operation\n   * \n   * @param request - The batch webhook send request containing up to 5,000 webhook sends\n   * @returns Promise<BatchOperationStartResponse> The batch operation start response\n   * @throws {ConduitCoreError} When the API request fails or request validation fails\n   * \n   * @example\n   * ```typescript\n   * const webhookSends = [\n   *   {\n   *     url: 'https://example.com/webhook',\n   *     eventType: 'spend_update',\n   *     payload: { userId: 123, amount: 10.50 },\n   *     headers: { 'X-Custom-Header': 'value' }\n   *   }\n   * ];\n   * \n   * const startResponse = await coreClient.batchOperations.batchWebhookSend({\n   *   webhookSends\n   * });\n   * \n   * console.log(`Started webhook batch operation: ${startResponse.operationId}`);\n   * ```\n   */\n  async batchWebhookSend(request: BatchWebhookSendRequest): Promise<BatchOperationStartResponse> {\n    // Validate request\n    if (request.webhookSends.length > 5000) {\n      throw new Error('Batch webhook sends cannot exceed 5,000 items');\n    }\n\n    if (request.webhookSends.length === 0) {\n      throw new Error('Cannot create empty batch webhook send request');\n    }\n\n    return this.clientAdapter.post<BatchOperationStartResponse>(\n      '/v1/batch/webhook-sends',\n      request\n    );\n  }\n\n  /**\n   * Gets the status of a batch operation\n   * \n   * @param operationId - The unique identifier of the batch operation\n   * @returns Promise<BatchOperationStatusResponse> The batch operation status response\n   * @throws {ConduitCoreError} When the API request fails\n   * \n   * @example\n   * ```typescript\n   * const status = await coreClient.batchOperations.getOperationStatus('batch-123');\n   * \n   * console.log(`Operation status: ${status.status}`);\n   * console.log(`Progress: ${status.metadata.processedItems}/${status.metadata.totalItems}`);\n   * console.log(`Success rate: ${((status.metadata.processedItems - status.metadata.failedItems) / status.metadata.processedItems * 100).toFixed(2)}%`);\n   * \n   * if (status.status === BatchOperationStatusEnum.Completed) {\n   *   console.log('Batch operation completed!');\n   * } else if (status.status === BatchOperationStatusEnum.Failed) {\n   *   console.log('Batch operation failed:', status.errors);\n   * }\n   * ```\n   */\n  async getOperationStatus(operationId: string): Promise<BatchOperationStatusResponse> {\n    return this.clientAdapter.get<BatchOperationStatusResponse>(\n      `/v1/batch/operations/${operationId}`\n    );\n  }\n\n  /**\n   * Cancels a running batch operation\n   * \n   * @param operationId - The unique identifier of the batch operation to cancel\n   * @returns Promise<BatchOperationStatusResponse> The updated batch operation status response\n   * @throws {ConduitCoreError} When the API request fails\n   * \n   * @example\n   * ```typescript\n   * const canceledStatus = await coreClient.batchOperations.cancelOperation('batch-123');\n   * console.log(`Operation canceled. Final status: ${canceledStatus.status}`);\n   * ```\n   */\n  async cancelOperation(operationId: string): Promise<BatchOperationStatusResponse> {\n    return this.clientAdapter.post<BatchOperationStatusResponse>(\n      `/v1/batch/operations/${operationId}/cancel`,\n      {}\n    );\n  }\n\n  /**\n   * Polls a batch operation until completion or timeout\n   * \n   * @param operationId - The unique identifier of the batch operation\n   * @param options - Polling options (interval and timeout)\n   * @returns Promise<BatchOperationStatusResponse> The final batch operation status response\n   * @throws {Error} When the operation doesn't complete within the timeout\n   * \n   * @example\n   * ```typescript\n   * // Poll every 3 seconds for up to 5 minutes\n   * const finalStatus = await coreClient.batchOperations.pollOperation('batch-123', {\n   *   pollingInterval: 3000,\n   *   timeout: 300000\n   * });\n   * \n   * if (finalStatus.status === BatchOperationStatusEnum.Completed) {\n   *   console.log('Operation completed successfully!');\n   *   console.log(`Processed ${finalStatus.metadata.processedItems} items`);\n   * }\n   * ```\n   */\n  async pollOperation(\n    operationId: string,\n    options: BatchOperationPollOptions = {}\n  ): Promise<BatchOperationStatusResponse> {\n    const pollingInterval = options.pollingInterval ?? 5000;\n    const timeout = options.timeout ?? 600000; // 10 minutes default\n\n    const startTime = Date.now();\n    let lastStatus: BatchOperationStatusResponse | undefined;\n\n    while (Date.now() - startTime < timeout) {\n      lastStatus = await this.getOperationStatus(operationId);\n\n      if (lastStatus.status === BatchOperationStatusEnum.Completed ||\n          lastStatus.status === BatchOperationStatusEnum.Failed ||\n          lastStatus.status === BatchOperationStatusEnum.Cancelled ||\n          lastStatus.status === BatchOperationStatusEnum.PartiallyCompleted) {\n        return lastStatus;\n      }\n\n      await new Promise(resolve => setTimeout(resolve, pollingInterval));\n    }\n\n    throw new Error(\n      `Batch operation ${operationId} did not complete within ${timeout}ms. ` +\n      `Last status: ${lastStatus?.status ?? 'unknown'}`\n    );\n  }\n\n  /**\n   * Validates a batch spend update request\n   * \n   * @param spendUpdates - Array of spend updates to validate\n   * @param options - Validation options\n   * @returns BatchValidationResult Validation result with errors and warnings\n   * \n   * @example\n   * ```typescript\n   * const spendUpdates = [\n   *   { virtualKeyId: 1, amount: 10.50, model: 'gpt-4', provider: 'openai' },\n   *   { virtualKeyId: 0, amount: -5, model: '', provider: 'invalid' } // Invalid\n   * ];\n   * \n   * const validation = BatchOperationsService.validateSpendUpdateRequest(spendUpdates);\n   * if (!validation.isValid) {\n   *   console.log('Validation errors:', validation.errors);\n   * }\n   * ```\n   */\n  static validateSpendUpdateRequest(\n    spendUpdates: SpendUpdateDto[], \n    options: BatchValidationOptions = {}\n  ): BatchValidationResult {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n    const validateItems = options.validateItems !== false;\n\n    if (spendUpdates.length > 10000) {\n      errors.push('Cannot process more than 10,000 spend updates in a single batch');\n    }\n\n    if (spendUpdates.length === 0) {\n      errors.push('Cannot create empty batch spend update request');\n    }\n\n    if (validateItems) {\n      spendUpdates.forEach((update, index) => {\n        if (!update.virtualKeyId || update.virtualKeyId <= 0) {\n          errors.push(`Invalid virtualKeyId at index ${index}: ${update.virtualKeyId}`);\n        }\n\n        if (!update.amount || update.amount <= 0 || update.amount > 1000000) {\n          errors.push(`Invalid amount at index ${index}: ${update.amount}. Must be between 0.0001 and 1,000,000`);\n        }\n\n        if (!update.model || update.model.trim() === '') {\n          errors.push(`Model cannot be empty at index ${index}`);\n        }\n\n        if (!update.provider || update.provider.trim() === '') {\n          errors.push(`Provider cannot be empty at index ${index}`);\n        }\n\n        if (update.amount && update.amount < 0.01) {\n          warnings.push(`Small amount at index ${index}: ${update.amount}. Consider using larger amounts for better efficiency`);\n        }\n      });\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      itemCount: spendUpdates.length,\n      warnings: warnings.length > 0 ? warnings : undefined\n    };\n  }\n\n  /**\n   * Validates a batch virtual key update request\n   * \n   * @param virtualKeyUpdates - Array of virtual key updates to validate\n   * @param options - Validation options\n   * @returns BatchValidationResult Validation result with errors and warnings\n   */\n  static validateVirtualKeyUpdateRequest(\n    virtualKeyUpdates: VirtualKeyUpdateDto[], \n    options: BatchValidationOptions = {}\n  ): BatchValidationResult {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n    const validateItems = options.validateItems !== false;\n    const validateDates = options.validateDates !== false;\n\n    if (virtualKeyUpdates.length > 1000) {\n      errors.push('Cannot process more than 1,000 virtual key updates in a single batch');\n    }\n\n    if (virtualKeyUpdates.length === 0) {\n      errors.push('Cannot create empty batch virtual key update request');\n    }\n\n    if (validateItems) {\n      virtualKeyUpdates.forEach((update, index) => {\n        if (!update.virtualKeyId || update.virtualKeyId <= 0) {\n          errors.push(`Invalid virtualKeyId at index ${index}: ${update.virtualKeyId}`);\n        }\n\n        if (update.maxBudget !== undefined && update.maxBudget < 0) {\n          errors.push(`Invalid maxBudget at index ${index}: ${update.maxBudget}. Cannot be negative`);\n        }\n\n        if (validateDates && update.expiresAt) {\n          const expiryDate = new Date(update.expiresAt);\n          if (isNaN(expiryDate.getTime())) {\n            errors.push(`Invalid expiresAt date format at index ${index}: ${update.expiresAt}`);\n          } else if (expiryDate < new Date()) {\n            errors.push(`Invalid expiresAt at index ${index}: ${update.expiresAt}. Cannot be in the past`);\n          }\n        }\n\n        if (update.allowedModels && update.allowedModels.length === 0) {\n          warnings.push(`Empty allowedModels array at index ${index}. This will remove all model restrictions`);\n        }\n      });\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      itemCount: virtualKeyUpdates.length,\n      warnings: warnings.length > 0 ? warnings : undefined\n    };\n  }\n\n  /**\n   * Validates a batch webhook send request\n   * \n   * @param webhookSends - Array of webhook sends to validate\n   * @param options - Validation options\n   * @returns BatchValidationResult Validation result with errors and warnings\n   */\n  static validateWebhookSendRequest(\n    webhookSends: WebhookSendDto[], \n    options: BatchValidationOptions = {}\n  ): BatchValidationResult {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n    const validateItems = options.validateItems !== false;\n    const validateUrls = options.validateUrls !== false;\n\n    if (webhookSends.length > 5000) {\n      errors.push('Cannot process more than 5,000 webhook sends in a single batch');\n    }\n\n    if (webhookSends.length === 0) {\n      errors.push('Cannot create empty batch webhook send request');\n    }\n\n    if (validateItems) {\n      webhookSends.forEach((webhook, index) => {\n        if (!webhook.url || webhook.url.trim() === '') {\n          errors.push(`URL cannot be empty at index ${index}`);\n        } else if (validateUrls) {\n          try {\n            const url = new URL(webhook.url);\n            if (url.protocol !== 'http:' && url.protocol !== 'https:') {\n              errors.push(`Invalid URL protocol at index ${index}: ${webhook.url}. Must be http or https`);\n            }\n          } catch {\n            errors.push(`Invalid URL format at index ${index}: ${webhook.url}`);\n          }\n        }\n\n        if (!webhook.eventType || webhook.eventType.trim() === '') {\n          errors.push(`EventType cannot be empty at index ${index}`);\n        }\n\n        if (!webhook.payload || Object.keys(webhook.payload).length === 0) {\n          errors.push(`Payload cannot be empty at index ${index}`);\n        }\n\n        if (webhook.headers && Object.keys(webhook.headers).length > 50) {\n          warnings.push(`Large number of headers at index ${index}. Consider reducing for better performance`);\n        }\n      });\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      itemCount: webhookSends.length,\n      warnings: warnings.length > 0 ? warnings : undefined\n    };\n  }\n\n  /**\n   * Creates a validated batch spend update request\n   * \n   * @param spendUpdates - Array of spend updates\n   * @returns BatchSpendUpdateRequest Validated request object\n   * @throws {Error} When validation fails\n   */\n  static createSpendUpdateRequest(spendUpdates: SpendUpdateDto[]): BatchSpendUpdateRequest {\n    const validation = this.validateSpendUpdateRequest(spendUpdates);\n    if (!validation.isValid) {\n      throw new Error(`Batch spend update validation failed: ${validation.errors.join(', ')}`);\n    }\n    return { spendUpdates };\n  }\n\n  /**\n   * Creates a validated batch virtual key update request\n   * \n   * @param virtualKeyUpdates - Array of virtual key updates\n   * @returns BatchVirtualKeyUpdateRequest Validated request object\n   * @throws {Error} When validation fails\n   */\n  static createVirtualKeyUpdateRequest(virtualKeyUpdates: VirtualKeyUpdateDto[]): BatchVirtualKeyUpdateRequest {\n    const validation = this.validateVirtualKeyUpdateRequest(virtualKeyUpdates);\n    if (!validation.isValid) {\n      throw new Error(`Batch virtual key update validation failed: ${validation.errors.join(', ')}`);\n    }\n    return { virtualKeyUpdates };\n  }\n\n  /**\n   * Creates a validated batch webhook send request\n   * \n   * @param webhookSends - Array of webhook sends\n   * @returns BatchWebhookSendRequest Validated request object\n   * @throws {Error} When validation fails\n   */\n  static createWebhookSendRequest(webhookSends: WebhookSendDto[]): BatchWebhookSendRequest {\n    const validation = this.validateWebhookSendRequest(webhookSends);\n    if (!validation.isValid) {\n      throw new Error(`Batch webhook send validation failed: ${validation.errors.join(', ')}`);\n    }\n    return { webhookSends };\n  }\n}","import type { FetchBasedClient } from '../client/FetchBasedClient';\nimport { createClientAdapter, type IFetchBasedClientAdapter } from '../client/ClientAdapter';\nimport type {\n  MetricsSnapshot,\n  DatabaseMetrics,\n  HttpMetrics,\n  BusinessMetrics,\n  SystemMetrics,\n  InfrastructureMetrics,\n  ProviderHealthStatus,\n  HistoricalMetricsRequest,\n  HistoricalMetricsResponse,\n  ModelUsageStats,\n  VirtualKeyStats,\n  KPISummary\n} from '../models/metrics';\n\n/**\n * Service for accessing system metrics and performance data from the Conduit Core API\n */\nexport class MetricsService {\n  private readonly clientAdapter: IFetchBasedClientAdapter;\n\n  constructor(client: FetchBasedClient) {\n    this.clientAdapter = createClientAdapter(client);\n  }\n\n  /**\n   * Gets the current comprehensive metrics snapshot\n   * \n   * @returns Promise<MetricsSnapshot> A complete snapshot of current system metrics\n   */\n  async getCurrentMetrics(): Promise<MetricsSnapshot> {\n    const response = await this.clientAdapter.get<MetricsSnapshot>(\n      '/metrics'\n    );\n    return response;\n  }\n\n  /**\n   * Gets current database connection pool metrics\n   * \n   * @returns Promise<DatabaseMetrics> Database connection pool metrics\n   */\n  async getDatabasePoolMetrics(): Promise<DatabaseMetrics> {\n    const response = await this.clientAdapter.get<DatabaseMetrics>(\n      '/metrics/database/pool'\n    );\n    return response;\n  }\n\n  /**\n   * Gets the raw Prometheus metrics format\n   * \n   * @returns Promise<string> Prometheus-formatted metrics as a string\n   */\n  async getPrometheusMetrics(): Promise<string> {\n    const response = await this.clientAdapter.get<string>(\n      '/metrics',\n      {\n        headers: {\n          'Accept': 'text/plain'\n        }\n      }\n    );\n    return response;\n  }\n\n  /**\n   * Gets historical metrics data for a specified time range\n   * \n   * @param request - The historical metrics request parameters\n   * @returns Promise<HistoricalMetricsResponse> Historical metrics data\n   */\n  async getHistoricalMetrics(request: HistoricalMetricsRequest): Promise<HistoricalMetricsResponse> {\n    const response = await this.clientAdapter.post<HistoricalMetricsResponse, HistoricalMetricsRequest>(\n      '/metrics/historical',\n      request\n    );\n    return response;\n  }\n\n  /**\n   * Gets historical metrics for a specific time range with simplified parameters\n   * \n   * @param startTime - Start time for the metrics query\n   * @param endTime - End time for the metrics query\n   * @param metricNames - Optional list of specific metrics to retrieve\n   * @param interval - Optional interval for data aggregation (default: \"5m\")\n   * @returns Promise<HistoricalMetricsResponse> Historical metrics data\n   */\n  async getHistoricalMetricsSimple(\n    startTime: Date,\n    endTime: Date,\n    metricNames: string[] = [],\n    interval: string = '5m'\n  ): Promise<HistoricalMetricsResponse> {\n    const request: HistoricalMetricsRequest = {\n      startTime,\n      endTime,\n      metricNames,\n      interval\n    };\n\n    return this.getHistoricalMetrics(request);\n  }\n\n  /**\n   * Gets current HTTP performance metrics\n   * \n   * @returns Promise<HttpMetrics> HTTP performance metrics\n   */\n  async getHttpMetrics(): Promise<HttpMetrics> {\n    const snapshot = await this.getCurrentMetrics();\n    return snapshot.http;\n  }\n\n  /**\n   * Gets current business metrics\n   * \n   * @returns Promise<BusinessMetrics> Business metrics including costs and usage\n   */\n  async getBusinessMetrics(): Promise<BusinessMetrics> {\n    const snapshot = await this.getCurrentMetrics();\n    return snapshot.business;\n  }\n\n  /**\n   * Gets current system resource metrics\n   * \n   * @returns Promise<SystemMetrics> System resource metrics\n   */\n  async getSystemMetrics(): Promise<SystemMetrics> {\n    const snapshot = await this.getCurrentMetrics();\n    return snapshot.system;\n  }\n\n  /**\n   * Gets current infrastructure component metrics\n   * \n   * @returns Promise<InfrastructureMetrics> Infrastructure metrics including database, Redis, and messaging\n   */\n  async getInfrastructureMetrics(): Promise<InfrastructureMetrics> {\n    const snapshot = await this.getCurrentMetrics();\n    return snapshot.infrastructure;\n  }\n\n  /**\n   * Gets current provider health status for all providers\n   * \n   * @returns Promise<ProviderHealthStatus[]> List of provider health statuses\n   */\n  async getProviderHealth(): Promise<ProviderHealthStatus[]> {\n    const snapshot = await this.getCurrentMetrics();\n    return snapshot.providerHealth;\n  }\n\n  /**\n   * Gets health status for a specific provider\n   * \n   * @param providerName - The name of the provider\n   * @returns Promise<ProviderHealthStatus | null> Provider health status, or null if not found\n   */\n  async getProviderHealthByName(providerName: string): Promise<ProviderHealthStatus | null> {\n    if (!providerName?.trim()) {\n      throw new Error('Provider name cannot be null or empty');\n    }\n\n    const allProviders = await this.getProviderHealth();\n    return allProviders.find(p => p.providerName.toLowerCase() === providerName.toLowerCase()) ?? null;\n  }\n\n  /**\n   * Gets the top performing models by request volume\n   * \n   * @param count - Number of top models to return (default: 10)\n   * @returns Promise<ModelUsageStats[]> List of top performing models ordered by request volume\n   */\n  async getTopModelsByRequestVolume(count: number = 10): Promise<ModelUsageStats[]> {\n    if (count <= 0) {\n      throw new Error('Count must be greater than 0');\n    }\n\n    const metrics = await this.getBusinessMetrics();\n    return metrics.modelUsage\n      .sort((a, b) => b.requestsPerMinute - a.requestsPerMinute)\n      .slice(0, count);\n  }\n\n  /**\n   * Gets the top spending virtual keys\n   * \n   * @param count - Number of top virtual keys to return (default: 10)\n   * @returns Promise<VirtualKeyStats[]> List of top spending virtual keys ordered by current spend\n   */\n  async getTopSpendingVirtualKeys(count: number = 10): Promise<VirtualKeyStats[]> {\n    if (count <= 0) {\n      throw new Error('Count must be greater than 0');\n    }\n\n    const metrics = await this.getBusinessMetrics();\n    return metrics.virtualKeyStats\n      .sort((a, b) => b.currentSpend - a.currentSpend)\n      .slice(0, count);\n  }\n\n  /**\n   * Gets providers that are currently unhealthy\n   * \n   * @returns Promise<ProviderHealthStatus[]> List of unhealthy providers\n   */\n  async getUnhealthyProviders(): Promise<ProviderHealthStatus[]> {\n    const allProviders = await this.getProviderHealth();\n    return allProviders.filter(p => !p.isHealthy);\n  }\n\n  /**\n   * Calculates the overall system health percentage\n   * \n   * @returns Promise<number> System health percentage (0-100)\n   */\n  async getSystemHealthPercentage(): Promise<number> {\n    const providers = await this.getProviderHealth();\n    if (providers.length === 0) return 100; // If no providers, assume healthy\n\n    const healthyCount = providers.filter(p => p.isHealthy).length;\n    return (healthyCount / providers.length) * 100;\n  }\n\n  /**\n   * Gets the current cost burn rate in USD per hour\n   * \n   * @returns Promise<number> Current cost burn rate in USD per hour\n   */\n  async getCurrentCostBurnRate(): Promise<number> {\n    const metrics = await this.getBusinessMetrics();\n    return metrics.cost.costPerMinute * 60; // Convert per-minute to per-hour\n  }\n\n  /**\n   * Checks if the system is currently healthy based on configurable thresholds\n   * \n   * @param options - Health check criteria\n   * @returns Promise<boolean> True if the system is healthy based on the specified thresholds\n   */\n  async isSystemHealthy(options: {\n    maxErrorRate?: number;\n    maxResponseTime?: number;\n    minProviderHealthPercentage?: number;\n  } = {}): Promise<boolean> {\n    const {\n      maxErrorRate = 5.0,\n      maxResponseTime = 2000.0,\n      minProviderHealthPercentage = 80.0\n    } = options;\n\n    try {\n      const snapshot = await this.getCurrentMetrics();\n\n      // Check error rate\n      if (snapshot.http.errorRate > maxErrorRate) {\n        return false;\n      }\n\n      // Check response time\n      if (snapshot.http.responseTimes.p95 > maxResponseTime) {\n        return false;\n      }\n\n      // Check provider health\n      const providerHealth = await this.getSystemHealthPercentage();\n      if (providerHealth < minProviderHealthPercentage) {\n        return false;\n      }\n\n      return true;\n    } catch {\n      return false; // Assume unhealthy if we can't get metrics\n    }\n  }\n\n  /**\n   * Gets a summary of key performance indicators\n   * \n   * @returns Promise<KPISummary> A summary object with key performance indicators\n   */\n  async getKPISummary(): Promise<KPISummary> {\n    const snapshot = await this.getCurrentMetrics();\n    const systemHealth = await this.getSystemHealthPercentage();\n    const costBurnRate = await this.getCurrentCostBurnRate();\n\n    return {\n      timestamp: snapshot.timestamp,\n      systemHealth: {\n        overallHealthPercentage: systemHealth,\n        errorRate: snapshot.http.errorRate,\n        responseTimeP95: snapshot.http.responseTimes.p95,\n        activeConnections: snapshot.infrastructure.database.activeConnections,\n        databaseUtilization: snapshot.infrastructure.database.poolUtilization\n      },\n      performance: {\n        requestsPerSecond: snapshot.http.requestsPerSecond,\n        activeRequests: snapshot.http.activeRequests,\n        averageResponseTime: snapshot.http.responseTimes.average,\n        cacheHitRate: snapshot.infrastructure.redis.hitRate\n      },\n      business: {\n        activeVirtualKeys: snapshot.business.activeVirtualKeys,\n        requestsPerMinute: snapshot.business.totalRequestsPerMinute,\n        costBurnRatePerHour: costBurnRate,\n        averageCostPerRequest: snapshot.business.cost.averageCostPerRequest\n      },\n      infrastructure: {\n        cpuUsage: snapshot.system.cpuUsagePercent,\n        memoryUsage: snapshot.system.memoryUsageMB,\n        uptime: snapshot.system.uptime,\n        signalRConnections: snapshot.infrastructure.signalR.activeConnections\n      }\n    };\n  }\n\n  /**\n   * Gets metrics for the last N minutes\n   * \n   * @param minutes - Number of minutes to look back\n   * @param interval - Data aggregation interval (default: \"1m\")\n   * @returns Promise<HistoricalMetricsResponse> Historical metrics for the specified period\n   */\n  async getMetricsForLastMinutes(minutes: number, interval: string = '1m'): Promise<HistoricalMetricsResponse> {\n    const endTime = new Date();\n    const startTime = new Date(endTime.getTime() - (minutes * 60 * 1000));\n\n    return this.getHistoricalMetricsSimple(startTime, endTime, [], interval);\n  }\n\n  /**\n   * Gets metrics for the last N hours\n   * \n   * @param hours - Number of hours to look back\n   * @param interval - Data aggregation interval (default: \"5m\")\n   * @returns Promise<HistoricalMetricsResponse> Historical metrics for the specified period\n   */\n  async getMetricsForLastHours(hours: number, interval: string = '5m'): Promise<HistoricalMetricsResponse> {\n    const endTime = new Date();\n    const startTime = new Date(endTime.getTime() - (hours * 60 * 60 * 1000));\n\n    return this.getHistoricalMetricsSimple(startTime, endTime, [], interval);\n  }\n\n  /**\n   * Gets metrics for today\n   * \n   * @param interval - Data aggregation interval (default: \"15m\")\n   * @returns Promise<HistoricalMetricsResponse> Historical metrics for today\n   */\n  async getMetricsForToday(interval: string = '15m'): Promise<HistoricalMetricsResponse> {\n    const endTime = new Date();\n    const startTime = new Date();\n    startTime.setHours(0, 0, 0, 0);\n\n    return this.getHistoricalMetricsSimple(startTime, endTime, [], interval);\n  }\n}","/**\n * Model capabilities that match the ILLMClient interface.\n */\nexport interface ModelCapabilities {\n  chat: boolean;\n  chat_stream: boolean;\n  embeddings: boolean;\n  image_generation: boolean;\n  vision: boolean;\n  video_generation: boolean;\n  video_understanding: boolean;\n  function_calling: boolean;\n  tool_use: boolean;\n  json_mode: boolean;\n  max_tokens?: number;\n  max_output_tokens?: number;\n  supported_image_sizes?: string[];\n  supported_video_resolutions?: string[];\n  max_video_duration_seconds?: number;\n}\n\n/**\n * Represents a discovered model with its capabilities.\n */\nexport interface DiscoveredModel {\n  id: string;\n  provider: string;\n  display_name?: string;\n  capabilities: ModelCapabilities;\n  metadata?: Record<string, unknown>;\n  last_verified: string;\n}\n\n/**\n * Response model for getting all models.\n */\nexport interface ModelsDiscoveryResponse {\n  data: DiscoveredModel[];\n  count: number;\n}\n\n/**\n * Response model for provider-specific models.\n */\nexport interface ProviderModelsDiscoveryResponse {\n  provider: string;\n  data: DiscoveredModel[];\n  count: number;\n}\n\n/**\n * Specific model capabilities to test.\n */\nexport enum ModelCapability {\n  Chat = 'Chat',\n  ChatStream = 'ChatStream',\n  Embeddings = 'Embeddings',\n  ImageGeneration = 'ImageGeneration',\n  Vision = 'Vision',\n  VideoGeneration = 'VideoGeneration',\n  VideoUnderstanding = 'VideoUnderstanding',\n  FunctionCalling = 'FunctionCalling',\n  ToolUse = 'ToolUse',\n  JsonMode = 'JsonMode'\n}\n\n/**\n * Response model for capability testing.\n */\nexport interface CapabilityTestResponse {\n  model: string;\n  capability: string;\n  supported: boolean;\n}\n\n/**\n * Individual capability test within a bulk request.\n */\nexport interface CapabilityTest {\n  model: string;\n  capability: string;\n}\n\n/**\n * Request model for bulk capability testing.\n */\nexport interface BulkCapabilityTestRequest {\n  tests: CapabilityTest[];\n}\n\n/**\n * Result of a single capability test.\n */\nexport interface CapabilityTestResult {\n  model: string;\n  capability: string;\n  supported: boolean;\n  error?: string;\n}\n\n/**\n * Response model for bulk capability testing.\n */\nexport interface BulkCapabilityTestResponse {\n  results: CapabilityTestResult[];\n  totalTests: number;\n  successfulTests: number;\n  failedTests: number;\n}\n\n/**\n * Request model for bulk model discovery.\n */\nexport interface BulkModelDiscoveryRequest {\n  models: string[];\n}\n\n/**\n * Discovery result for a single model.\n */\nexport interface ModelDiscoveryResult {\n  model: string;\n  provider?: string;\n  displayName?: string;\n  capabilities: Record<string, boolean>;\n  found: boolean;\n  error?: string;\n}\n\n/**\n * Response model for bulk model discovery.\n */\nexport interface BulkModelDiscoveryResponse {\n  results: ModelDiscoveryResult[];\n  totalRequested: number;\n  foundModels: number;\n  notFoundModels: number;\n}","import type { FetchBasedClient } from '../client/FetchBasedClient';\nimport { createClientAdapter, type IFetchBasedClientAdapter } from '../client/ClientAdapter';\nimport type { RequestOptions } from '../client/types';\n\n/**\n * Service for retrieving provider model information.\n */\nexport class ProviderModelsService {\n  private readonly baseEndpoint = '/api/provider-models';\n  private readonly clientAdapter: IFetchBasedClientAdapter;\n\n  constructor(client: FetchBasedClient) {\n    this.clientAdapter = createClientAdapter(client);\n  }\n\n  /**\n   * Gets available models for a specified provider.\n   * @param providerName - Name of the provider\n   * @param forceRefresh - Whether to bypass cache and force refresh\n   * @returns List of available model IDs\n   */\n  async getProviderModels(\n    providerName: string, \n    forceRefresh = false,\n    options?: RequestOptions\n  ): Promise<string[]> {\n    if (!providerName?.trim()) {\n      throw new Error('Provider name is required');\n    }\n\n    const queryParams = forceRefresh ? '?forceRefresh=true' : '';\n    \n    const response = await this.clientAdapter.get<string[]>(\n      `${this.baseEndpoint}/${encodeURIComponent(providerName)}${queryParams}`,\n      options\n    );\n\n    return response;\n  }\n\n  /**\n   * Static validation helper to validate provider name.\n   */\n  static validateProviderName(providerName: string): void {\n    if (!providerName?.trim()) {\n      throw new Error('Provider name is required');\n    }\n  }\n}","import { \n  BaseSignalRConnection as CommonBaseSignalRConnection,\n  type BaseSignalRConfig,\n  type SignalRAuthConfig\n} from '@knn_labs/conduit-common';\n\n/**\n * Base class for Core SDK SignalR hub connections.\n * Extends the common base class with Core SDK-specific authentication.\n */\nexport abstract class BaseSignalRConnection extends CommonBaseSignalRConnection {\n  protected readonly virtualKey: string;\n\n  constructor(baseUrl: string, virtualKey: string) {\n    // Configure Core SDK-specific authentication\n    const authConfig: SignalRAuthConfig = {\n      authToken: virtualKey,\n      authType: 'virtual'\n    };\n\n    const config: BaseSignalRConfig = {\n      baseUrl,\n      auth: authConfig,\n      options: {\n        reconnectionDelay: [0, 2000, 10000, 30000]\n      },\n      userAgent: 'Conduit-Core-Node-Client/0.2.0'\n    };\n\n    super(config);\n    this.virtualKey = virtualKey;\n  }\n\n  /**\n   * Starts the SignalR connection.\n   */\n  async start(): Promise<void> {\n    await this.getConnection();\n  }\n\n  /**\n   * Stops the SignalR connection.\n   */\n  async stop(): Promise<void> {\n    await this.disconnect();\n  }\n\n  /**\n   * Waits for the connection to be established.\n   */\n  async waitForConnection(timeoutMs = 30000): Promise<boolean> {\n    try {\n      await Promise.race([\n        this.waitForReady(),\n        new Promise<void>((_, reject) => \n          setTimeout(() => reject(new Error('Connection timeout')), timeoutMs)\n        )\n      ]);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n}","// Import common SignalR types from Common package\nimport {\n  HubConnectionState,\n  HttpTransportType,\n  DefaultTransports,\n  SignalRLogLevel,\n  type SignalRConnectionOptions\n} from '@knn_labs/conduit-common';\n\n// Re-export for backward compatibility\nexport {\n  HubConnectionState,\n  HttpTransportType,\n  DefaultTransports,\n  SignalRLogLevel\n};\n\nexport type { SignalRConnectionOptions };\n\n/**\n * SignalR hub endpoints.\n */\nexport const SignalREndpoints = {\n  TaskHub: '/hubs/tasks',\n  VideoGenerationHub: '/hubs/video-generation',\n  ImageGenerationHub: '/hubs/image-generation',\n  NavigationStateHub: '/hubs/navigation-state'\n} as const;\n\n/**\n * Task hub server interface.\n */\nexport interface ITaskHubServer {\n  subscribeToTask(taskId: string): Promise<void>;\n  unsubscribeFromTask(taskId: string): Promise<void>;\n  subscribeToTaskType(taskType: string): Promise<void>;\n  unsubscribeFromTaskType(taskType: string): Promise<void>;\n}\n\n/**\n * Video generation hub server interface.\n */\nexport interface IVideoGenerationHubServer {\n  subscribeToTask(taskId: string): Promise<void>;\n  unsubscribeFromTask(taskId: string): Promise<void>;\n}\n\n/**\n * Image generation hub server interface.\n */\nexport interface IImageGenerationHubServer {\n  subscribeToTask(taskId: string): Promise<void>;\n  unsubscribeFromTask(taskId: string): Promise<void>;\n}\n\n/**\n * Task started event data.\n */\nexport interface TaskStartedEvent {\n  eventType: 'TaskStarted';\n  taskId: string;\n  taskType: string;\n  metadata: Record<string, unknown>;\n}\n\n/**\n * Task progress event data.\n */\nexport interface TaskProgressEvent {\n  eventType: 'TaskProgress';\n  taskId: string;\n  progress: number;\n  message?: string;\n}\n\n/**\n * Task completed event data.\n */\nexport interface TaskCompletedEvent {\n  eventType: 'TaskCompleted';\n  taskId: string;\n  result: Record<string, unknown>;\n}\n\n/**\n * Task failed event data.\n */\nexport interface TaskFailedEvent {\n  eventType: 'TaskFailed';\n  taskId: string;\n  error: string;\n  isRetryable: boolean;\n}\n\n/**\n * Task cancelled event data.\n */\nexport interface TaskCancelledEvent {\n  eventType: 'TaskCancelled';\n  taskId: string;\n  reason?: string;\n}\n\n/**\n * Task timed out event data.\n */\nexport interface TaskTimedOutEvent {\n  eventType: 'TaskTimedOut';\n  taskId: string;\n  timeoutSeconds: number;\n}\n\n/**\n * Video generation started event data.\n */\nexport interface VideoGenerationStartedEvent {\n  eventType: 'VideoGenerationStarted';\n  taskId: string;\n  prompt: string;\n  estimatedSeconds: number;\n}\n\n/**\n * Video generation progress event data.\n */\nexport interface VideoGenerationProgressEvent {\n  eventType: 'VideoGenerationProgress';\n  taskId: string;\n  progress: number;\n  currentFrame?: number;\n  totalFrames?: number;\n  message?: string;\n}\n\n/**\n * Video generation completed event data.\n */\nexport interface VideoGenerationCompletedEvent {\n  eventType: 'VideoGenerationCompleted';\n  taskId: string;\n  videoUrl: string;\n  duration: number;\n  metadata: Record<string, unknown>;\n}\n\n/**\n * Image generation started event data.\n */\nexport interface ImageGenerationStartedEvent {\n  eventType: 'ImageGenerationStarted';\n  taskId: string;\n  prompt: string;\n  model: string;\n}\n\n/**\n * Image generation progress event data.\n */\nexport interface ImageGenerationProgressEvent {\n  eventType: 'ImageGenerationProgress';\n  taskId: string;\n  progress: number;\n  stage?: string;\n}\n\n/**\n * Image generation completed event data.\n */\nexport interface ImageGenerationCompletedEvent {\n  eventType: 'ImageGenerationCompleted';\n  taskId: string;\n  imageUrl: string;\n  metadata: Record<string, unknown>;\n}\n\n/**\n * Video generation failed event data.\n */\nexport interface VideoGenerationFailedEvent {\n  eventType: 'VideoGenerationFailed';\n  taskId: string;\n  error: string;\n  errorCode?: string;\n  isRetryable: boolean;\n}\n\n/**\n * Image generation failed event data.\n */\nexport interface ImageGenerationFailedEvent {\n  eventType: 'ImageGenerationFailed';\n  taskId: string;\n  error: string;\n  errorCode?: string;\n  isRetryable: boolean;\n}\n\n/**\n * Union type for all task events.\n */\nexport type TaskEvent = \n  | TaskStartedEvent\n  | TaskProgressEvent\n  | TaskCompletedEvent\n  | TaskFailedEvent\n  | TaskCancelledEvent\n  | TaskTimedOutEvent;\n\n/**\n * Union type for all video generation events.\n */\nexport type VideoGenerationEvent = \n  | VideoGenerationStartedEvent\n  | VideoGenerationProgressEvent\n  | VideoGenerationCompletedEvent\n  | VideoGenerationFailedEvent;\n\n/**\n * Union type for all image generation events.\n */\nexport type ImageGenerationEvent = \n  | ImageGenerationStartedEvent\n  | ImageGenerationProgressEvent\n  | ImageGenerationCompletedEvent\n  | ImageGenerationFailedEvent;","import type * as signalR from '@microsoft/signalr';\nimport { BaseSignalRConnection } from './BaseSignalRConnection';\nimport { \n  SignalREndpoints,\n  type ITaskHubServer,\n  type TaskStartedEvent,\n  type TaskProgressEvent,\n  type TaskCompletedEvent,\n  type TaskFailedEvent,\n  type TaskCancelledEvent,\n  type TaskTimedOutEvent\n} from '../models/signalr';\n\n/**\n * SignalR client for the Task Hub, providing real-time task progress notifications.\n */\nexport class TaskHubClient extends BaseSignalRConnection implements ITaskHubServer {\n  /**\n   * Gets the hub path for task notifications.\n   */\n  protected get hubPath(): string {\n    return SignalREndpoints.TaskHub;\n  }\n\n  /**\n   * Event handlers for task notifications.\n   */\n  onTaskStarted?: (event: TaskStartedEvent) => Promise<void>;\n  onTaskProgress?: (event: TaskProgressEvent) => Promise<void>;\n  onTaskCompleted?: (event: TaskCompletedEvent) => Promise<void>;\n  onTaskFailed?: (event: TaskFailedEvent) => Promise<void>;\n  onTaskCancelled?: (event: TaskCancelledEvent) => Promise<void>;\n  onTaskTimedOut?: (event: TaskTimedOutEvent) => Promise<void>;\n\n  /**\n   * Configures the hub-specific event handlers.\n   */\n  protected configureHubHandlers(connection: signalR.HubConnection): void {\n    connection.on('TaskStarted', async (taskId: string, taskType: string, metadata: unknown) => {\n      console.warn(`Task started: ${taskId}, Type: ${taskType}`);\n      if (this.onTaskStarted) {\n        await this.onTaskStarted({ eventType: 'TaskStarted', taskId, taskType, metadata: metadata as Record<string, unknown> });\n      }\n    });\n\n    connection.on('TaskProgress', async (taskId: string, progress: number, message?: string) => {\n      console.warn(`Task progress: ${taskId}, Progress: ${progress}%`);\n      if (this.onTaskProgress) {\n        await this.onTaskProgress({ eventType: 'TaskProgress', taskId, progress, message });\n      }\n    });\n\n    connection.on('TaskCompleted', async (taskId: string, result: unknown) => {\n      console.warn(`Task completed: ${taskId}`);\n      if (this.onTaskCompleted) {\n        await this.onTaskCompleted({ eventType: 'TaskCompleted', taskId, result: result as Record<string, unknown> });\n      }\n    });\n\n    connection.on('TaskFailed', async (taskId: string, error: string, isRetryable: boolean) => {\n      console.error(`Task failed: ${taskId}, Error: ${error}, Retryable: ${isRetryable}`);\n      if (this.onTaskFailed) {\n        await this.onTaskFailed({ eventType: 'TaskFailed', taskId, error, isRetryable });\n      }\n    });\n\n    connection.on('TaskCancelled', async (taskId: string, reason?: string) => {\n      console.warn(`Task cancelled: ${taskId}, Reason: ${reason}`);\n      if (this.onTaskCancelled) {\n        await this.onTaskCancelled({ eventType: 'TaskCancelled', taskId, reason });\n      }\n    });\n\n    connection.on('TaskTimedOut', async (taskId: string, timeoutSeconds: number) => {\n      console.error(`Task timed out: ${taskId}, Timeout: ${timeoutSeconds}s`);\n      if (this.onTaskTimedOut) {\n        await this.onTaskTimedOut({ eventType: 'TaskTimedOut', taskId, timeoutSeconds });\n      }\n    });\n  }\n\n  /**\n   * Subscribe to notifications for a specific task.\n   */\n  async subscribeToTask(taskId: string): Promise<void> {\n    if (!taskId?.trim()) {\n      throw new Error('Task ID cannot be null or empty');\n    }\n\n    await this.invoke('SubscribeToTask', taskId);\n    console.warn(`Subscribed to task: ${taskId}`);\n  }\n\n  /**\n   * Unsubscribe from notifications for a specific task.\n   */\n  async unsubscribeFromTask(taskId: string): Promise<void> {\n    if (!taskId?.trim()) {\n      throw new Error('Task ID cannot be null or empty');\n    }\n\n    await this.invoke('UnsubscribeFromTask', taskId);\n    console.warn(`Unsubscribed from task: ${taskId}`);\n  }\n\n  /**\n   * Subscribe to notifications for all tasks of a specific type.\n   */\n  async subscribeToTaskType(taskType: string): Promise<void> {\n    if (!taskType?.trim()) {\n      throw new Error('Task type cannot be null or empty');\n    }\n\n    await this.invoke('SubscribeToTaskType', taskType);\n    console.warn(`Subscribed to task type: ${taskType}`);\n  }\n\n  /**\n   * Unsubscribe from notifications for a task type.\n   */\n  async unsubscribeFromTaskType(taskType: string): Promise<void> {\n    if (!taskType?.trim()) {\n      throw new Error('Task type cannot be null or empty');\n    }\n\n    await this.invoke('UnsubscribeFromTaskType', taskType);\n    console.warn(`Unsubscribed from task type: ${taskType}`);\n  }\n\n  /**\n   * Subscribe to multiple tasks at once.\n   */\n  async subscribeToTasks(taskIds: string[]): Promise<void> {\n    await Promise.all(taskIds.map(taskId => this.subscribeToTask(taskId)));\n  }\n\n  /**\n   * Unsubscribe from multiple tasks at once.\n   */\n  async unsubscribeFromTasks(taskIds: string[]): Promise<void> {\n    await Promise.all(taskIds.map(taskId => this.unsubscribeFromTask(taskId)));\n  }\n\n  /**\n   * Subscribe to multiple task types at once.\n   */\n  async subscribeToTaskTypes(taskTypes: string[]): Promise<void> {\n    await Promise.all(taskTypes.map(taskType => this.subscribeToTaskType(taskType)));\n  }\n\n  /**\n   * Unsubscribe from multiple task types at once.\n   */\n  async unsubscribeFromTaskTypes(taskTypes: string[]): Promise<void> {\n    await Promise.all(taskTypes.map(taskType => this.unsubscribeFromTaskType(taskType)));\n  }\n}","import type * as signalR from '@microsoft/signalr';\nimport { BaseSignalRConnection } from './BaseSignalRConnection';\nimport { \n  SignalREndpoints,\n  type IVideoGenerationHubServer,\n  type VideoGenerationStartedEvent,\n  type VideoGenerationProgressEvent,\n  type VideoGenerationCompletedEvent,\n  type VideoGenerationFailedEvent\n} from '../models/signalr';\n\n/**\n * SignalR client for the Video Generation Hub, providing real-time video generation notifications.\n */\nexport class VideoGenerationHubClient extends BaseSignalRConnection implements IVideoGenerationHubServer {\n  /**\n   * Gets the hub path for video generation notifications.\n   */\n  protected get hubPath(): string {\n    return SignalREndpoints.VideoGenerationHub;\n  }\n\n  /**\n   * Event handlers for video generation notifications.\n   */\n  onVideoGenerationStarted?: (event: VideoGenerationStartedEvent) => Promise<void>;\n  onVideoGenerationProgress?: (event: VideoGenerationProgressEvent) => Promise<void>;\n  onVideoGenerationCompleted?: (event: VideoGenerationCompletedEvent) => Promise<void>;\n  onVideoGenerationFailed?: (event: VideoGenerationFailedEvent) => Promise<void>;\n\n  /**\n   * Configures the hub-specific event handlers.\n   */\n  protected configureHubHandlers(connection: signalR.HubConnection): void {\n    connection.on('VideoGenerationStarted', async (taskId: string, prompt: string, estimatedSeconds: number) => {\n      console.warn(`Video generation started: ${taskId}, Estimated: ${estimatedSeconds}s`);\n      if (this.onVideoGenerationStarted) {\n        await this.onVideoGenerationStarted({ eventType: 'VideoGenerationStarted', taskId, prompt, estimatedSeconds });\n      }\n    });\n\n    connection.on('VideoGenerationProgress', async (\n      taskId: string, \n      progress: number, \n      currentFrame?: number, \n      totalFrames?: number, \n      message?: string\n    ) => {\n      console.warn(`Video generation progress: ${taskId}, Progress: ${progress}%`);\n      if (this.onVideoGenerationProgress) {\n        await this.onVideoGenerationProgress({ \n          eventType: 'VideoGenerationProgress',\n          taskId, \n          progress, \n          currentFrame, \n          totalFrames, \n          message \n        });\n      }\n    });\n\n    connection.on('VideoGenerationCompleted', async (\n      taskId: string, \n      videoUrl: string, \n      duration: number, \n      metadata: unknown\n    ) => {\n      console.warn(`Video generation completed: ${taskId}, Duration: ${duration}s`);\n      if (this.onVideoGenerationCompleted) {\n        await this.onVideoGenerationCompleted({ eventType: 'VideoGenerationCompleted', taskId, videoUrl, duration, metadata: metadata as Record<string, unknown> });\n      }\n    });\n\n    connection.on('VideoGenerationFailed', async (taskId: string, error: string, isRetryable: boolean) => {\n      console.error(`Video generation failed: ${taskId}, Error: ${error}`);\n      if (this.onVideoGenerationFailed) {\n        await this.onVideoGenerationFailed({ eventType: 'VideoGenerationFailed', taskId, error, isRetryable, errorCode: undefined });\n      }\n    });\n  }\n\n  /**\n   * Subscribe to notifications for a specific video generation task.\n   */\n  async subscribeToTask(taskId: string): Promise<void> {\n    if (!taskId?.trim()) {\n      throw new Error('Task ID cannot be null or empty');\n    }\n\n    await this.invoke('SubscribeToTask', taskId);\n    console.warn(`Subscribed to video generation task: ${taskId}`);\n  }\n\n  /**\n   * Unsubscribe from notifications for a specific video generation task.\n   */\n  async unsubscribeFromTask(taskId: string): Promise<void> {\n    if (!taskId?.trim()) {\n      throw new Error('Task ID cannot be null or empty');\n    }\n\n    await this.invoke('UnsubscribeFromTask', taskId);\n    console.warn(`Unsubscribed from video generation task: ${taskId}`);\n  }\n\n  /**\n   * Subscribe to multiple tasks at once.\n   */\n  async subscribeToTasks(taskIds: string[]): Promise<void> {\n    await Promise.all(taskIds.map(taskId => this.subscribeToTask(taskId)));\n  }\n\n  /**\n   * Unsubscribe from multiple tasks at once.\n   */\n  async unsubscribeFromTasks(taskIds: string[]): Promise<void> {\n    await Promise.all(taskIds.map(taskId => this.unsubscribeFromTask(taskId)));\n  }\n}","import type * as signalR from '@microsoft/signalr';\nimport { BaseSignalRConnection } from './BaseSignalRConnection';\nimport { \n  SignalREndpoints,\n  type IImageGenerationHubServer,\n  type ImageGenerationStartedEvent,\n  type ImageGenerationProgressEvent,\n  type ImageGenerationCompletedEvent,\n  type ImageGenerationFailedEvent\n} from '../models/signalr';\n\n/**\n * SignalR client for the Image Generation Hub, providing real-time image generation notifications.\n */\nexport class ImageGenerationHubClient extends BaseSignalRConnection implements IImageGenerationHubServer {\n  /**\n   * Gets the hub path for image generation notifications.\n   */\n  protected get hubPath(): string {\n    return SignalREndpoints.ImageGenerationHub;\n  }\n\n  /**\n   * Event handlers for image generation notifications.\n   */\n  onImageGenerationStarted?: (event: ImageGenerationStartedEvent) => Promise<void>;\n  onImageGenerationProgress?: (event: ImageGenerationProgressEvent) => Promise<void>;\n  onImageGenerationCompleted?: (event: ImageGenerationCompletedEvent) => Promise<void>;\n  onImageGenerationFailed?: (event: ImageGenerationFailedEvent) => Promise<void>;\n\n  /**\n   * Configures the hub-specific event handlers.\n   */\n  protected configureHubHandlers(connection: signalR.HubConnection): void {\n    connection.on('ImageGenerationStarted', async (taskId: string, prompt: string, model: string) => {\n      console.warn(`Image generation started: ${taskId}, Model: ${model}`);\n      if (this.onImageGenerationStarted) {\n        await this.onImageGenerationStarted({ eventType: 'ImageGenerationStarted', taskId, prompt, model });\n      }\n    });\n\n    connection.on('ImageGenerationProgress', async (taskId: string, progress: number, stage?: string) => {\n      console.warn(`Image generation progress: ${taskId}, Progress: ${progress}%, Stage: ${stage}`);\n      if (this.onImageGenerationProgress) {\n        await this.onImageGenerationProgress({ eventType: 'ImageGenerationProgress', taskId, progress, stage });\n      }\n    });\n\n    connection.on('ImageGenerationCompleted', async (taskId: string, imageUrl: string, metadata: unknown) => {\n      console.warn(`Image generation completed: ${taskId}`);\n      if (this.onImageGenerationCompleted) {\n        await this.onImageGenerationCompleted({ eventType: 'ImageGenerationCompleted', taskId, imageUrl, metadata: metadata as Record<string, unknown> });\n      }\n    });\n\n    connection.on('ImageGenerationFailed', async (taskId: string, error: string, isRetryable: boolean) => {\n      console.error(`Image generation failed: ${taskId}, Error: ${error}`);\n      if (this.onImageGenerationFailed) {\n        await this.onImageGenerationFailed({ eventType: 'ImageGenerationFailed', taskId, error, isRetryable, errorCode: undefined });\n      }\n    });\n  }\n\n  /**\n   * Subscribe to notifications for a specific image generation task.\n   */\n  async subscribeToTask(taskId: string): Promise<void> {\n    if (!taskId?.trim()) {\n      throw new Error('Task ID cannot be null or empty');\n    }\n\n    await this.invoke('SubscribeToTask', taskId);\n    console.warn(`Subscribed to image generation task: ${taskId}`);\n  }\n\n  /**\n   * Unsubscribe from notifications for a specific image generation task.\n   */\n  async unsubscribeFromTask(taskId: string): Promise<void> {\n    if (!taskId?.trim()) {\n      throw new Error('Task ID cannot be null or empty');\n    }\n\n    await this.invoke('UnsubscribeFromTask', taskId);\n    console.warn(`Unsubscribed from image generation task: ${taskId}`);\n  }\n\n  /**\n   * Subscribe to multiple tasks at once.\n   */\n  async subscribeToTasks(taskIds: string[]): Promise<void> {\n    await Promise.all(taskIds.map(taskId => this.subscribeToTask(taskId)));\n  }\n\n  /**\n   * Unsubscribe from multiple tasks at once.\n   */\n  async unsubscribeFromTasks(taskIds: string[]): Promise<void> {\n    await Promise.all(taskIds.map(taskId => this.unsubscribeFromTask(taskId)));\n  }\n}","import type { BaseSignalRConnection } from '../signalr/BaseSignalRConnection';\nimport { TaskHubClient } from '../signalr/TaskHubClient';\nimport { VideoGenerationHubClient } from '../signalr/VideoGenerationHubClient';\nimport { ImageGenerationHubClient } from '../signalr/ImageGenerationHubClient';\nimport type { HubConnectionState } from '../models/signalr';\n\n/**\n * Service for managing SignalR hub connections for real-time notifications.\n */\nexport class SignalRService {\n  private readonly baseUrl: string;\n  private readonly virtualKey: string;\n  private readonly connections = new Map<string, BaseSignalRConnection>();\n  private disposed = false;\n\n  constructor(baseUrl: string, virtualKey: string) {\n    this.baseUrl = baseUrl;\n    this.virtualKey = virtualKey;\n  }\n\n  /**\n   * Gets or creates a TaskHubClient for task progress notifications.\n   */\n  getTaskHubClient(): TaskHubClient {\n    return this.getOrCreateConnection('TaskHubClient', \n      () => new TaskHubClient(this.baseUrl, this.virtualKey));\n  }\n\n  /**\n   * Gets or creates a VideoGenerationHubClient for video generation notifications.\n   */\n  getVideoGenerationHubClient(): VideoGenerationHubClient {\n    return this.getOrCreateConnection('VideoGenerationHubClient', \n      () => new VideoGenerationHubClient(this.baseUrl, this.virtualKey));\n  }\n\n  /**\n   * Gets or creates an ImageGenerationHubClient for image generation notifications.\n   */\n  getImageGenerationHubClient(): ImageGenerationHubClient {\n    return this.getOrCreateConnection('ImageGenerationHubClient', \n      () => new ImageGenerationHubClient(this.baseUrl, this.virtualKey));\n  }\n\n  /**\n   * Gets or creates a connection of the specified type.\n   */\n  private getOrCreateConnection<T extends BaseSignalRConnection>(\n    key: string, \n    factory: () => T\n  ): T {\n    const existing = this.connections.get(key);\n    if (existing) {\n      return existing as T;\n    }\n\n    const newConnection = factory();\n    this.connections.set(key, newConnection);\n    \n    return newConnection;\n  }\n\n  /**\n   * Starts all active hub connections.\n   */\n  async startAllConnections(): Promise<void> {\n    const startPromises = Array.from(this.connections.values()).map(\n      connection => connection.start()\n    );\n    await Promise.all(startPromises);\n  }\n\n  /**\n   * Stops all active hub connections.\n   */\n  async stopAllConnections(): Promise<void> {\n    const stopPromises = Array.from(this.connections.values()).map(\n      connection => connection.stop()\n    );\n    await Promise.all(stopPromises);\n  }\n\n  /**\n   * Waits for all connections to be established.\n   */\n  async waitForAllConnections(timeoutMs = 30000): Promise<boolean> {\n    const waitPromises = Array.from(this.connections.values()).map(\n      connection => connection.waitForConnection(timeoutMs)\n    );\n    \n    try {\n      const results = await Promise.all(waitPromises);\n      return results.every(result => result === true);\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Gets the connection status for all hub connections.\n   */\n  getConnectionStatus(): Record<string, HubConnectionState> {\n    const status: Record<string, HubConnectionState> = {};\n    \n    for (const [key, connection] of this.connections) {\n      status[key] = connection.state;\n    }\n    \n    return status;\n  }\n\n  /**\n   * Checks if all connections are established.\n   */\n  areAllConnectionsEstablished(): boolean {\n    return Array.from(this.connections.values()).every(\n      connection => connection.isConnected\n    );\n  }\n\n  /**\n   * Checks if SignalR service is connected.\n   */\n  isConnected(): boolean {\n    return this.areAllConnectionsEstablished();\n  }\n\n  /**\n   * Subscribes to a task across all relevant hubs.\n   */\n  async subscribeToTask(taskId: string, taskType?: string): Promise<void> {\n    const taskHubClient = this.getTaskHubClient();\n    await taskHubClient.subscribeToTask(taskId);\n\n    // Subscribe to specialized hubs based on task type\n    if (taskType?.toLowerCase().includes('video')) {\n      const videoHubClient = this.getVideoGenerationHubClient();\n      await videoHubClient.subscribeToTask(taskId);\n    } else if (taskType?.toLowerCase().includes('image')) {\n      const imageHubClient = this.getImageGenerationHubClient();\n      await imageHubClient.subscribeToTask(taskId);\n    }\n\n    console.warn(`Subscribed to task ${taskId} with type ${taskType}`);\n  }\n\n  /**\n   * Unsubscribes from a task across all relevant hubs.\n   */\n  async unsubscribeFromTask(taskId: string, taskType?: string): Promise<void> {\n    const taskHubClient = this.getTaskHubClient();\n    await taskHubClient.unsubscribeFromTask(taskId);\n\n    // Unsubscribe from specialized hubs based on task type\n    if (taskType?.toLowerCase().includes('video')) {\n      const videoHubClient = this.getVideoGenerationHubClient();\n      await videoHubClient.unsubscribeFromTask(taskId);\n    } else if (taskType?.toLowerCase().includes('image')) {\n      const imageHubClient = this.getImageGenerationHubClient();\n      await imageHubClient.unsubscribeFromTask(taskId);\n    }\n\n    console.warn(`Unsubscribed from task ${taskId} with type ${taskType}`);\n  }\n\n  /**\n   * Disposes all SignalR connections.\n   */\n  async dispose(): Promise<void> {\n    if (!this.disposed) {\n      const disposePromises = Array.from(this.connections.values()).map(\n        connection => connection.dispose()\n      );\n      await Promise.all(disposePromises);\n      \n      this.connections.clear();\n      this.disposed = true;\n      \n      console.warn('Disposed SignalRService and all connections');\n    }\n  }\n}","import { IMAGE_MODEL_CAPABILITIES, type ImageModel } from '../models/images';\nimport { ModelCapability, getCapabilityDisplayName as getDisplayName } from '@knn_labs/conduit-common';\n\n// Re-export ModelCapability but alias some Core-specific ones\nexport { ModelCapability };\nexport const CoreModelCapability = ModelCapability;\n\n/**\n * Check if a model supports a specific capability\n * @param modelId The model identifier\n * @param capability The capability to check for\n * @returns True if the model supports the capability\n */\nexport function modelSupportsCapability(\n  modelId: string,\n  capability: ModelCapability\n): boolean {\n  // For image generation models, check specific capabilities\n  if (modelId in IMAGE_MODEL_CAPABILITIES) {\n    const imageCapabilities = IMAGE_MODEL_CAPABILITIES[modelId as ImageModel];\n    switch (capability) {\n      case ModelCapability.IMAGE_GENERATION:\n        return true; // All models in IMAGE_MODEL_CAPABILITIES support generation\n      case ModelCapability.IMAGE_EDIT:\n        return imageCapabilities.supportsEdit;\n      case ModelCapability.IMAGE_VARIATION:\n        return imageCapabilities.supportsVariation;\n      case ModelCapability.VISION:\n      case ModelCapability.CHAT:\n        return false; // Image generation models don't support chat/vision\n      default:\n        return false;\n    }\n  }\n\n  // For other models, make reasonable assumptions based on model names\n  const lowerModelId = modelId.toLowerCase();\n  \n  switch (capability) {\n    case CoreModelCapability.CHAT:\n      // Most models support chat unless they're specifically image models\n      return !lowerModelId.includes('dall-e') && \n             !lowerModelId.includes('image') &&\n             !lowerModelId.includes('stable-diffusion');\n    \n    case CoreModelCapability.VISION:\n      // Vision models typically have 'vision' in the name or are GPT-4 variants\n      return lowerModelId.includes('vision') ||\n             lowerModelId.includes('gpt-4') ||\n             lowerModelId.includes('claude-3');\n    \n    case CoreModelCapability.IMAGE_GENERATION:\n      // Only specific image generation models\n      return lowerModelId.includes('dall-e') ||\n             lowerModelId.includes('image') ||\n             lowerModelId.includes('stable-diffusion') ||\n             lowerModelId.includes('minimax-image');\n    \n    default:\n      return false;\n  }\n}\n\n/**\n * Get all capabilities supported by a model\n * @param modelId The model identifier\n * @returns Array of supported capabilities\n */\nexport function getModelCapabilities(modelId: string): ModelCapability[] {\n  const capabilities: ModelCapability[] = [];\n\n  Object.values(ModelCapability).forEach(capability => {\n    if (modelSupportsCapability(modelId, capability)) {\n      capabilities.push(capability);\n    }\n  });\n\n  return capabilities;\n}\n\n/**\n * Validate that a request is compatible with the specified model\n * @param modelId The model identifier\n * @param requestType The type of request being made\n * @returns Validation result with any errors\n */\nexport function validateModelCompatibility(\n  modelId: string,\n  requestType: 'chat' | 'image-generation' | 'image-edit' | 'image-variation'\n): {\n  isValid: boolean;\n  errors: string[];\n  suggestions?: string[];\n} {\n  const errors: string[] = [];\n  const suggestions: string[] = [];\n\n  const capabilityMap: Record<string, ModelCapability> = {\n    'chat': ModelCapability.CHAT,\n    'image-generation': ModelCapability.IMAGE_GENERATION,\n    'image-edit': ModelCapability.IMAGE_EDIT,\n    'image-variation': ModelCapability.IMAGE_VARIATION,\n  };\n\n  const requiredCapability = capabilityMap[requestType];\n  \n  if (!modelSupportsCapability(modelId, requiredCapability)) {\n    errors.push(`Model '${modelId}' does not support ${requestType}`);\n    \n    // Provide suggestions based on request type\n    switch (requestType) {\n      case 'image-generation':\n        suggestions.push('Try using models like: dall-e-3, dall-e-2, or minimax-image');\n        break;\n      case 'image-edit':\n      case 'image-variation':\n        suggestions.push('Try using dall-e-2 for image editing and variations');\n        break;\n      case 'chat':\n        suggestions.push('Try using models like: gpt-4, gpt-3.5-turbo, or claude-3');\n        break;\n    }\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors,\n    suggestions: suggestions.length > 0 ? suggestions : undefined,\n  };\n}\n\n/**\n * Get optimal model recommendations for a specific capability\n * @param capability The desired capability\n * @param preferences Optional preferences for model selection\n * @returns Array of recommended model IDs, ordered by preference\n */\nexport function getRecommendedModels(\n  capability: ModelCapability,\n  preferences?: {\n    prioritizeQuality?: boolean;\n    prioritizeSpeed?: boolean;\n    prioritizeCost?: boolean;\n  }\n): string[] {\n  const { prioritizeQuality, prioritizeSpeed, prioritizeCost } = preferences ?? {};\n\n  switch (capability) {\n    case ModelCapability.CHAT:\n      if (prioritizeQuality) {\n        return ['gpt-4', 'claude-3-sonnet', 'gpt-3.5-turbo'];\n      }\n      if (prioritizeSpeed) {\n        return ['gpt-3.5-turbo', 'gpt-4', 'claude-3-haiku'];\n      }\n      if (prioritizeCost) {\n        return ['gpt-3.5-turbo', 'claude-3-haiku', 'gpt-4'];\n      }\n      return ['gpt-4', 'gpt-3.5-turbo', 'claude-3-sonnet'];\n\n    case ModelCapability.VISION:\n      if (prioritizeQuality) {\n        return ['gpt-4-vision-preview', 'claude-3-sonnet', 'gpt-4'];\n      }\n      return ['gpt-4-vision-preview', 'claude-3-sonnet'];\n\n    case ModelCapability.IMAGE_GENERATION:\n      if (prioritizeQuality) {\n        return ['dall-e-3', 'minimax-image', 'dall-e-2'];\n      }\n      if (prioritizeSpeed) {\n        return ['dall-e-2', 'minimax-image', 'dall-e-3'];\n      }\n      if (prioritizeCost) {\n        return ['dall-e-2', 'minimax-image', 'dall-e-3'];\n      }\n      return ['dall-e-3', 'dall-e-2', 'minimax-image'];\n\n    case ModelCapability.IMAGE_EDIT:\n    case ModelCapability.IMAGE_VARIATION:\n      return ['dall-e-2']; // Currently only DALL-E 2 supports these\n\n    default:\n      return [];\n  }\n}\n\n/**\n * Get user-friendly display name for a capability\n * @param capability The capability to get display name for\n * @returns Human-readable display name\n */\nexport function getCapabilityDisplayName(capability: ModelCapability): string {\n  return getDisplayName(capability);\n}\n\n/**\n * Check if two models are functionally equivalent for a given capability\n * @param modelA First model to compare\n * @param modelB Second model to compare\n * @param capability The capability to compare for\n * @returns True if models are equivalent for the capability\n */\nexport function areModelsEquivalent(\n  modelA: string,\n  modelB: string,\n  capability: ModelCapability\n): boolean {\n  // Both must support the capability\n  if (!modelSupportsCapability(modelA, capability) || \n      !modelSupportsCapability(modelB, capability)) {\n    return false;\n  }\n\n  // For image generation, check if they have similar constraints\n  if (capability === CoreModelCapability.IMAGE_GENERATION) {\n    const capabilitiesA = IMAGE_MODEL_CAPABILITIES[modelA as ImageModel];\n    const capabilitiesB = IMAGE_MODEL_CAPABILITIES[modelB as ImageModel];\n    \n    if (capabilitiesA && capabilitiesB) {\n      return capabilitiesA.maxImages === capabilitiesB.maxImages &&\n             JSON.stringify(capabilitiesA.supportedSizes) === JSON.stringify(capabilitiesB.supportedSizes);\n    }\n  }\n\n  // For other capabilities, simple name-based equivalence\n  const normalizeModel = (model: string) => \n    model.toLowerCase().replace(/[^a-z0-9]/g, '');\n  \n  return normalizeModel(modelA) === normalizeModel(modelB);\n}","/**\n * Request for creating embeddings\n */\nexport interface EmbeddingRequest {\n  /**\n   * Input text(s) to generate embeddings for\n   */\n  input: string | string[];\n\n  /**\n   * ID of the model to use\n   */\n  model: string;\n\n  /**\n   * The format to return the embeddings in\n   * Can be either \"float\" or \"base64\"\n   * Default: \"float\"\n   */\n  encoding_format?: 'float' | 'base64';\n\n  /**\n   * The number of dimensions the resulting output embeddings should have\n   * Only supported in text-embedding-3 and later models\n   */\n  dimensions?: number;\n\n  /**\n   * A unique identifier representing your end-user\n   */\n  user?: string;\n}\n\n/**\n * Response from creating embeddings\n */\nexport interface EmbeddingResponse {\n  /**\n   * The list of embeddings generated\n   */\n  data: EmbeddingData[];\n\n  /**\n   * The model used for embedding generation\n   */\n  model: string;\n\n  /**\n   * The object type, always \"embedding\"\n   */\n  object: 'list';\n\n  /**\n   * Usage statistics for the request\n   */\n  usage: EmbeddingUsage;\n}\n\n/**\n * Individual embedding data\n */\nexport interface EmbeddingData {\n  /**\n   * The embedding vector represented as an array of floats or base64 encoded string\n   */\n  embedding: number[] | string;\n\n  /**\n   * The index of the embedding in the list of embeddings\n   */\n  index: number;\n\n  /**\n   * The object type, always \"embedding\"\n   */\n  object: 'embedding';\n}\n\n/**\n * Usage statistics for embeddings\n */\nexport interface EmbeddingUsage {\n  /**\n   * The number of tokens used by the prompt\n   */\n  prompt_tokens: number;\n\n  /**\n   * The total number of tokens used by the request\n   */\n  total_tokens: number;\n}\n\n/**\n * Available embedding models\n */\nexport const EmbeddingModels = {\n  /**\n   * OpenAI text-embedding-ada-002\n   * Dimensions: 1536\n   */\n  ADA_002: 'text-embedding-ada-002',\n\n  /**\n   * OpenAI text-embedding-3-small\n   * Dimensions: 1536 (can be reduced)\n   */\n  EMBEDDING_3_SMALL: 'text-embedding-3-small',\n\n  /**\n   * OpenAI text-embedding-3-large\n   * Dimensions: 3072 (can be reduced)\n   */\n  EMBEDDING_3_LARGE: 'text-embedding-3-large',\n\n  /**\n   * Default embedding model\n   */\n  DEFAULT: 'text-embedding-3-small',\n} as const;\n\n/**\n * Encoding format options\n */\nexport const EmbeddingEncodingFormats = {\n  /**\n   * Return embeddings as array of floats (default)\n   */\n  FLOAT: 'float',\n\n  /**\n   * Return embeddings as base64-encoded string\n   */\n  BASE64: 'base64',\n} as const;\n\n/**\n * Validates an embedding request\n */\nexport function validateEmbeddingRequest(request: EmbeddingRequest): void {\n  if (!request.input) {\n    throw new Error('Input is required');\n  }\n\n  if (typeof request.input === 'string') {\n    if (!request.input.trim()) {\n      throw new Error('Input text cannot be empty');\n    }\n  } else if (Array.isArray(request.input)) {\n    if (request.input.length === 0) {\n      throw new Error('At least one input text is required');\n    }\n    if (request.input.some(text => !text?.trim())) {\n      throw new Error('Input texts cannot be null or empty');\n    }\n  } else {\n    throw new Error('Input must be a string or array of strings');\n  }\n\n  if (!request.model) {\n    throw new Error('Model is required');\n  }\n\n  if (request.encoding_format && \n      request.encoding_format !== EmbeddingEncodingFormats.FLOAT &&\n      request.encoding_format !== EmbeddingEncodingFormats.BASE64) {\n    throw new Error(`Encoding format must be '${String(EmbeddingEncodingFormats.FLOAT)}' or '${String(EmbeddingEncodingFormats.BASE64)}'`);\n  }\n\n  if (request.dimensions !== undefined && request.dimensions <= 0) {\n    throw new Error('Dimensions must be a positive integer');\n  }\n}\n\n/**\n * Converts embedding response to float array\n */\nexport function convertEmbeddingToFloatArray(embedding: number[] | string): number[] {\n  if (Array.isArray(embedding)) {\n    return embedding;\n  }\n  \n  if (typeof embedding === 'string') {\n    // Base64 encoded embedding\n    const buffer = Buffer.from(embedding, 'base64');\n    const floats = new Float32Array(buffer.buffer, buffer.byteOffset, buffer.length / Float32Array.BYTES_PER_ELEMENT);\n    return Array.from(floats);\n  }\n  \n  throw new Error(`Unexpected embedding type: ${typeof embedding}`);\n}\n\n/**\n * Calculates cosine similarity between two embedding vectors\n */\nexport function calculateCosineSimilarity(embedding1: number[], embedding2: number[]): number {\n  if (embedding1.length !== embedding2.length) {\n    throw new Error('Embeddings must have the same dimensions');\n  }\n\n  let dotProduct = 0;\n  let magnitude1 = 0;\n  let magnitude2 = 0;\n\n  for (let i = 0; i < embedding1.length; i++) {\n    dotProduct += embedding1[i] * embedding2[i];\n    magnitude1 += embedding1[i] * embedding1[i];\n    magnitude2 += embedding2[i] * embedding2[i];\n  }\n\n  magnitude1 = Math.sqrt(magnitude1);\n  magnitude2 = Math.sqrt(magnitude2);\n\n  if (magnitude1 === 0 || magnitude2 === 0) {\n    return 0;\n  }\n\n  return dotProduct / (magnitude1 * magnitude2);\n}\n\n/**\n * Embedding streaming chunk\n */\nexport interface EmbeddingChunk {\n  id: string;\n  object: 'embedding.chunk';\n  created: number;\n  data: Partial<EmbeddingData>[];\n  index?: number;\n}","import type { FetchBasedClient } from '../client/FetchBasedClient';\nimport { createClientAdapter, type IFetchBasedClientAdapter } from '../client/ClientAdapter';\nimport {\n  type EmbeddingRequest,\n  type EmbeddingResponse,\n  EmbeddingModels,\n  validateEmbeddingRequest,\n  convertEmbeddingToFloatArray,\n  calculateCosineSimilarity\n} from '../models/embeddings';\nimport { ConduitError } from '../utils/errors';\nimport { API_ENDPOINTS } from '../constants/endpoints';\n\n/**\n * Service for creating text embeddings using the Conduit Core API\n */\nexport class EmbeddingsService {\n  private readonly clientAdapter: IFetchBasedClientAdapter;\n\n  constructor(client: FetchBasedClient) {\n    this.clientAdapter = createClientAdapter(client);\n  }\n\n  /**\n   * Creates embeddings for the given input text(s)\n   * \n   * @param request - The embedding request\n   * @param options - Request options\n   * @returns Promise<EmbeddingResponse> The embedding response containing the generated embeddings\n   * @throws {ConduitError} When the API request fails or validation fails\n   * \n   * @example\n   * ```typescript\n   * const response = await client.embeddings.createEmbedding({\n   *   input: \"Hello, world!\",\n   *   model: \"text-embedding-3-small\"\n   * });\n   * \n   * console.log(`Generated ${response.data.length} embeddings`);\n   * console.log(`Used ${response.usage.total_tokens} tokens`);\n   * ```\n   */\n  async createEmbedding(\n    request: EmbeddingRequest,\n    options?: { signal?: AbortSignal }\n  ): Promise<EmbeddingResponse> {\n    try {\n      validateEmbeddingRequest(request);\n\n      const response = await this.clientAdapter.post<EmbeddingResponse, EmbeddingRequest>(\n        API_ENDPOINTS.V1.EMBEDDINGS.BASE,\n        request,\n        options\n      );\n\n      return response;\n    } catch (error) {\n      if (error instanceof ConduitError) {\n        throw error;\n      }\n      throw new ConduitError(\n        `Embedding creation failed: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  /**\n   * Creates embeddings for a single text input\n   * \n   * @param text - The input text\n   * @param model - The model to use (defaults to text-embedding-3-small)\n   * @param options - Additional options\n   * @returns Promise<number[]> The embedding vector for the input text\n   * \n   * @example\n   * ```typescript\n   * const embedding = await client.embeddings.createSingleEmbedding(\n   *   \"Hello, world!\",\n   *   \"text-embedding-3-small\"\n   * );\n   * \n   * console.log(`Embedding dimension: ${embedding.length}`);\n   * ```\n   */\n  async createSingleEmbedding(\n    text: string,\n    model?: string,\n    options?: {\n      dimensions?: number;\n      encoding_format?: 'float' | 'base64';\n      user?: string;\n      signal?: AbortSignal;\n    }\n  ): Promise<number[]> {\n    const request: EmbeddingRequest = {\n      input: text,\n      model: model ?? EmbeddingModels.DEFAULT,\n      dimensions: options?.dimensions,\n      encoding_format: options?.encoding_format,\n      user: options?.user,\n    };\n\n    const response = await this.createEmbedding(request, { signal: options?.signal });\n    \n    if (response.data.length === 0) {\n      throw new ConduitError('No embeddings returned');\n    }\n\n    return convertEmbeddingToFloatArray(response.data[0].embedding);\n  }\n\n  /**\n   * Creates embeddings for multiple text inputs\n   * \n   * @param texts - The input texts\n   * @param model - The model to use (defaults to text-embedding-3-small)\n   * @param options - Additional options\n   * @returns Promise<number[][]> A list of embedding vectors for each input text\n   * \n   * @example\n   * ```typescript\n   * const embeddings = await client.embeddings.createBatchEmbeddings(\n   *   [\"Hello\", \"World\", \"AI\"],\n   *   \"text-embedding-3-small\"\n   * );\n   * \n   * embeddings.forEach((embedding, i) => {\n   *   console.log(`Text ${i}: ${embedding.length} dimensions`);\n   * });\n   * ```\n   */\n  async createBatchEmbeddings(\n    texts: string[],\n    model?: string,\n    options?: {\n      dimensions?: number;\n      encoding_format?: 'float' | 'base64';\n      user?: string;\n      signal?: AbortSignal;\n    }\n  ): Promise<number[][]> {\n    if (texts.length === 0) {\n      throw new Error('At least one text input is required');\n    }\n\n    const request: EmbeddingRequest = {\n      input: texts,\n      model: model ?? EmbeddingModels.DEFAULT,\n      dimensions: options?.dimensions,\n      encoding_format: options?.encoding_format,\n      user: options?.user,\n    };\n\n    const response = await this.createEmbedding(request, { signal: options?.signal });\n    \n    // Sort by index to ensure correct order\n    return response.data\n      .sort((a, b) => a.index - b.index)\n      .map(data => convertEmbeddingToFloatArray(data.embedding));\n  }\n\n  /**\n   * Finds the most similar texts from a list of candidates to a query text\n   * \n   * @param query - The query text\n   * @param candidates - The list of candidate texts\n   * @param options - Search options\n   * @returns Promise<Array<{ text: string; similarity: number; index: number }>> \n   *          Sorted list of candidates with similarity scores\n   * \n   * @example\n   * ```typescript\n   * const candidates = [\n   *   \"The cat sat on the mat\",\n   *   \"Dogs are loyal animals\",\n   *   \"The feline rested on the rug\",\n   *   \"Birds can fly\"\n   * ];\n   * \n   * const results = await client.embeddings.findSimilar(\n   *   \"A cat is sleeping\",\n   *   candidates,\n   *   { topK: 2 }\n   * );\n   * \n   * results.forEach(result => {\n   *   console.log(`\"${result.text}\" - Similarity: ${result.similarity.toFixed(3)}`);\n   * });\n   * ```\n   */\n  async findSimilar(\n    query: string,\n    candidates: string[],\n    options?: {\n      model?: string;\n      topK?: number;\n      dimensions?: number;\n      signal?: AbortSignal;\n    }\n  ): Promise<Array<{ text: string; similarity: number; index: number }>> {\n    if (candidates.length === 0) {\n      throw new Error('At least one candidate is required');\n    }\n\n    // Create embeddings for query and all candidates in a single batch\n    const allTexts = [query, ...candidates];\n    const embeddings = await this.createBatchEmbeddings(\n      allTexts,\n      options?.model,\n      {\n        dimensions: options?.dimensions,\n        signal: options?.signal,\n      }\n    );\n\n    const queryEmbedding = embeddings[0];\n    const candidateEmbeddings = embeddings.slice(1);\n\n    // Calculate similarities\n    const results = candidates.map((text, index) => ({\n      text,\n      similarity: calculateCosineSimilarity(queryEmbedding, candidateEmbeddings[index]),\n      index,\n    }));\n\n    // Sort by similarity (descending) and take top K\n    results.sort((a, b) => b.similarity - a.similarity);\n    \n    const topK = options?.topK ?? candidates.length;\n    return results.slice(0, topK);\n  }\n\n  /**\n   * Calculates the similarity between two texts\n   * \n   * @param text1 - The first text\n   * @param text2 - The second text\n   * @param model - The model to use for embeddings\n   * @param options - Additional options\n   * @returns Promise<number> The cosine similarity between -1 and 1\n   * \n   * @example\n   * ```typescript\n   * const similarity = await client.embeddings.calculateSimilarity(\n   *   \"The weather is nice today\",\n   *   \"It's a beautiful day outside\"\n   * );\n   * \n   * console.log(`Similarity: ${(similarity * 100).toFixed(1)}%`);\n   * ```\n   */\n  async calculateSimilarity(\n    text1: string,\n    text2: string,\n    model?: string,\n    options?: {\n      dimensions?: number;\n      signal?: AbortSignal;\n    }\n  ): Promise<number> {\n    const embeddings = await this.createBatchEmbeddings(\n      [text1, text2],\n      model,\n      options\n    );\n\n    return calculateCosineSimilarity(embeddings[0], embeddings[1]);\n  }\n\n  /**\n   * Groups texts by similarity using embeddings\n   * \n   * @param texts - The texts to group\n   * @param threshold - Similarity threshold for grouping (0-1)\n   * @param model - The model to use for embeddings\n   * @param options - Additional options\n   * @returns Promise<string[][]> Groups of similar texts\n   * \n   * @example\n   * ```typescript\n   * const texts = [\n   *   \"Python programming\",\n   *   \"JavaScript coding\",\n   *   \"Cooking recipes\",\n   *   \"Software development\",\n   *   \"Baking cakes\"\n   * ];\n   * \n   * const groups = await client.embeddings.groupBySimilarity(\n   *   texts,\n   *   0.7 // 70% similarity threshold\n   * );\n   * \n   * groups.forEach((group, i) => {\n   *   console.log(`Group ${i + 1}: ${group.join(\", \")}`);\n   * });\n   * ```\n   */\n  async groupBySimilarity(\n    texts: string[],\n    threshold: number = 0.7,\n    model?: string,\n    options?: {\n      dimensions?: number;\n      signal?: AbortSignal;\n    }\n  ): Promise<string[][]> {\n    if (texts.length === 0) {\n      return [];\n    }\n\n    if (threshold < 0 || threshold > 1) {\n      throw new Error('Threshold must be between 0 and 1');\n    }\n\n    const embeddings = await this.createBatchEmbeddings(texts, model, options);\n    const groups: number[][] = [];\n    const assigned = new Set<number>();\n\n    for (let i = 0; i < texts.length; i++) {\n      if (assigned.has(i)) continue;\n\n      const group = [i];\n      assigned.add(i);\n\n      for (let j = i + 1; j < texts.length; j++) {\n        if (assigned.has(j)) continue;\n\n        const similarity = calculateCosineSimilarity(embeddings[i], embeddings[j]);\n        if (similarity >= threshold) {\n          group.push(j);\n          assigned.add(j);\n        }\n      }\n\n      groups.push(group);\n    }\n\n    return groups.map(group => group.map(index => texts[index]));\n  }\n}\n\n/**\n * Helper functions for embeddings\n */\nexport const EmbeddingHelpers = {\n  /**\n   * Normalizes an embedding vector to unit length\n   */\n  normalize(embedding: number[]): number[] {\n    const magnitude = Math.sqrt(embedding.reduce((sum, val) => sum + val * val, 0));\n    if (magnitude === 0) return embedding;\n    return embedding.map(val => val / magnitude);\n  },\n\n  /**\n   * Calculates euclidean distance between two embeddings\n   */\n  euclideanDistance(embedding1: number[], embedding2: number[]): number {\n    if (embedding1.length !== embedding2.length) {\n      throw new Error('Embeddings must have the same dimensions');\n    }\n    \n    let sum = 0;\n    for (let i = 0; i < embedding1.length; i++) {\n      const diff = embedding1[i] - embedding2[i];\n      sum += diff * diff;\n    }\n    return Math.sqrt(sum);\n  },\n\n  /**\n   * Calculates the centroid of multiple embeddings\n   */\n  centroid(embeddings: number[][]): number[] {\n    if (embeddings.length === 0) {\n      throw new Error('At least one embedding is required');\n    }\n\n    const dimensions = embeddings[0].length;\n    const result = new Array(dimensions).fill(0);\n\n    for (const embedding of embeddings) {\n      for (let i = 0; i < dimensions; i++) {\n        result[i] += embedding[i];\n      }\n    }\n\n    return result.map(val => val / embeddings.length);\n  },\n};","import type { SignalRService } from './SignalRService';\nimport type { TaskHubClient } from '../signalr/TaskHubClient';\nimport type { VideoGenerationHubClient } from '../signalr/VideoGenerationHubClient';\nimport type { ImageGenerationHubClient } from '../signalr/ImageGenerationHubClient';\nimport type {\n  VideoProgressEvent,\n  ImageProgressEvent,\n  TaskUpdateEvent,\n  VideoProgressCallback,\n  ImageProgressCallback,\n  SpendUpdateCallback,\n  SpendLimitAlertCallback,\n  TaskUpdateCallback,\n  NotificationSubscription,\n  NotificationOptions,\n} from '../models/notifications';\nimport { HubConnectionState } from '../models/signalr';\n\n/**\n * Service for managing real-time notifications through SignalR\n */\nexport class NotificationsService {\n  private signalRService: SignalRService;\n  private subscriptions: Map<string, NotificationSubscription> = new Map();\n  private taskHubClient?: TaskHubClient;\n  private videoHubClient?: VideoGenerationHubClient;\n  private imageHubClient?: ImageGenerationHubClient;\n  private connectionStateCallbacks: Set<(state: 'connected' | 'disconnected' | 'reconnecting') => void> = new Set();\n\n  // Store callbacks for each subscription\n  private videoCallbacks: Map<string, VideoProgressCallback> = new Map();\n  private imageCallbacks: Map<string, ImageProgressCallback> = new Map();\n  private spendUpdateCallbacks: Map<string, SpendUpdateCallback> = new Map();\n  private spendLimitCallbacks: Map<string, SpendLimitAlertCallback> = new Map();\n  private taskCallbacks: Map<string, { taskId: string; callback: TaskUpdateCallback }> = new Map();\n\n  constructor(signalRService: SignalRService) {\n    this.signalRService = signalRService;\n  }\n\n  /**\n   * Subscribe to video generation progress events\n   */\n  onVideoProgress(\n    callback: VideoProgressCallback,\n    options?: NotificationOptions\n  ): NotificationSubscription {\n    // Ensure video hub client is initialized\n    if (!this.videoHubClient) {\n      this.videoHubClient = this.signalRService.getVideoGenerationHubClient();\n      \n      // Set up event handlers\n      this.videoHubClient.onVideoGenerationProgress = (event) => {\n        // Notify all video progress callbacks\n        for (const [subId, cb] of this.videoCallbacks) {\n          const subscription = this.subscriptions.get(subId);\n          if (!subscription) continue;\n          \n          // Apply filters if any\n          const opts = options?.filter?.taskIds;\n          if (opts && !opts.includes(event.taskId)) continue;\n          \n          const notificationEvent: VideoProgressEvent = {\n            taskId: event.taskId,\n            progress: event.progress,\n            status: 'processing',\n            message: event.message,\n          };\n          \n          cb(notificationEvent);\n        }\n        return Promise.resolve();\n      };\n      \n      this.videoHubClient.onVideoGenerationCompleted = (event) => {\n        // Notify all video progress callbacks\n        for (const [subId, cb] of this.videoCallbacks) {\n          const subscription = this.subscriptions.get(subId);\n          if (!subscription) continue;\n          \n          // Apply filters if any\n          const opts = options?.filter?.taskIds;\n          if (opts && !opts.includes(event.taskId)) continue;\n          \n          const notificationEvent: VideoProgressEvent = {\n            taskId: event.taskId,\n            progress: 100,\n            status: 'completed',\n            metadata: event.metadata,\n          };\n          \n          cb(notificationEvent);\n        }\n        return Promise.resolve();\n      };\n      \n      this.videoHubClient.onVideoGenerationFailed = (event) => {\n        // Notify all video progress callbacks\n        for (const [subId, cb] of this.videoCallbacks) {\n          const subscription = this.subscriptions.get(subId);\n          if (!subscription) continue;\n          \n          // Apply filters if any\n          const opts = options?.filter?.taskIds;\n          if (opts && !opts.includes(event.taskId)) continue;\n          \n          const notificationEvent: VideoProgressEvent = {\n            taskId: event.taskId,\n            progress: 0,\n            status: 'failed',\n            message: event.error,\n          };\n          \n          cb(notificationEvent);\n        }\n        return Promise.resolve();\n      };\n    }\n\n    const subscriptionId = this.generateSubscriptionId();\n    this.videoCallbacks.set(subscriptionId, callback);\n\n    const subscription: NotificationSubscription = {\n      id: subscriptionId,\n      eventType: 'videoProgress',\n      unsubscribe: () => this.unsubscribe(subscriptionId),\n    };\n\n    this.subscriptions.set(subscriptionId, subscription);\n\n    // Handle connection state changes\n    if (options?.onConnectionStateChange) {\n      this.connectionStateCallbacks.add(options.onConnectionStateChange);\n    }\n\n    return subscription;\n  }\n\n  /**\n   * Subscribe to image generation progress events\n   */\n  onImageProgress(\n    callback: ImageProgressCallback,\n    options?: NotificationOptions\n  ): NotificationSubscription {\n    // Ensure image hub client is initialized\n    if (!this.imageHubClient) {\n      this.imageHubClient = this.signalRService.getImageGenerationHubClient();\n      \n      // Set up event handlers\n      this.imageHubClient.onImageGenerationProgress = (event) => {\n        // Notify all image progress callbacks\n        for (const [subId, cb] of this.imageCallbacks) {\n          const subscription = this.subscriptions.get(subId);\n          if (!subscription) continue;\n          \n          // Apply filters if any\n          const opts = options?.filter?.taskIds;\n          if (opts && !opts.includes(event.taskId)) continue;\n          \n          const notificationEvent: ImageProgressEvent = {\n            taskId: event.taskId,\n            progress: event.progress,\n            status: 'processing',\n          };\n          \n          cb(notificationEvent);\n        }\n        return Promise.resolve();\n      };\n      \n      this.imageHubClient.onImageGenerationCompleted = (event) => {\n        // Notify all image progress callbacks\n        for (const [subId, cb] of this.imageCallbacks) {\n          const subscription = this.subscriptions.get(subId);\n          if (!subscription) continue;\n          \n          // Apply filters if any\n          const opts = options?.filter?.taskIds;\n          if (opts && !opts.includes(event.taskId)) continue;\n          \n          const notificationEvent: ImageProgressEvent = {\n            taskId: event.taskId,\n            progress: 100,\n            status: 'completed',\n            images: event.imageUrl ? [{ url: event.imageUrl }] : undefined,\n          };\n          \n          cb(notificationEvent);\n        }\n        return Promise.resolve();\n      };\n      \n      this.imageHubClient.onImageGenerationFailed = (event) => {\n        // Notify all image progress callbacks\n        for (const [subId, cb] of this.imageCallbacks) {\n          const subscription = this.subscriptions.get(subId);\n          if (!subscription) continue;\n          \n          // Apply filters if any\n          const opts = options?.filter?.taskIds;\n          if (opts && !opts.includes(event.taskId)) continue;\n          \n          const notificationEvent: ImageProgressEvent = {\n            taskId: event.taskId,\n            progress: 0,\n            status: 'failed',\n            message: event.error,\n          };\n          \n          cb(notificationEvent);\n        }\n        return Promise.resolve();\n      };\n    }\n\n    const subscriptionId = this.generateSubscriptionId();\n    this.imageCallbacks.set(subscriptionId, callback);\n\n    const subscription: NotificationSubscription = {\n      id: subscriptionId,\n      eventType: 'imageProgress',\n      unsubscribe: () => this.unsubscribe(subscriptionId),\n    };\n\n    this.subscriptions.set(subscriptionId, subscription);\n\n    if (options?.onConnectionStateChange) {\n      this.connectionStateCallbacks.add(options.onConnectionStateChange);\n    }\n\n    return subscription;\n  }\n\n  /**\n   * Subscribe to spend update events\n   */\n  onSpendUpdate(\n    callback: SpendUpdateCallback,\n    options?: NotificationOptions\n  ): NotificationSubscription {\n    // Ensure task hub client is initialized\n    this.taskHubClient ??= this.signalRService.getTaskHubClient();\n      \n    // Set up event handlers for spend updates\n    // Note: The current task hub doesn't directly support spend update events\n    // This would need to be implemented on the server side\n    // For now, we'll set up the structure for future implementation\n\n    const subscriptionId = this.generateSubscriptionId();\n    this.spendUpdateCallbacks.set(subscriptionId, callback);\n\n    const subscription: NotificationSubscription = {\n      id: subscriptionId,\n      eventType: 'spendUpdate',\n      unsubscribe: () => this.unsubscribe(subscriptionId),\n    };\n\n    this.subscriptions.set(subscriptionId, subscription);\n\n    if (options?.onConnectionStateChange) {\n      this.connectionStateCallbacks.add(options.onConnectionStateChange);\n    }\n\n    return subscription;\n  }\n\n  /**\n   * Subscribe to spend limit alert events\n   */\n  onSpendLimitAlert(\n    callback: SpendLimitAlertCallback,\n    options?: NotificationOptions\n  ): NotificationSubscription {\n    // Ensure task hub client is initialized\n    this.taskHubClient ??= this.signalRService.getTaskHubClient();\n      \n    // Set up event handlers for spend limit alerts\n    // Note: The current task hub doesn't directly support spend limit alert events\n    // This would need to be implemented on the server side\n    // For now, we'll set up the structure for future implementation\n\n    const subscriptionId = this.generateSubscriptionId();\n    this.spendLimitCallbacks.set(subscriptionId, callback);\n\n    const subscription: NotificationSubscription = {\n      id: subscriptionId,\n      eventType: 'spendLimitAlert',\n      unsubscribe: () => this.unsubscribe(subscriptionId),\n    };\n\n    this.subscriptions.set(subscriptionId, subscription);\n\n    if (options?.onConnectionStateChange) {\n      this.connectionStateCallbacks.add(options.onConnectionStateChange);\n    }\n\n    return subscription;\n  }\n\n  /**\n   * Subscribe to updates for a specific task\n   */\n  async subscribeToTask(\n    taskId: string,\n    taskType: 'video' | 'image' | 'batch' | 'other',\n    callback: TaskUpdateCallback,\n    options?: NotificationOptions\n  ): Promise<NotificationSubscription> {\n    const subscriptionId = this.generateSubscriptionId();\n    \n    // Subscribe to the task\n    await this.signalRService.subscribeToTask(taskId, taskType);\n    \n    // Store the callback\n    this.taskCallbacks.set(subscriptionId, { taskId, callback });\n\n    // Set up appropriate listeners based on task type\n    if (taskType === 'video') {\n      this.videoHubClient ??= this.signalRService.getVideoGenerationHubClient();\n      \n      // We've already set up the handlers in onVideoProgress\n    } else if (taskType === 'image') {\n      this.imageHubClient ??= this.signalRService.getImageGenerationHubClient();\n      \n      // We've already set up the handlers in onImageProgress\n    } else {\n      this.taskHubClient ??= this.signalRService.getTaskHubClient();\n      \n      // Set up generic task handlers if not already done\n      this.taskHubClient.onTaskProgress ??= (event) => {\n          // Notify task-specific callbacks\n          for (const [subId, taskInfo] of this.taskCallbacks) {\n            if (taskInfo.taskId === event.taskId) {\n              const subscription = this.subscriptions.get(subId);\n              if (!subscription) continue;\n              \n              const notificationEvent: TaskUpdateEvent = {\n                taskId: event.taskId,\n                taskType: taskType,\n                status: 'processing',\n                progress: event.progress,\n                metadata: {},\n              };\n              \n              taskInfo.callback(notificationEvent);\n            }\n          }\n          return Promise.resolve();\n        };\n      \n      this.taskHubClient.onTaskCompleted ??= (event) => {\n          // Notify task-specific callbacks\n          for (const [subId, taskInfo] of this.taskCallbacks) {\n            if (taskInfo.taskId === event.taskId) {\n              const subscription = this.subscriptions.get(subId);\n              if (!subscription) continue;\n              \n              const notificationEvent: TaskUpdateEvent = {\n                taskId: event.taskId,\n                taskType: taskType,\n                status: 'completed',\n                result: event.result,\n              };\n              \n              taskInfo.callback(notificationEvent);\n            }\n          }\n          return Promise.resolve();\n        };\n      \n      this.taskHubClient.onTaskFailed ??= (event) => {\n          // Notify task-specific callbacks\n          for (const [subId, taskInfo] of this.taskCallbacks) {\n            if (taskInfo.taskId === event.taskId) {\n              const subscription = this.subscriptions.get(subId);\n              if (!subscription) continue;\n              \n              const notificationEvent: TaskUpdateEvent = {\n                taskId: event.taskId,\n                taskType: taskType,\n                status: 'failed',\n                error: event.error,\n              };\n              \n              taskInfo.callback(notificationEvent);\n            }\n          }\n          return Promise.resolve();\n        };\n    }\n\n    const subscription: NotificationSubscription = {\n      id: subscriptionId,\n      eventType: 'taskUpdate',\n      unsubscribe: () => this.unsubscribe(subscriptionId),\n    };\n\n    this.subscriptions.set(subscriptionId, subscription);\n\n    if (options?.onConnectionStateChange) {\n      this.connectionStateCallbacks.add(options.onConnectionStateChange);\n    }\n\n    return subscription;\n  }\n\n  /**\n   * Unsubscribe from a specific task\n   */\n  async unsubscribeFromTask(taskId: string): Promise<void> {\n    // Find and remove all subscriptions for this task\n    const toRemove: string[] = [];\n    \n    for (const [id, taskInfo] of this.taskCallbacks) {\n      if (taskInfo.taskId === taskId) {\n        toRemove.push(id);\n      }\n    }\n\n    toRemove.forEach(id => this.unsubscribe(id));\n    \n    // Unsubscribe from the task on the server\n    await this.signalRService.unsubscribeFromTask(taskId);\n  }\n\n  /**\n   * Unsubscribe from all notifications\n   */\n  unsubscribeAll(): void {\n    const subscriptionIds = Array.from(this.subscriptions.keys());\n    subscriptionIds.forEach(id => this.unsubscribe(id));\n    this.connectionStateCallbacks.clear();\n  }\n\n  /**\n   * Get all active subscriptions\n   */\n  getActiveSubscriptions(): NotificationSubscription[] {\n    return Array.from(this.subscriptions.values());\n  }\n\n  /**\n   * Connect to SignalR hubs\n   */\n  async connect(): Promise<void> {\n    await this.signalRService.startAllConnections();\n  }\n\n  /**\n   * Disconnect from SignalR hubs\n   */\n  async disconnect(): Promise<void> {\n    await this.signalRService.stopAllConnections();\n  }\n\n  /**\n   * Check if connected to SignalR hubs\n   */\n  isConnected(): boolean {\n    const states = this.signalRService.getConnectionStatus();\n    return Object.values(states).some(state => state === HubConnectionState.Connected);\n  }\n\n  private unsubscribe(subscriptionId: string): void {\n    this.subscriptions.delete(subscriptionId);\n    this.videoCallbacks.delete(subscriptionId);\n    this.imageCallbacks.delete(subscriptionId);\n    this.spendUpdateCallbacks.delete(subscriptionId);\n    this.spendLimitCallbacks.delete(subscriptionId);\n    this.taskCallbacks.delete(subscriptionId);\n    \n    // If no more subscriptions, we could disconnect, but we'll keep connections alive\n    // for better performance in case of new subscriptions\n  }\n\n  private generateSubscriptionId(): string {\n    return `sub_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n}","/**\n * Type-safe metadata interfaces for Core SDK\n */\n\n/**\n * Chat completion metadata\n */\nexport interface ChatMetadata {\n  /** Conversation or session ID */\n  conversationId?: string;\n  /** User ID making the request */\n  userId?: string;\n  /** Application or client name */\n  application?: string;\n  /** Request purpose or context */\n  context?: string;\n  /** Custom tracking ID */\n  trackingId?: string;\n  /** Additional properties */\n  custom?: {\n    [key: string]: string | number | boolean;\n  };\n}\n\n/**\n * Video generation webhook metadata\n */\nexport interface VideoWebhookMetadata {\n  /** Job or task ID */\n  jobId?: string;\n  /** User or customer ID */\n  userId?: string;\n  /** Callback URL for status updates */\n  callbackUrl?: string;\n  /** Custom reference ID */\n  referenceId?: string;\n  /** Priority level */\n  priority?: 'low' | 'normal' | 'high';\n  /** Additional callback data */\n  callbackData?: {\n    [key: string]: string | number | boolean;\n  };\n}\n\n/**\n * Tool/Function call parameters\n */\nexport interface ToolParameters {\n  [key: string]: string | number | boolean | null | ToolParameters | ToolParameters[];\n}\n\n/**\n * Notification metadata\n */\nexport interface NotificationMetadata {\n  /** Notification type */\n  type?: string;\n  /** Source system */\n  source?: string;\n  /** Target user or group */\n  target?: string;\n  /** Priority level */\n  priority?: 'low' | 'normal' | 'high' | 'urgent';\n  /** Expiration time */\n  expiresAt?: string;\n  /** Action URL */\n  actionUrl?: string;\n  /** Custom data */\n  data?: {\n    [key: string]: string | number | boolean;\n  };\n}\n\n/**\n * Type guard to check if a value is valid metadata\n */\nexport function isValidMetadata(value: unknown): value is Record<string, unknown> {\n  return typeof value === 'object' && value !== null && !Array.isArray(value);\n}\n\n/**\n * Safely parse metadata from various sources\n */\nexport function parseMetadata<T extends Record<string, unknown>>(\n  metadata: string | Record<string, unknown> | null | undefined\n): T | undefined {\n  if (!metadata) {\n    return undefined;\n  }\n  \n  // If already an object, return it\n  if (typeof metadata === 'object') {\n    return metadata as T;\n  }\n  \n  // If string, try to parse as JSON\n  if (typeof metadata === 'string') {\n    try {\n      const parsed = JSON.parse(metadata) as unknown;\n      if (isValidMetadata(parsed)) {\n        return parsed as T;\n      }\n    } catch {\n      // Invalid JSON\n    }\n  }\n  \n  return undefined;\n}\n\n/**\n * Convert metadata to string if needed\n */\nexport function stringifyMetadata<T extends Record<string, unknown>>(\n  metadata: T | null | undefined\n): string | undefined {\n  if (!metadata || Object.keys(metadata).length === 0) {\n    return undefined;\n  }\n  \n  try {\n    return JSON.stringify(metadata);\n  } catch {\n    return undefined;\n  }\n}"]}