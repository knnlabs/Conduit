using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using ConduitLLM.Core.Interfaces;
using ConduitLLM.Core.Models;
using Microsoft.Extensions.Logging;

namespace ConduitLLM.Core.Services
{
    /// <summary>
    /// Service for analyzing image generation performance and providing insights.
    /// </summary>
    public class ImageGenerationAnalyticsService : IImageGenerationAnalyticsService
    {
        private readonly ILogger<ImageGenerationAnalyticsService> _logger;
        private readonly IImageGenerationMetricsService _metricsService;
        private readonly IImageGenerationMetricsCollector _metricsCollector;

        public ImageGenerationAnalyticsService(
            ILogger<ImageGenerationAnalyticsService> logger,
            IImageGenerationMetricsService metricsService,
            IImageGenerationMetricsCollector metricsCollector)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            _metricsService = metricsService ?? throw new ArgumentNullException(nameof(metricsService));
            _metricsCollector = metricsCollector ?? throw new ArgumentNullException(nameof(metricsCollector));
        }

        public async Task<ImageGenerationAnalyticsReport> GetAnalyticsReportAsync(
            DateTime startTime,
            DateTime endTime,
            CancellationToken cancellationToken = default)
        {
            var report = new ImageGenerationAnalyticsReport
            {
                StartTime = startTime,
                EndTime = endTime
            };

            // Get all provider stats for the period
            var allProviderStats = await _metricsService.GetAllProviderStatsAsync(
                (int)(endTime - startTime).TotalMinutes, cancellationToken);

            // Build executive summary
            report.Summary = BuildExecutiveSummary(allProviderStats);

            // Build performance metrics
            report.Performance = BuildPerformanceMetrics(allProviderStats);

            // Build cost metrics
            report.Cost = BuildCostMetrics(allProviderStats);

            // Build usage metrics
            report.Usage = BuildUsageMetrics(allProviderStats);

            // Build quality metrics
            report.Quality = BuildQualityMetrics(allProviderStats);

            // Generate key insights
            report.KeyInsights = GenerateKeyInsights(allProviderStats);

            return report;
        }

        public async Task<ProviderComparisonReport> GetProviderComparisonAsync(
            int timeWindowHours = 24,
            CancellationToken cancellationToken = default)
        {
            var report = new ProviderComparisonReport
            {
                GeneratedAt = DateTime.UtcNow,
                TimeWindowHours = timeWindowHours
            };

            var allProviderStats = await _metricsService.GetAllProviderStatsAsync(
                timeWindowHours * 60, cancellationToken);

            foreach (var providerStats in allProviderStats)
            {
                var comparison = new ProviderComparison
                {
                    ProviderName = providerStats.Provider,
                    Metrics = providerStats
                };

                // Calculate scores
                comparison.PerformanceScore = CalculatePerformanceScore(providerStats);
                comparison.ReliabilityScore = CalculateReliabilityScore(providerStats);
                comparison.CostEfficiencyScore = CalculateCostEfficiencyScore(providerStats);
                comparison.OverallScore = (comparison.PerformanceScore + 
                                          comparison.ReliabilityScore + 
                                          comparison.CostEfficiencyScore) / 3;

                // Identify strengths and weaknesses
                IdentifyStrengthsAndWeaknesses(comparison, providerStats);

                report.Providers.Add(comparison);
            }

            // Identify best providers
            report.BestPerformanceProvider = report.Providers
                .OrderByDescending(p => p.PerformanceScore)
                .FirstOrDefault()?.ProviderName ?? "None";

            report.BestCostEfficiencyProvider = report.Providers
                .OrderByDescending(p => p.CostEfficiencyScore)
                .FirstOrDefault()?.ProviderName ?? "None";

            report.MostReliableProvider = report.Providers
                .OrderByDescending(p => p.ReliabilityScore)
                .FirstOrDefault()?.ProviderName ?? "None";

            // Generate recommendations
            report.Recommendations = GenerateProviderRecommendations(report.Providers);

            return report;
        }

        public async Task<CostOptimizationReport> GetCostOptimizationRecommendationsAsync(
            int timeWindowDays = 7,
            CancellationToken cancellationToken = default)
        {
            var report = new CostOptimizationReport
            {
                GeneratedAt = DateTime.UtcNow
            };

            var allProviderStats = await _metricsService.GetAllProviderStatsAsync(
                timeWindowDays * 24 * 60, cancellationToken);

            // Calculate current monthly cost projection
            var totalCost = allProviderStats.Sum(p => p.Cost);
            var dailyCost = totalCost / timeWindowDays;
            report.CurrentMonthlyCost = dailyCost * 30;

            // Identify optimization opportunities
            report.Opportunities = new List<CostOptimizationOpportunity>();

            // Check for provider optimization
            var providerCosts = allProviderStats.ToDictionary(p => p.Provider, p => p.AverageCostPerImage);
            if (providerCosts.Any())
            {
                var cheapestProvider = providerCosts.OrderBy(p => p.Value).First();
                var mostExpensiveProvider = providerCosts.OrderByDescending(p => p.Value).First();

                if (mostExpensiveProvider.Value > cheapestProvider.Value * 1.5m)
                {
                    var potentialSavings = (mostExpensiveProvider.Value - cheapestProvider.Value) * 
                                         allProviderStats.First(p => p.Provider == mostExpensiveProvider.Key).ImageCount;

                    report.Opportunities.Add(new CostOptimizationOpportunity
                    {
                        Title = "Provider Cost Optimization",
                        Description = $"Switch from {mostExpensiveProvider.Key} to {cheapestProvider.Key} for suitable workloads",
                        PotentialSavings = potentialSavings * 30 / timeWindowDays, // Monthly projection
                        Implementation = "Update provider selection logic to prefer cost-efficient providers",
                        Impact = OpportunityImpact.High,
                        Effort = OpportunityEffort.Low
                    });
                }
            }

            // Check for model optimization
            var modelCosts = allProviderStats
                .SelectMany(p => p.ModelBreakdown.Values)
                .GroupBy(m => m.ModelName)
                .ToDictionary(g => g.Key, g => g.Average(m => m.TotalCost / Math.Max(1, m.TotalImages)));

            // Calculate potential savings
            report.PotentialSavings = report.Opportunities.Sum(o => o.PotentialSavings);
            report.SavingsPercentage = report.CurrentMonthlyCost > 0 
                ? (double)(report.PotentialSavings / report.CurrentMonthlyCost) * 100 
                : 0;

            // Detect anomalies
            report.Anomalies = DetectCostAnomalies(allProviderStats, timeWindowDays);

            return report;
        }

        public async Task<UsageTrendReport> GetUsageTrendsAsync(
            TimeGranularity granularity,
            int periods = 30,
            CancellationToken cancellationToken = default)
        {
            var report = new UsageTrendReport
            {
                GeneratedAt = DateTime.UtcNow,
                Granularity = granularity
            };

            // For now, generate sample trend data
            // In a real implementation, this would query historical data
            report.TrendData = GenerateSampleTrendData(granularity, periods);

            // Analyze trends
            report.Analysis = AnalyzeTrends(report.TrendData);

            // Generate forecast
            report.Forecast = GenerateUsageForecast(report.TrendData, 30);

            return await Task.FromResult(report);
        }

        public async Task<ErrorAnalysisReport> GetErrorAnalysisAsync(
            int timeWindowHours = 24,
            CancellationToken cancellationToken = default)
        {
            var report = new ErrorAnalysisReport
            {
                GeneratedAt = DateTime.UtcNow
            };

            var allProviderStats = await _metricsService.GetAllProviderStatsAsync(
                timeWindowHours * 60, cancellationToken);

            // Calculate total errors
            report.TotalErrors = allProviderStats.Sum(p => p.FailedRequests);
            var totalRequests = allProviderStats.Sum(p => p.TotalRequests);
            report.ErrorRate = totalRequests > 0 ? (double)report.TotalErrors / totalRequests * 100 : 0;

            // Analyze error patterns
            report.ErrorPatterns = new Dictionary<string, ErrorPattern>();
            
            foreach (var providerStats in allProviderStats)
            {
                foreach (var error in providerStats.ErrorBreakdown)
                {
                    if (!report.ErrorPatterns.ContainsKey(error.Key))
                    {
                        report.ErrorPatterns[error.Key] = new ErrorPattern
                        {
                            ErrorType = error.Key,
                            Occurrences = 0,
                            AffectedProviders = new List<string>()
                        };
                    }

                    var pattern = report.ErrorPatterns[error.Key];
                    pattern.Occurrences += error.Value;
                    pattern.AffectedProviders.Add(providerStats.Provider);
                    pattern.IsRetryable = IsRetryableError(error.Key);
                }
            }

            // Calculate error frequencies
            foreach (var pattern in report.ErrorPatterns.Values)
            {
                pattern.Frequency = report.TotalErrors > 0 
                    ? (double)pattern.Occurrences / report.TotalErrors * 100 
                    : 0;
            }

            // Identify correlations
            report.Correlations = IdentifyErrorCorrelations(report.ErrorPatterns, allProviderStats);

            // Root cause analysis
            report.RootCauseAnalysis = PerformRootCauseAnalysis(report.ErrorPatterns, report.Correlations);

            return report;
        }

        public async Task<CapacityPlanningReport> GetCapacityPlanningInsightsAsync(
            int forecastDays = 30,
            CancellationToken cancellationToken = default)
        {
            var report = new CapacityPlanningReport
            {
                GeneratedAt = DateTime.UtcNow
            };

            // Get current metrics
            var currentMetrics = await _metricsCollector.GetMetricsSnapshotAsync(cancellationToken);

            // Build current capacity metrics
            report.CurrentCapacity = new CapacityMetrics
            {
                PeakRequestsPerMinute = currentMetrics.GenerationsPerMinute * 1.5, // Estimate peak
                AverageRequestsPerMinute = currentMetrics.GenerationsPerMinute,
                CapacityUtilization = EstimateCapacityUtilization(currentMetrics),
                MaxConcurrentGenerations = currentMetrics.ActiveGenerations * 2, // Estimate max
                ResourceUtilization = new Dictionary<string, double>
                {
                    ["CPU"] = currentMetrics.ResourceMetrics.CpuUsagePercent,
                    ["Memory"] = currentMetrics.ResourceMetrics.MemoryUsagePercent,
                    ["Queue"] = currentMetrics.QueueMetrics.TotalDepth > 100 ? 80.0 : currentMetrics.QueueMetrics.TotalDepth
                }
            };

            // Generate forecast
            report.Forecast = GenerateCapacityForecast(report.CurrentCapacity, forecastDays);

            // Generate recommendations
            report.Recommendations = GenerateCapacityRecommendations(report.CurrentCapacity, report.Forecast);

            // Build provider capacities
            report.ProviderCapacities = new Dictionary<string, ProviderCapacity>();
            foreach (var provider in currentMetrics.ProviderStatuses)
            {
                report.ProviderCapacities[provider.Key] = new ProviderCapacity
                {
                    ProviderName = provider.Key,
                    RateLimitPerMinute = GetProviderRateLimit(provider.Key),
                    CurrentUtilization = provider.Value.ActiveRequests * 100.0 / GetProviderRateLimit(provider.Key),
                    AvailableCapacity = Math.Max(0, GetProviderRateLimit(provider.Key) - provider.Value.ActiveRequests),
                    IsAtCapacity = provider.Value.ActiveRequests >= GetProviderRateLimit(provider.Key) * 0.9
                };
            }

            return report;
        }

        public async Task<VirtualKeyUsageReport> GetVirtualKeyUsageAnalyticsAsync(
            int? virtualKeyId = null,
            int timeWindowDays = 30,
            CancellationToken cancellationToken = default)
        {
            var report = new VirtualKeyUsageReport
            {
                GeneratedAt = DateTime.UtcNow
            };

            // This would typically query virtual key usage data
            // For now, returning a basic implementation
            report.KeyUsages = new List<VirtualKeyUsage>();
            report.UsageTrends = new Dictionary<int, UsageTrend>();
            report.BudgetAlerts = new List<BudgetAlert>();

            return await Task.FromResult(report);
        }

        public async Task<AnomalyDetectionReport> DetectPerformanceAnomaliesAsync(
            int timeWindowHours = 24,
            CancellationToken cancellationToken = default)
        {
            var report = new AnomalyDetectionReport
            {
                GeneratedAt = DateTime.UtcNow
            };

            var currentMetrics = await _metricsCollector.GetMetricsSnapshotAsync(cancellationToken);
            var allProviderStats = await _metricsService.GetAllProviderStatsAsync(
                timeWindowHours * 60, cancellationToken);

            report.Anomalies = new List<PerformanceAnomaly>();

            // Check for response time anomalies
            if (currentMetrics.P95ResponseTimeMs > 60000) // Over 60 seconds
            {
                report.Anomalies.Add(new PerformanceAnomaly
                {
                    DetectedAt = DateTime.UtcNow,
                    Type = "HighResponseTime",
                    Description = "P95 response time exceeds normal threshold",
                    AnomalyScore = Math.Min(1.0, currentMetrics.P95ResponseTimeMs / 60000),
                    Metrics = new Dictionary<string, object>
                    {
                        ["P95ResponseTime"] = currentMetrics.P95ResponseTimeMs,
                        ["AverageResponseTime"] = currentMetrics.AverageResponseTimeMs
                    }
                });
            }

            // Check for provider anomalies
            foreach (var provider in currentMetrics.ProviderStatuses)
            {
                if (provider.Value.ConsecutiveFailures > 3)
                {
                    report.Anomalies.Add(new PerformanceAnomaly
                    {
                        DetectedAt = DateTime.UtcNow,
                        Type = "ProviderFailures",
                        Description = $"Provider {provider.Key} experiencing consecutive failures",
                        AnomalyScore = Math.Min(1.0, provider.Value.ConsecutiveFailures / 10.0),
                        Metrics = new Dictionary<string, object>
                        {
                            ["Provider"] = provider.Key,
                            ["ConsecutiveFailures"] = provider.Value.ConsecutiveFailures,
                            ["LastError"] = provider.Value.LastError ?? "Unknown"
                        },
                        PossibleCause = "Provider service degradation or API issues"
                    });
                }
            }

            // Build summary
            report.Summary = new AnomalySummary
            {
                TotalAnomalies = report.Anomalies.Count,
                CriticalAnomalies = report.Anomalies.Count(a => a.AnomalyScore > 0.8),
                SystemStability = 1.0 - (report.Anomalies.Any() ? report.Anomalies.Average(a => a.AnomalyScore) : 0),
                RecommendedActions = GenerateAnomalyRecommendations(report.Anomalies)
            };

            report.AffectedProviders = report.Anomalies
                .Where(a => a.Metrics.ContainsKey("Provider"))
                .Select(a => a.Metrics["Provider"].ToString()!)
                .Distinct()
                .ToList();

            return report;
        }

        #region Private Methods

        private ExecutiveSummary BuildExecutiveSummary(IReadOnlyList<ImageGenerationProviderStats> stats)
        {
            var summary = new ExecutiveSummary
            {
                TotalGenerations = stats.Sum(s => s.TotalRequests),
                TotalImages = stats.Sum(s => s.ImageCount),
                TotalCost = stats.Sum(s => s.Cost),
                OverallSuccessRate = stats.Any() ? stats.Average(s => s.SuccessRate) : 0,
                AverageResponseTime = stats.Any() ? stats.Average(s => s.AverageResponseTime) : 0
            };

            summary.TopProviders = stats
                .OrderByDescending(s => s.TotalRequests)
                .Take(3)
                .ToDictionary(s => s.Provider, s => s.TotalRequests);

            // Identify critical issues
            if (summary.OverallSuccessRate < 95)
            {
                summary.CriticalIssues.Add($"Low success rate: {summary.OverallSuccessRate:F1}%");
            }

            if (summary.AverageResponseTime > 45000)
            {
                summary.CriticalIssues.Add($"High average response time: {summary.AverageResponseTime:F0}ms");
            }

            return summary;
        }

        private ImageGenerationPerformanceMetrics BuildPerformanceMetrics(IReadOnlyList<ImageGenerationProviderStats> stats)
        {
            var metrics = new ImageGenerationPerformanceMetrics();

            if (stats.Any())
            {
                metrics.AverageResponseTimeMs = stats.Average(s => s.AverageResponseTime);
                metrics.P50ResponseTimeMs = stats.Average(s => s.P50ResponseTime);
                metrics.P95ResponseTimeMs = stats.Average(s => s.P95ResponseTime);
                metrics.P99ResponseTimeMs = stats.Average(s => s.P99ResponseTime);

                metrics.ResponseTimeByProvider = stats.ToDictionary(
                    s => s.Provider,
                    s => s.AverageResponseTime);

                metrics.SuccessRateByProvider = stats.ToDictionary(
                    s => s.Provider,
                    s => s.SuccessRate);
            }

            return metrics;
        }

        private CostMetrics BuildCostMetrics(IReadOnlyList<ImageGenerationProviderStats> stats)
        {
            var metrics = new CostMetrics
            {
                TotalCost = stats.Sum(s => s.Cost),
                CostByProvider = stats.ToDictionary(s => s.Provider, s => s.Cost)
            };

            var totalImages = stats.Sum(s => s.ImageCount);
            metrics.AverageCostPerImage = totalImages > 0 ? metrics.TotalCost / totalImages : 0;

            // Build cost by model
            metrics.CostByModel = stats
                .SelectMany(s => s.ModelBreakdown.Values)
                .GroupBy(m => m.ModelName)
                .ToDictionary(g => g.Key, g => g.Sum(m => m.TotalCost));

            return metrics;
        }

        private UsageMetrics BuildUsageMetrics(IReadOnlyList<ImageGenerationProviderStats> stats)
        {
            return new UsageMetrics
            {
                TotalRequests = stats.Sum(s => s.TotalRequests),
                TotalImages = stats.Sum(s => s.ImageCount),
                RequestsByProvider = stats.ToDictionary(s => s.Provider, s => s.TotalRequests)
            };
        }

        private ImageGenerationQualityMetrics BuildQualityMetrics(IReadOnlyList<ImageGenerationProviderStats> stats)
        {
            var metrics = new ImageGenerationQualityMetrics
            {
                OverallSuccessRate = stats.Any() ? stats.Average(s => s.SuccessRate) : 0
            };

            // Aggregate error counts
            metrics.ErrorCountByType = stats
                .SelectMany(s => s.ErrorBreakdown)
                .GroupBy(e => e.Key)
                .ToDictionary(g => g.Key, g => g.Sum(e => e.Value));

            // Calculate SLA compliance (assuming 99.9% availability target)
            metrics.SlaCompliancePercent = metrics.OverallSuccessRate >= 99.9 ? 100 : metrics.OverallSuccessRate;

            return metrics;
        }

        private List<KeyInsight> GenerateKeyInsights(IReadOnlyList<ImageGenerationProviderStats> stats)
        {
            var insights = new List<KeyInsight>();

            // Check for poor performing providers
            var poorProviders = stats.Where(s => s.SuccessRate < 95).ToList();
            if (poorProviders.Any())
            {
                insights.Add(new KeyInsight
                {
                    Type = "Performance",
                    Title = "Provider Performance Issues",
                    Description = $"{poorProviders.Count} provider(s) have success rates below 95%",
                    Severity = InsightSeverity.Warning,
                    Recommendation = "Consider disabling or investigating these providers",
                    Data = new Dictionary<string, object>
                    {
                        ["Providers"] = poorProviders.Select(p => p.Provider).ToList()
                    }
                });
            }

            // Check for cost optimization opportunities
            if (stats.Count > 1)
            {
                var costVariance = stats.Max(s => s.AverageCostPerImage) - stats.Min(s => s.AverageCostPerImage);
                if (costVariance > stats.Average(s => s.AverageCostPerImage) * 0.5m)
                {
                    insights.Add(new KeyInsight
                    {
                        Type = "Cost",
                        Title = "Significant Cost Variance Between Providers",
                        Description = "Large cost differences detected between providers",
                        Severity = InsightSeverity.Opportunity,
                        Recommendation = "Optimize provider selection to reduce costs"
                    });
                }
            }

            return insights;
        }

        private double CalculatePerformanceScore(ImageGenerationProviderStats stats)
        {
            // Lower response time = higher score
            var responseScore = Math.Max(0, 1 - (stats.AverageResponseTime / 60000)); // 60s baseline
            return responseScore;
        }

        private double CalculateReliabilityScore(ImageGenerationProviderStats stats)
        {
            return stats.SuccessRate / 100;
        }

        private double CalculateCostEfficiencyScore(ImageGenerationProviderStats stats)
        {
            // Lower cost = higher score
            var baseCost = 0.05m; // $0.05 baseline
            return Math.Max(0, 1 - ((double)(stats.AverageCostPerImage / baseCost) - 1));
        }

        private void IdentifyStrengthsAndWeaknesses(ProviderComparison comparison, ImageGenerationProviderStats stats)
        {
            if (comparison.PerformanceScore > 0.8)
                comparison.Strengths.Add("Fast response times");
            else if (comparison.PerformanceScore < 0.5)
                comparison.Weaknesses.Add("Slow response times");

            if (comparison.ReliabilityScore > 0.98)
                comparison.Strengths.Add("Excellent reliability");
            else if (comparison.ReliabilityScore < 0.95)
                comparison.Weaknesses.Add("Below target reliability");

            if (comparison.CostEfficiencyScore > 0.8)
                comparison.Strengths.Add("Cost-effective");
            else if (comparison.CostEfficiencyScore < 0.5)
                comparison.Weaknesses.Add("High cost per image");
        }

        private List<ProviderRecommendation> GenerateProviderRecommendations(List<ProviderComparison> providers)
        {
            var recommendations = new List<ProviderRecommendation>();

            foreach (var provider in providers)
            {
                if (provider.ReliabilityScore < 0.95)
                {
                    recommendations.Add(new ProviderRecommendation
                    {
                        Provider = provider.ProviderName,
                        Action = "Investigate reliability issues",
                        Reason = $"Success rate below 95% ({provider.ReliabilityScore * 100:F1}%)",
                        ExpectedImprovement = (0.95 - provider.ReliabilityScore) * 100
                    });
                }

                if (provider.PerformanceScore < 0.5)
                {
                    recommendations.Add(new ProviderRecommendation
                    {
                        Provider = provider.ProviderName,
                        Action = "Optimize or reduce usage",
                        Reason = "Response times significantly above baseline",
                        ExpectedImprovement = 30
                    });
                }
            }

            return recommendations;
        }

        private List<CostAnomaly> DetectCostAnomalies(IReadOnlyList<ImageGenerationProviderStats> stats, int days)
        {
            var anomalies = new List<CostAnomaly>();

            // Simple anomaly detection - would be more sophisticated in production
            foreach (var provider in stats)
            {
                if (provider.AverageCostPerImage > 0.10m) // $0.10 threshold
                {
                    anomalies.Add(new CostAnomaly
                    {
                        DetectedAt = DateTime.UtcNow,
                        Type = "HighCostPerImage",
                        Description = $"Provider {provider.Provider} has unusually high cost per image",
                        AnomalousAmount = provider.AverageCostPerImage,
                        ExpectedAmount = 0.05m,
                        DeviationPercent = ((double)provider.AverageCostPerImage / 0.05 - 1) * 100
                    });
                }
            }

            return anomalies;
        }

        private List<UsageTrendPoint> GenerateSampleTrendData(TimeGranularity granularity, int periods)
        {
            var trends = new List<UsageTrendPoint>();
            var now = DateTime.UtcNow;
            var random = new Random();

            for (int i = periods - 1; i >= 0; i--)
            {
                var timestamp = granularity switch
                {
                    TimeGranularity.Hourly => now.AddHours(-i),
                    TimeGranularity.Daily => now.AddDays(-i),
                    TimeGranularity.Weekly => now.AddDays(-i * 7),
                    TimeGranularity.Monthly => now.AddMonths(-i),
                    _ => now.AddDays(-i)
                };

                trends.Add(new UsageTrendPoint
                {
                    Timestamp = timestamp,
                    Requests = random.Next(50, 200) + i * 2, // Simulating growth
                    Images = random.Next(100, 400) + i * 3,
                    Cost = (decimal)(random.Next(50, 150) + i * 1.5),
                    SuccessRate = 95 + random.NextDouble() * 4,
                    AverageResponseTime = 10000 + random.Next(-2000, 2000)
                });
            }

            return trends;
        }

        private TrendAnalysis AnalyzeTrends(List<UsageTrendPoint> trendData)
        {
            var analysis = new TrendAnalysis();

            if (trendData.Count < 2) return analysis;

            // Simple trend detection
            var firstHalf = trendData.Take(trendData.Count / 2).Average(t => t.Requests);
            var secondHalf = trendData.Skip(trendData.Count / 2).Average(t => t.Requests);

            if (secondHalf > firstHalf * 1.1)
                analysis.OverallTrend = ImageGenerationTrendDirection.Increasing;
            else if (secondHalf < firstHalf * 0.9)
                analysis.OverallTrend = ImageGenerationTrendDirection.Decreasing;
            else
                analysis.OverallTrend = ImageGenerationTrendDirection.Stable;

            analysis.GrowthRate = firstHalf > 0 ? ((secondHalf - firstHalf) / firstHalf) * 100 : 0;

            return analysis;
        }

        private UsageForecast GenerateUsageForecast(List<UsageTrendPoint> trendData, int forecastDays)
        {
            var forecast = new UsageForecast
            {
                ForecastDays = forecastDays,
                ConfidenceLevel = 0.8
            };

            if (trendData.Any())
            {
                var avgDailyRequests = trendData.Average(t => t.Requests);
                var avgDailyCost = trendData.Average(t => t.Cost);

                forecast.ProjectedRequests = (int)(avgDailyRequests * forecastDays);
                forecast.ProjectedCost = avgDailyCost * forecastDays;
            }

            return forecast;
        }

        private bool IsRetryableError(string errorType)
        {
            return errorType.ToLowerInvariant() switch
            {
                "timeout" => true,
                "network" => true,
                "ratelimit" => true,
                _ => false
            };
        }

        private List<ErrorCorrelation> IdentifyErrorCorrelations(
            Dictionary<string, ErrorPattern> errorPatterns,
            IReadOnlyList<ImageGenerationProviderStats> stats)
        {
            var correlations = new List<ErrorCorrelation>();

            // Check for provider-specific correlations
            var providerErrors = errorPatterns.Values
                .Where(p => p.AffectedProviders.Distinct().Count() == 1)
                .ToList();

            if (providerErrors.Any())
            {
                correlations.Add(new ErrorCorrelation
                {
                    Factor = "Provider-Specific",
                    CorrelationStrength = providerErrors.Count / (double)errorPatterns.Count,
                    Description = "Some errors are specific to certain providers"
                });
            }

            return correlations;
        }

        private List<string> PerformRootCauseAnalysis(
            Dictionary<string, ErrorPattern> errorPatterns,
            List<ErrorCorrelation> correlations)
        {
            var rootCauses = new List<string>();

            // Check for authentication issues
            if (errorPatterns.ContainsKey("Authentication"))
            {
                rootCauses.Add("Authentication failures detected - check API key validity");
            }

            // Check for rate limiting
            if (errorPatterns.ContainsKey("RateLimit"))
            {
                rootCauses.Add("Rate limiting issues - consider implementing backoff or adding providers");
            }

            // Check for network issues
            if (errorPatterns.ContainsKey("Network") || errorPatterns.ContainsKey("Timeout"))
            {
                rootCauses.Add("Network connectivity issues - check provider endpoints and timeout settings");
            }

            return rootCauses;
        }

        private double EstimateCapacityUtilization(ImageGenerationMetricsSnapshot metrics)
        {
            // Simple estimation based on queue depth and active generations
            var queueUtilization = Math.Min(100, metrics.QueueMetrics.TotalDepth);
            var generationUtilization = Math.Min(100, metrics.ActiveGenerations * 10); // Assume 10 is high
            
            return (queueUtilization + generationUtilization) / 2;
        }

        private CapacityForecast GenerateCapacityForecast(CapacityMetrics current, int forecastDays)
        {
            var forecast = new CapacityForecast
            {
                Projections = new List<CapacityProjection>()
            };

            // Simple linear projection
            var growthRate = 0.02; // 2% daily growth assumption
            
            for (int day = 1; day <= forecastDays; day++)
            {
                var expectedLoad = current.AverageRequestsPerMinute * Math.Pow(1 + growthRate, day);
                var utilization = (expectedLoad / current.PeakRequestsPerMinute) * 100;
                
                forecast.Projections.Add(new CapacityProjection
                {
                    Date = DateTime.UtcNow.AddDays(day),
                    ExpectedLoad = expectedLoad,
                    CapacityUtilization = utilization,
                    ExceedsCapacity = utilization > 90
                });
            }

            var capacityExceeded = forecast.Projections.FirstOrDefault(p => p.ExceedsCapacity);
            if (capacityExceeded != null)
            {
                forecast.ProjectedCapacityLimit = capacityExceeded.Date;
            }

            return forecast;
        }

        private List<CapacityRecommendation> GenerateCapacityRecommendations(
            CapacityMetrics current,
            CapacityForecast forecast)
        {
            var recommendations = new List<CapacityRecommendation>();

            if (current.CapacityUtilization > 80)
            {
                recommendations.Add(new CapacityRecommendation
                {
                    Title = "High Capacity Utilization",
                    Description = "System is operating at over 80% capacity",
                    Action = CapacityAction.ScaleUp,
                    RecommendedBy = DateTime.UtcNow.AddDays(7),
                    Justification = "Prevent performance degradation during peak loads"
                });
            }

            if (forecast.ProjectedCapacityLimit < DateTime.UtcNow.AddDays(30))
            {
                recommendations.Add(new CapacityRecommendation
                {
                    Title = "Capacity Limit Approaching",
                    Description = $"System will reach capacity limit by {forecast.ProjectedCapacityLimit:yyyy-MM-dd}",
                    Action = CapacityAction.AddProvider,
                    RecommendedBy = forecast.ProjectedCapacityLimit.AddDays(-7),
                    Justification = "Maintain service availability"
                });
            }

            return recommendations;
        }

        private int GetProviderRateLimit(string provider)
        {
            // Default rate limits per minute
            return provider.ToLowerInvariant() switch
            {
                "openai" => 50,
                "minimax" => 30,
                "replicate" => 20,
                _ => 10
            };
        }

        private List<string> GenerateAnomalyRecommendations(List<PerformanceAnomaly> anomalies)
        {
            var recommendations = new List<string>();

            if (anomalies.Any(a => a.Type == "HighResponseTime"))
            {
                recommendations.Add("Investigate slow providers and consider failover");
            }

            if (anomalies.Any(a => a.Type == "ProviderFailures"))
            {
                recommendations.Add("Check provider API status and credentials");
                recommendations.Add("Enable circuit breakers for failing providers");
            }

            return recommendations;
        }

        #endregion
    }
}