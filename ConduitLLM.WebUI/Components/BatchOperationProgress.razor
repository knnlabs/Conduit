@using System.Text.Json
@using ConduitLLM.WebUI.Services
@inject ServerSideSignalRService SignalRService
@inject ILogger<BatchOperationProgress> Logger
@implements IServerSideSignalRListener
@implements IDisposable

<div class="batch-operation-progress @(IsMinimized ? "minimized" : "")">
    <div class="progress-header" @onclick="ToggleMinimize">
        <div class="header-content">
            <i class="@GetOperationIcon()"></i>
            <span class="operation-type">@GetOperationTypeDisplay()</span>
            <span class="operation-id">@OperationId.Substring(0, 8)...</span>
        </div>
        <div class="header-actions">
            @if (CanCancel && !IsCompleted)
            {
                <button class="cancel-btn" @onclick="CancelOperation" @onclick:stopPropagation="true">
                    <i class="fa fa-times"></i>
                </button>
            }
            <button class="minimize-btn" @onclick:stopPropagation="true">
                <i class="fa @(IsMinimized ? "fa-chevron-up" : "fa-chevron-down")"></i>
            </button>
        </div>
    </div>

    @if (!IsMinimized)
    {
        <div class="progress-body">
            <!-- Progress Bar -->
            <div class="progress-bar-container">
                <div class="progress-bar">
                    <div class="progress-fill @GetProgressClass()" style="width: @Progress%">
                        @if (Progress > 10)
                        {
                            <span class="progress-text">@Progress%</span>
                        }
                    </div>
                </div>
                @if (Progress <= 10)
                {
                    <span class="progress-text-outside">@Progress%</span>
                }
            </div>

            <!-- Stats Grid -->
            <div class="stats-grid">
                <div class="stat">
                    <label>Status</label>
                    <span class="@GetStatusClass()">@Status</span>
                </div>
                <div class="stat">
                    <label>Processed</label>
                    <span>@ProcessedCount / @TotalItems</span>
                </div>
                <div class="stat">
                    <label>Success</label>
                    <span class="success">@SuccessCount</span>
                </div>
                <div class="stat">
                    <label>Failed</label>
                    <span class="@(FailedCount > 0 ? "error" : "")">@FailedCount</span>
                </div>
            </div>

            <!-- Performance Metrics -->
            @if (Status == "Running" && ItemsPerSecond > 0)
            {
                <div class="performance-metrics">
                    <div class="metric">
                        <i class="fa fa-tachometer-alt"></i>
                        <span>@ItemsPerSecond.ToString("F1") items/sec</span>
                    </div>
                    <div class="metric">
                        <i class="fa fa-clock"></i>
                        <span>ETA: @FormatTimeSpan(EstimatedTimeRemaining)</span>
                    </div>
                    <div class="metric">
                        <i class="fa fa-hourglass-half"></i>
                        <span>Elapsed: @FormatTimeSpan(ElapsedTime)</span>
                    </div>
                </div>
            }

            <!-- Current Item -->
            @if (!string.IsNullOrEmpty(CurrentItem))
            {
                <div class="current-item">
                    <label>Processing:</label>
                    <span>@CurrentItem</span>
                </div>
            }

            <!-- Error Summary -->
            @if (FailedCount > 0 && Errors.Any())
            {
                <div class="error-summary">
                    <div class="error-header" @onclick="ToggleErrors">
                        <i class="fa fa-exclamation-triangle"></i>
                        <span>@FailedCount Error@(FailedCount != 1 ? "s" : "")</span>
                        <i class="fa @(ShowErrors ? "fa-chevron-up" : "fa-chevron-down")"></i>
                    </div>
                    @if (ShowErrors)
                    {
                        <div class="error-list">
                            @foreach (var error in Errors.Take(5))
                            {
                                <div class="error-item">
                                    <span class="error-entity">@error.EntityId:</span>
                                    <span class="error-message">@error.Message</span>
                                </div>
                            }
                            @if (Errors.Count > 5)
                            {
                                <div class="error-more">
                                    And @(Errors.Count - 5) more errors...
                                </div>
                            }
                        </div>
                    }
                </div>
            }
        </div>
    }
</div>

@code {
    [Parameter] public string OperationId { get; set; } = "";
    [Parameter] public string OperationType { get; set; } = "";
    [Parameter] public EventCallback<string> OnCancel { get; set; }
    [Parameter] public EventCallback<string> OnComplete { get; set; }
    [Parameter] public bool AutoRemoveOnComplete { get; set; } = false;
    [Parameter] public int AutoRemoveDelay { get; set; } = 5000;

    private bool IsMinimized = false;
    private bool ShowErrors = false;
    private bool IsCompleted => Status == "Completed" || Status == "Failed" || Status == "Cancelled";
    private bool CanCancel => Status == "Running" || Status == "Pending";
    
    // Progress tracking
    private string Status = "Pending";
    private int Progress = 0;
    private int TotalItems = 0;
    private int ProcessedCount = 0;
    private int SuccessCount = 0;
    private int FailedCount = 0;
    private double ItemsPerSecond = 0;
    private TimeSpan ElapsedTime = TimeSpan.Zero;
    private TimeSpan EstimatedTimeRemaining = TimeSpan.Zero;
    private string CurrentItem = "";
    private List<BatchError> Errors = new();
    
    private DateTime _startTime;
    private Timer? _autoRemoveTimer;
    private bool _isInitialized = false;
    
    protected override void OnInitialized()
    {
        _startTime = DateTime.UtcNow;
        
        // Register as a SignalR listener
        SignalRService.RegisterListener(this);
        _isInitialized = true;
        
        Logger.LogInformation("BatchOperationProgress initialized for operation {OperationId}", OperationId);
    }
    
    // IServerSideSignalRListener implementation
    public async Task OnConnectionStateChanged(string hubName, ConnectionState state)
    {
        if (hubName == "notifications")
        {
            Logger.LogDebug("Batch operation connection state changed to {State}", state);
        }
    }
    
    public async Task OnBatchOperationProgress(string operationId, JsonElement progress)
    {
        if (operationId != OperationId) return;
        
        try
        {
            Logger.LogDebug("Received batch operation progress for {OperationId}", operationId);
            
            // Update progress metrics
            if (progress.TryGetProperty("status", out var statusElement))
            {
                Status = statusElement.GetString() ?? "Running";
            }
            
            if (progress.TryGetProperty("progress", out var progressElement))
            {
                Progress = progressElement.GetInt32();
            }
            
            if (progress.TryGetProperty("totalItems", out var totalElement))
            {
                TotalItems = totalElement.GetInt32();
            }
            
            if (progress.TryGetProperty("processedCount", out var processedElement))
            {
                ProcessedCount = processedElement.GetInt32();
            }
            
            if (progress.TryGetProperty("successCount", out var successElement))
            {
                SuccessCount = successElement.GetInt32();
            }
            
            if (progress.TryGetProperty("failedCount", out var failedElement))
            {
                FailedCount = failedElement.GetInt32();
            }
            
            if (progress.TryGetProperty("currentItem", out var currentElement))
            {
                CurrentItem = currentElement.GetString() ?? "";
            }
            
            // Calculate performance metrics
            ElapsedTime = DateTime.UtcNow - _startTime;
            if (ProcessedCount > 0 && ElapsedTime.TotalSeconds > 0)
            {
                ItemsPerSecond = ProcessedCount / ElapsedTime.TotalSeconds;
                
                if (ItemsPerSecond > 0 && TotalItems > ProcessedCount)
                {
                    var remainingItems = TotalItems - ProcessedCount;
                    EstimatedTimeRemaining = TimeSpan.FromSeconds(remainingItems / ItemsPerSecond);
                }
            }
            
            // Parse errors if present
            if (progress.TryGetProperty("errors", out var errorsElement))
            {
                Errors.Clear();
                foreach (var errorElement in errorsElement.EnumerateArray())
                {
                    if (errorElement.TryGetProperty("entityId", out var entityIdElement) &&
                        errorElement.TryGetProperty("message", out var messageElement))
                    {
                        Errors.Add(new BatchError
                        {
                            EntityId = entityIdElement.GetString() ?? "",
                            Message = messageElement.GetString() ?? ""
                        });
                    }
                }
            }
            
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error processing batch operation progress");
        }
    }
    
    public async Task OnBatchOperationCompleted(string operationId, JsonElement result)
    {
        if (operationId != OperationId) return;
        
        try
        {
            Logger.LogInformation("Batch operation {OperationId} completed", operationId);
            
            Status = "Completed";
            Progress = 100;
            ProcessedCount = TotalItems;
            
            if (OnComplete.HasDelegate)
            {
                await OnComplete.InvokeAsync(operationId);
            }
            
            if (AutoRemoveOnComplete)
            {
                ScheduleAutoRemove();
            }
            
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error processing batch operation completion");
        }
    }
    
    public async Task OnBatchOperationFailed(string operationId, string error)
    {
        if (operationId != OperationId) return;
        
        try
        {
            Logger.LogError("Batch operation {OperationId} failed: {Error}", operationId, error);
            
            Status = "Failed";
            
            // Add the overall failure as an error
            Errors.Insert(0, new BatchError
            {
                EntityId = "Operation",
                Message = error
            });
            
            if (AutoRemoveOnComplete)
            {
                ScheduleAutoRemove();
            }
            
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error processing batch operation failure");
        }
    }
    
    // Default implementations for other SignalR events
    public Task OnSystemNotificationReceived(JsonElement notification) => Task.CompletedTask;
    public Task OnModelMappingChanged(JsonElement data) => Task.CompletedTask;
    public Task OnProviderHealthChanged(JsonElement data) => Task.CompletedTask;
    public Task OnNavigationStateChanged(JsonElement data) => Task.CompletedTask;
    public Task OnVideoGenerationProgress(string taskId, JsonElement progress) => Task.CompletedTask;
    public Task OnVideoGenerationCompleted(string taskId, JsonElement result) => Task.CompletedTask;
    public Task OnVideoGenerationFailed(string taskId, string error) => Task.CompletedTask;
    public Task OnImageGenerationProgress(string taskId, JsonElement progress) => Task.CompletedTask;
    public Task OnImageGenerationCompleted(string taskId, JsonElement result) => Task.CompletedTask;
    public Task OnImageGenerationFailed(string taskId, string error) => Task.CompletedTask;
    public Task OnSpendUpdate(JsonElement notification) => Task.CompletedTask;
    public Task OnBudgetAlert(JsonElement notification) => Task.CompletedTask;
    public Task OnSpendSummary(JsonElement notification) => Task.CompletedTask;
    public Task OnUnusualSpending(JsonElement notification) => Task.CompletedTask;
    public Task OnNewModelsDiscovered(JsonElement notification) => Task.CompletedTask;
    public Task OnModelCapabilitiesChanged(JsonElement notification) => Task.CompletedTask;
    public Task OnModelPricingUpdated(JsonElement notification) => Task.CompletedTask;
    public Task OnModelDeprecated(JsonElement notification) => Task.CompletedTask;
    public Task OnAdminNotificationReceived(JsonElement notification) => Task.CompletedTask;
    
    private void ToggleMinimize()
    {
        IsMinimized = !IsMinimized;
    }
    
    private void ToggleErrors()
    {
        ShowErrors = !ShowErrors;
    }
    
    private async Task CancelOperation()
    {
        if (OnCancel.HasDelegate)
        {
            await OnCancel.InvokeAsync(OperationId);
        }
        Status = "Cancelled";
    }
    
    private void ScheduleAutoRemove()
    {
        _autoRemoveTimer?.Dispose();
        _autoRemoveTimer = new Timer(_ =>
        {
            // Component should be removed by parent
            InvokeAsync(StateHasChanged);
        }, null, AutoRemoveDelay, Timeout.Infinite);
    }
    
    private string GetOperationIcon() => OperationType switch
    {
        "VirtualKeyUpdate" => "fa fa-key",
        "ModelSync" => "fa fa-sync",
        "BulkDelete" => "fa fa-trash",
        "Export" => "fa fa-download",
        "Import" => "fa fa-upload",
        _ => "fa fa-tasks"
    };
    
    private string GetOperationTypeDisplay() => OperationType switch
    {
        "VirtualKeyUpdate" => "Virtual Key Update",
        "ModelSync" => "Model Synchronization",
        "BulkDelete" => "Bulk Delete",
        "Export" => "Data Export",
        "Import" => "Data Import",
        _ => "Batch Operation"
    };
    
    private string GetProgressClass() => Status switch
    {
        "Completed" => "progress-success",
        "Failed" => "progress-danger",
        "Running" => "progress-primary progress-striped",
        _ => "progress-secondary"
    };
    
    private string GetStatusClass() => Status switch
    {
        "Completed" => "text-success",
        "Failed" => "text-danger",
        "Running" => "text-primary",
        "Cancelled" => "text-warning",
        _ => "text-secondary"
    };
    
    private string FormatTimeSpan(TimeSpan ts)
    {
        if (ts.TotalHours >= 1)
            return $"{ts.Hours}h {ts.Minutes}m";
        if (ts.TotalMinutes >= 1)
            return $"{ts.Minutes}m {ts.Seconds}s";
        return $"{ts.Seconds}s";
    }
    
    public void Dispose()
    {
        if (_isInitialized)
        {
            SignalRService.UnregisterListener(this);
        }
        
        _autoRemoveTimer?.Dispose();
    }
    
    private class BatchError
    {
        public string EntityId { get; set; } = "";
        public string Message { get; set; } = "";
    }
}

<style>
    .batch-operation-progress {
        background: white;
        border: 1px solid #e0e0e0;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        margin-bottom: 1rem;
        transition: all 0.3s ease;
    }
    
    .batch-operation-progress.minimized {
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.05);
    }
    
    .progress-header {
        padding: 1rem;
        border-bottom: 1px solid #e0e0e0;
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: pointer;
        user-select: none;
    }
    
    .batch-operation-progress.minimized .progress-header {
        border-bottom: none;
    }
    
    .header-content {
        display: flex;
        align-items: center;
        gap: 0.75rem;
    }
    
    .operation-type {
        font-weight: 600;
        color: #333;
    }
    
    .operation-id {
        font-family: monospace;
        font-size: 0.875rem;
        color: #666;
    }
    
    .header-actions {
        display: flex;
        gap: 0.5rem;
    }
    
    .cancel-btn,
    .minimize-btn {
        background: none;
        border: 1px solid #ddd;
        padding: 0.25rem 0.5rem;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s;
        color: #666;
    }
    
    .cancel-btn:hover {
        background: #fee;
        border-color: #f88;
        color: #c00;
    }
    
    .minimize-btn:hover {
        background: #f5f5f5;
        border-color: #ccc;
    }
    
    .progress-body {
        padding: 1rem;
    }
    
    .progress-bar-container {
        position: relative;
        margin-bottom: 1.5rem;
    }
    
    .progress-bar {
        height: 24px;
        background: #f0f0f0;
        border-radius: 12px;
        overflow: hidden;
        position: relative;
    }
    
    .progress-fill {
        height: 100%;
        transition: width 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: 600;
        font-size: 0.875rem;
    }
    
    .progress-primary {
        background: #007bff;
    }
    
    .progress-success {
        background: #28a745;
    }
    
    .progress-danger {
        background: #dc3545;
    }
    
    .progress-secondary {
        background: #6c757d;
    }
    
    .progress-striped {
        background-image: linear-gradient(
            45deg,
            rgba(255, 255, 255, 0.15) 25%,
            transparent 25%,
            transparent 50%,
            rgba(255, 255, 255, 0.15) 50%,
            rgba(255, 255, 255, 0.15) 75%,
            transparent 75%,
            transparent
        );
        background-size: 1rem 1rem;
        animation: progress-bar-stripes 1s linear infinite;
    }
    
    @@keyframes progress-bar-stripes {
        from { background-position: 1rem 0; }
        to { background-position: 0 0; }
    }
    
    .progress-text-outside {
        position: absolute;
        left: 1rem;
        top: 50%;
        transform: translateY(-50%);
        font-weight: 600;
        font-size: 0.875rem;
        color: #333;
    }
    
    .stats-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 1rem;
        margin-bottom: 1rem;
    }
    
    .stat {
        text-align: center;
    }
    
    .stat label {
        display: block;
        font-size: 0.75rem;
        color: #666;
        margin-bottom: 0.25rem;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }
    
    .stat span {
        font-size: 1.25rem;
        font-weight: 600;
        color: #333;
    }
    
    .stat .success {
        color: #28a745;
    }
    
    .stat .error {
        color: #dc3545;
    }
    
    .performance-metrics {
        display: flex;
        gap: 2rem;
        padding: 1rem;
        background: #f8f9fa;
        border-radius: 6px;
        margin-bottom: 1rem;
    }
    
    .metric {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.875rem;
        color: #666;
    }
    
    .metric i {
        color: #999;
    }
    
    .current-item {
        padding: 0.75rem;
        background: #e8f4f8;
        border-radius: 6px;
        margin-bottom: 1rem;
        font-size: 0.875rem;
    }
    
    .current-item label {
        font-weight: 600;
        margin-right: 0.5rem;
        color: #0066cc;
    }
    
    .error-summary {
        background: #fee;
        border: 1px solid #fcc;
        border-radius: 6px;
        overflow: hidden;
    }
    
    .error-header {
        padding: 0.75rem 1rem;
        background: #fdd;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        cursor: pointer;
        user-select: none;
    }
    
    .error-header i:first-child {
        color: #c00;
    }
    
    .error-header span {
        flex-grow: 1;
        font-weight: 600;
        color: #c00;
    }
    
    .error-list {
        padding: 1rem;
        max-height: 200px;
        overflow-y: auto;
    }
    
    .error-item {
        margin-bottom: 0.5rem;
        font-size: 0.875rem;
    }
    
    .error-entity {
        font-weight: 600;
        color: #666;
        margin-right: 0.5rem;
    }
    
    .error-message {
        color: #333;
    }
    
    .error-more {
        margin-top: 0.5rem;
        font-size: 0.875rem;
        color: #666;
        font-style: italic;
    }
</style>