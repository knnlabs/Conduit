@page "/virtualkeys/edit/{id?}"
@using Microsoft.EntityFrameworkCore
@using Microsoft.AspNetCore.Authorization
@using Microsoft.Extensions.Logging
@using ConduitLLM.WebUI.Services
@using ConduitLLM.WebUI.Components
@using ConduitLLM.Configuration
@using ConduitLLM.Configuration.Entities
@using ConduitLLM.Configuration.DTOs.VirtualKey
@inject IDbContextFactory<ConfigurationDbContext> DbContextFactory
@inject NavigationManager NavigationManager
@inject ILogger<VirtualKeyEdit> Logger
@inject ConfigurationChangeNotifier ConfigChangeNotifier
@inject VirtualKeyService VirtualKeyService
@inject IJSRuntime JSRuntime
@rendermode InteractiveServer

<MudText Typo="Typo.h3" Class="mb-4">@(Id.HasValue ? "Edit Virtual Key" : "Create Virtual Key")</MudText>

@if (isLoading)
{
    <MudProgressCircular Color="Color.Primary" Indeterminate="true" />
}
else if (request == null && Id.HasValue)
{
    <MudAlert Severity="Severity.Error">Virtual key not found or error loading.</MudAlert>
}
else if (showCreatedKey)
{
    <MudAlert Severity="Severity.Success" Class="mb-4">
        <MudText Typo="Typo.h5" Class="mb-2">Virtual Key Created Successfully!</MudText>
        <MudText>Your new virtual key has been created. Please save this key as it will only be shown once:</MudText>
        <div class="d-flex align-center mt-3 mb-3">
            <MudTextField ReadOnly="true" Value="@createdKey" Class="flex-grow-1 mr-2" Variant="Variant.Outlined" id="newKeyInput" />
            <MudIconButton Icon="@Icons.Material.Filled.ContentCopy" Color="Color.Secondary" OnClick="CopyKeyToClipboard" />
        </div>
        <MudText>This key can be used to authenticate API requests. For security reasons, we only show this key once and store a secure hash.</MudText>
    </MudAlert>
    
    <MudAlert Severity="Severity.Warning" Class="mb-4">
        <div class="d-flex">
            <MudIcon Icon="@Icons.Material.Filled.Warning" Class="mr-2" />
            <MudText>Make sure to securely store this key. You won't be able to retrieve it again.</MudText>
        </div>
    </MudAlert>
    
    <div class="mt-4">
        <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="ReturnToList">Return to Virtual Keys List</MudButton>
    </div>
}
else
{
    <EditForm Model="@request" OnValidSubmit="HandleValidSubmit" FormName="VirtualKeyForm">
        <DataAnnotationsValidator />
        <ValidationSummary />

        @if (!string.IsNullOrEmpty(errorMessage))
        {
            <MudAlert Severity="Severity.Error" Class="mb-4">@errorMessage</MudAlert>
        }

        <MudGrid>
            <MudItem xs="12" md="6">
                <MudPaper Elevation="2" Class="pa-4 mb-4">
                    <MudText Typo="Typo.h6" Class="mb-3">Key Details</MudText>
                    
                    <MudTextField Label="Key Name" 
                                @bind-Value="request!.KeyName" 
                                For="@(() => request!.KeyName)"
                                HelperText="A friendly name to identify this key"
                                Class="mb-4" />

                    <div class="mb-4">
                        <div class="d-flex align-center mb-2">
                            <MudText Class="mr-2">Allowed Models (Optional):</MudText>
                            <MudTooltip Text="Select specific models this key can access. Leave empty to allow all models. More restrictive keys are more secure.">
                                <MudIcon Icon="@Icons.Material.Filled.Info" Size="Size.Small" />
                            </MudTooltip>
                            @if (availableModels != null && availableModels.Count > 0)
                            {
                                <MudChip T="string" Color="Color.Primary" Size="Size.Small" Class="ml-2">@selectedModels.Count selected</MudChip>
                            }
                        </div>
                        
                        <div class="d-flex mb-2">
                            <MudTextField @bind-Value="modelSearchText" 
                                        Placeholder="Search models..." 
                                        Immediate="true"
                                        Adornment="Adornment.Start"
                                        AdornmentIcon="@Icons.Material.Filled.Search"
                                        Class="flex-grow-1 mr-2" />
                            <MudButton Size="Size.Small" Variant="Variant.Outlined" OnClick="SelectAllModels">
                                <MudIcon Icon="@Icons.Material.Filled.DoneAll" Size="Size.Small" Class="mr-1" />
                                Select All
                            </MudButton>
                            <MudButton Size="Size.Small" Variant="Variant.Outlined" Color="Color.Error" Class="ml-2" OnClick="ClearModelSelection">
                                <MudIcon Icon="@Icons.Material.Filled.Clear" Size="Size.Small" Class="mr-1" />
                                Clear All
                            </MudButton>
                        </div>
                        
                        <MudPaper Elevation="0" Class="border pa-0" Style="height: 250px; overflow-y: auto;">
                            @if (availableModels == null || availableModels.Count == 0)
                            {
                                <MudProgressCircular Color="Color.Primary" Indeterminate="true" Class="ma-3" />
                            }
                            else
                            {
                                var filteredModels = FilterModels();
                                var groupedModels = filteredModels
                                    .GroupBy(m => m.ProviderName)
                                    .OrderBy(g => g.Key)
                                    .ToList();
                                
                                if (groupedModels.Count == 0)
                                {
                                    <MudText Typo="Typo.body2" Class="pa-3 mud-text-secondary">No models match your search.</MudText>
                                }
                                else
                                {
                                    @foreach (var group in groupedModels)
                                    {
                                        <div>
                                            <MudText Typo="Typo.subtitle2" Class="pa-2 d-flex justify-space-between mud-background-gray">
                                                <span>@group.Key</span>
                                                <MudChip T="string" Size="Size.Small" Color="Color.Default">
                                                    @group.Count() model@(group.Count() != 1 ? "s" : "")
                                                </MudChip>
                                            </MudText>
                                            <div class="pa-2">
                                                @foreach (var model in group.OrderBy(m => m.ModelAlias))
                                                {
                                                    <MudCheckBox T="bool" Checked="@(selectedModels.Contains(model.ModelAlias))"
                                                                 CheckedChanged="@((bool b) => ToggleModelSelection(model.ModelAlias, b))"
                                                                 Label="@model.ModelAlias"
                                                                 Color="Color.Primary"
                                                                 Size="Size.Small"
                                                                 Class="py-1" />
                                                }
                                            </div>
                                        </div>
                                    }
                                }
                            }
                        </MudPaper>
                        <MudText Typo="Typo.caption" Class="mt-1">
                            Specify which models this key can access, or leave empty to allow all models.
                        </MudText>
                    </div>
                </MudPaper>
                
                <MudPaper Elevation="2" Class="pa-4 mb-4">
                    <MudText Typo="Typo.h6" Class="mb-3">Rate Limits</MudText>
                    
                    <MudAlert Severity="Severity.Info" Class="mb-4">
                        Rate limits help prevent abuse and manage API load. Set to 0 for no limit.
                    </MudAlert>
                    
                    <div class="mb-4">
                        <div class="d-flex align-center mb-2">
                            <MudText>Requests Per Minute (RPM):</MudText>
                            <MudTooltip Text="Maximum number of requests allowed per minute for this key. Set to 0 for no limit.">
                                <MudIcon Icon="@Icons.Material.Filled.Info" Size="Size.Small" Class="ml-2" />
                            </MudTooltip>
                        </div>
                        <MudNumericField @bind-Value="request!.RateLimitRpm"
                                         For="@(() => request!.RateLimitRpm)"
                                         Min="0"
                                         Variant="Variant.Outlined" />
                    </div>
                    
                    <div class="mb-3">
                        <div class="d-flex align-center mb-2">
                            <MudText>Requests Per Day (RPD):</MudText>
                            <MudTooltip Text="Maximum number of requests allowed per day for this key. Set to 0 for no limit.">
                                <MudIcon Icon="@Icons.Material.Filled.Info" Size="Size.Small" Class="ml-2" />
                            </MudTooltip>
                        </div>
                        <MudNumericField @bind-Value="request!.RateLimitRpd" 
                                         For="@(() => request!.RateLimitRpd)"
                                         Min="0"
                                         Variant="Variant.Outlined" />
                    </div>
                </MudPaper>
            </MudItem>
            
            <MudItem xs="12" md="6">
                <MudPaper Elevation="2" Class="pa-4 mb-4">
                    <MudText Typo="Typo.h6" Class="mb-3">Budget Settings</MudText>
                    
                    <MudAlert Severity="Severity.Info" Class="mb-4">
                        Set a budget limit for this key to control costs. The budget can reset on a schedule you define.
                    </MudAlert>
                    
                    <div class="mb-4">
                        <div class="d-flex align-center mb-2">
                            <MudText>Max Budget ($):</MudText>
                            <MudTooltip Text="Maximum amount in USD this key can spend. Set to 0 for no budget limit.">
                                <MudIcon Icon="@Icons.Material.Filled.Info" Size="Size.Small" Class="ml-2" />
                            </MudTooltip>
                        </div>
                        <MudNumericField @bind-Value="request!.MaxBudget"
                                         For="@(() => request!.MaxBudget)"
                                         Min="0"
                                         Format="N2"
                                         AdornmentIcon="@Icons.Material.Filled.AttachMoney"
                                         Adornment="Adornment.Start"
                                         Variant="Variant.Outlined"
                                         HelperText="Set to 0 for no budget limit" />
                    </div>
                    
                    <div class="mb-4">
                        <div class="d-flex align-center mb-2">
                            <MudText>Budget Reset Schedule:</MudText>
                            <MudTooltip Text="How often the budget should reset. Select 'Never' if you want a fixed budget without reset.">
                                <MudIcon Icon="@Icons.Material.Filled.Info" Size="Size.Small" Class="ml-2" />
                            </MudTooltip>
                        </div>
                        <MudSelect T="string" @bind-Value="request!.BudgetDuration" 
                                  HelperText="How often the budget resets"
                                  Variant="Variant.Outlined">
                            <MudSelectItem Value="@string.Empty">Never (Fixed Budget)</MudSelectItem>
                            <MudSelectItem Value="@("Daily")">Daily</MudSelectItem>
                            <MudSelectItem Value="@("Weekly")">Weekly</MudSelectItem>
                            <MudSelectItem Value="@("Monthly")">Monthly</MudSelectItem>
                            <MudSelectItem Value="@("Quarterly")">Quarterly</MudSelectItem>
                            <MudSelectItem Value="@("Yearly")">Yearly</MudSelectItem>
                        </MudSelect>
                    </div>
                    
                    @if (!string.IsNullOrEmpty(request!.BudgetDuration))
                    {
                        <div class="mb-4">
                            <MudDatePicker Label="Budget Start Date" 
                                          @bind-Date="budgetStartDate" 
                                          HelperText="The date from which budget cycles are calculated"
                                          Variant="Variant.Outlined" />
                        </div>
                    }
                    
                    @if (Id.HasValue && request?.MaxBudget.HasValue == true && request.MaxBudget > 0)
                    {
                        <div class="mb-3">
                            <MudText Class="mb-2">Current Budget Usage:</MudText>
                            <div class="d-flex align-items-center mb-2">
                                @{
                                    var percentage = (int)(request.MaxBudget > 0 
                                        ? Math.Min(100, (currentSpend / request.MaxBudget.Value) * 100) 
                                        : 0);
                                    var progressColor = percentage < 60 
                                        ? Color.Success 
                                        : (percentage < 85 ? Color.Warning : Color.Error);
                                }
                                <MudProgressLinear Color="@progressColor" Value="@percentage" Class="flex-grow-1 mr-2" Style="height: 10px;">
                                    <MudText Typo="Typo.caption" Class="mud-text-secondary">@percentage%</MudText>
                                </MudProgressLinear>
                                <MudIconButton Icon="@Icons.Material.Filled.Refresh" 
                                             Size="Size.Small" 
                                             OnClick="ResetCurrentSpend" 
                                             Variant="Variant.Outlined"
                                             Class="ml-2" />
                            </div>
                            <div class="d-flex justify-space-between">
                                <MudText Typo="Typo.caption" Class="mud-text-secondary">$@(currentSpend.ToString("0.000000"))</MudText>
                                <MudText Typo="Typo.caption" Class="mud-text-secondary">of $@(request.MaxBudget?.ToString("0.000000"))</MudText>
                            </div>
                            @if (!string.IsNullOrEmpty(request!.BudgetDuration) && budgetStartDate.HasValue)
                            {
                                <MudText Typo="Typo.caption" Class="mt-2 d-flex align-center mud-text-secondary">
                                    <MudIcon Icon="@Icons.Material.Filled.Event" Size="Size.Small" Class="mr-1" />
                                    Next reset: @(GetNextBudgetResetDate(request.BudgetDuration, budgetStartDate))
                                </MudText>
                            }
                        </div>
                    }
                </MudPaper>
                
                <MudPaper Elevation="2" Class="pa-4 mb-4">
                    <MudText Typo="Typo.h6" Class="mb-3">Limits</MudText>
                    
                    <div class="mb-4">
                        <MudCheckBox T="bool" @bind-Checked="_setMaxSpend"
                                     Label="Set Max Spend"
                                     Color="Color.Primary" />
                        <MudCollapse Expanded="@_setMaxSpend">
                            <MudNumericField @bind-Value="request!.MaxBudget"
                                             For="@(() => request!.MaxBudget)"
                                             Min="0"
                                             Format="N2"
                                             AdornmentIcon="@Icons.Material.Filled.AttachMoney"
                                             Adornment="Adornment.Start"
                                             Variant="Variant.Outlined"
                                             HelperText="Set to 0 for no budget limit" />
                        </MudCollapse>
                    </div>
                </MudPaper>
                
                <MudPaper Elevation="2" Class="pa-4 mb-4">
                    <MudText Typo="Typo.h6" Class="mb-3">Key Details</MudText>
                    
                    <MudTextField Label="Description (Optional)" 
                                @bind-Value="description" 
                                Lines="3"
                                Variant="Variant.Outlined"
                                HelperText="A description of what this key is used for"
                                Class="mb-4" />
                    
                    <div class="mb-3">
                        <div class="d-flex align-center mb-2">
                            <MudText>Expiration Date (Optional):</MudText>
                            <MudTooltip Text="Date when this key will expire. Leave empty for a non-expiring key.">
                                <MudIcon Icon="@Icons.Material.Filled.Info" Size="Size.Small" Class="ml-2" />
                            </MudTooltip>
                        </div>
                        <MudDatePicker @bind-Date="request!.ExpiresAt"
                                      HelperText="Leave empty for a key that never expires"
                                      Variant="Variant.Outlined" />
                    </div>
                </MudPaper>
            </MudItem>
        </MudGrid>
        
        <MudPaper Elevation="0" Class="d-flex gap-2 mt-4">
            <MudButton ButtonType="ButtonType.Submit" 
                      Variant="Variant.Filled" 
                      Color="Color.Primary" 
                      Disabled="@isSaving"
                      StartIcon="@(Id.HasValue ? Icons.Material.Filled.Save : Icons.Material.Filled.Add)">
                @if (isSaving)
                {
                    <MudProgressCircular Class="mr-2" Size="Size.Small" Indeterminate="true" />
                    <span>Saving...</span>
                }
                else
                {
                    <span>@(Id.HasValue ? "Update Key" : "Create Key")</span>
                }
            </MudButton>
            <MudButton Variant="Variant.Outlined" 
                      Color="Color.Secondary" 
                      OnClick="Cancel">
                Cancel
            </MudButton>
        </MudPaper>
    </EditForm>
}

@code {
    [Parameter]
    public int? Id { get; set; }
    
    private bool isLoading = true;
    private bool isSaving = false;
    private string? errorMessage;
    private UpdateVirtualKeyRequestDto? request;
    private List<ModelMappingViewModel>? availableModels;
    private HashSet<string> selectedModels = new();
    private string modelSearchText = "";
    private decimal currentSpend = 0;
    private bool showCreatedKey = false;
    private string createdKey = "";
    private string? description; // Field to hold description since UpdateVirtualKeyRequestDto doesn't have it
    private DateTime? budgetStartDate; // Field to hold budget start date
    private bool _setMaxSpend = false;

    protected override async Task OnInitializedAsync()
    {
        try
        {
            await LoadAvailableModelsAsync();
            
            if (Id.HasValue)
            {
                await LoadVirtualKey();
            }
            else
            {
                // Create a new request
                request = new UpdateVirtualKeyRequestDto
                {
                    KeyName = "",
                    MaxBudget = 0,
                    BudgetDuration = "",
                    ExpiresAt = null,
                    AllowedModels = "",
                    RateLimitRpm = 0,
                    RateLimitRpd = 0
                };
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Error loading data: {ex.Message}";
            Logger.LogError(ex, "Error initializing VirtualKeyEdit component");
        }
        finally
        {
            isLoading = false;
        }
    }
    
    private async Task LoadVirtualKey()
    {
        if (!Id.HasValue) return;
        
        try
        {
            var key = await VirtualKeyService.GetVirtualKeyInfoAsync(Id.Value);
            if (key == null)
            {
                return;
            }
            
            // Initialize the request from the existing key
            request = new UpdateVirtualKeyRequestDto
            {
                KeyName = key.KeyName,
                MaxBudget = key.MaxBudget,
                BudgetDuration = key.BudgetDuration,
                ExpiresAt = key.ExpiresAt,
                AllowedModels = key.AllowedModels,
                RateLimitRpm = key.RateLimitRpm,
                RateLimitRpd = key.RateLimitRpd
            };
            
            description = key.Metadata; // Use metadata for description 
            budgetStartDate = key.BudgetStartDate; // Store the budget start date separately
            
            // Parse allowed models
            if (!string.IsNullOrEmpty(key.AllowedModels))
            {
                selectedModels = new HashSet<string>(key.AllowedModels.Split(',', StringSplitOptions.RemoveEmptyEntries));
            }
            
            currentSpend = key.CurrentSpend;
        }
        catch (Exception ex)
        {
            errorMessage = $"Error loading virtual key: {ex.Message}";
            Logger.LogError(ex, "Error loading virtual key with ID {KeyId}", Id);
        }
    }
    
    private async Task LoadAvailableModelsAsync()
    {
        try
        {
            using var dbContext = await DbContextFactory.CreateDbContextAsync();
            
            // Load model mappings from the consolidated context
            availableModels = await dbContext.ModelProviderMappings
                .Include(m => m.ProviderCredential)
                .Select(m => new ModelMappingViewModel
                {
                    ModelAlias = m.ModelAlias,
                    ProviderName = m.ProviderCredential.ProviderName,
                    ProviderModelId = m.ProviderModelName
                })
                .ToListAsync();
                
            if (Id.HasValue && !string.IsNullOrEmpty(request?.AllowedModels))
            {
                selectedModels = new HashSet<string>(
                    request.AllowedModels.Split(',', StringSplitOptions.RemoveEmptyEntries));
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading available models");
            errorMessage = "Failed to load available models. See logs for details.";
        }
    }
    
    private List<ModelMappingViewModel> FilterModels()
    {
        if (availableModels == null) return new List<ModelMappingViewModel>();
        
        if (string.IsNullOrWhiteSpace(modelSearchText))
            return availableModels;
            
        return availableModels
            .Where(m => 
                m.ModelAlias.Contains(modelSearchText, StringComparison.OrdinalIgnoreCase) ||
                m.ProviderName.Contains(modelSearchText, StringComparison.OrdinalIgnoreCase))
            .ToList();
    }
    
    private void ToggleModelSelection(string modelKey, bool isSelected)
    {
        if (isSelected)
            selectedModels.Add(modelKey);
        else
            selectedModels.Remove(modelKey);
    }
    
    private void SelectAllModels()
    {
        if (availableModels == null) return;
        
        var filteredModels = FilterModels();
        foreach (var model in filteredModels)
        {
            selectedModels.Add(model.ModelAlias);
        }
    }
    
    private void ClearModelSelection()
    {
        if (modelSearchText.Length > 0)
        {
            // If there's a search filter, only clear the filtered items
            var filteredModelKeys = FilterModels()
                .Select(m => m.ModelAlias)
                .ToList();
                
            foreach (var key in filteredModelKeys)
            {
                selectedModels.Remove(key);
            }
        }
        else
        {
            // Clear all selections
            selectedModels.Clear();
        }
    }
    
    private async Task HandleValidSubmit()
    {
        if (request == null) return;
        
        try
        {
            isSaving = true;
            
            // Update the allowed models from the selection
            request.AllowedModels = string.Join(",", selectedModels);
            
            if (Id.HasValue)
            {
                // Update an existing key
                // Also set the metadata field to store the description
                request.Metadata = description;
                
                var result = await VirtualKeyService.UpdateVirtualKeyAsync(Id.Value, request);
                if (result)
                {
                    NavigationManager.NavigateTo("/virtualkeys");
                }
                else
                {
                    errorMessage = "Failed to update the virtual key";
                }
            }
            else
            {
                // Create a new key
                var createRequest = new CreateVirtualKeyRequestDto
                {
                    KeyName = request.KeyName ?? "",
                    AllowedModels = request.AllowedModels,
                    MaxBudget = request.MaxBudget,
                    BudgetDuration = request.BudgetDuration,
                    ExpiresAt = request.ExpiresAt,
                    Metadata = description,
                    RateLimitRpm = request.RateLimitRpm,
                    RateLimitRpd = request.RateLimitRpd
                };
                
                var response = await VirtualKeyService.GenerateVirtualKeyAsync(createRequest);
                if (response != null)
                {
                    createdKey = response.VirtualKey;
                    showCreatedKey = true;
                }
                else
                {
                    errorMessage = "Failed to create the virtual key";
                }
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Error: {ex.Message}";
            Logger.LogError(ex, "Error saving virtual key");
        }
        finally
        {
            isSaving = false;
        }
    }

    private void Cancel()
    {
        NavigationManager.NavigateTo("/virtualkeys");
    }
    
    private void ReturnToList()
    {
        NavigationManager.NavigateTo("/virtualkeys");
    }

    private async Task ResetCurrentSpend()
    {
        if (!Id.HasValue) return;
        
        try
        {
            var success = await VirtualKeyService.ResetSpendAsync(Id.Value);
            if (success)
            {
                currentSpend = 0;
                StateHasChanged();
            }
            else
            {
                errorMessage = "Failed to reset spend. The key may have been deleted.";
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Error resetting spend: {ex.Message}";
            Logger.LogError(ex, "Error resetting spend for virtual key with ID {KeyId}", Id);
        }
    }
    
    private async Task CopyKeyToClipboard()
    {
        if (string.IsNullOrEmpty(createdKey)) return;
        
        try
        {
            await JSRuntime.InvokeAsync<object>("navigator.clipboard.writeText", createdKey);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error copying key to clipboard");
        }
    }
    
    // View model for model mappings
    private class ModelMappingViewModel
    {
        public string ModelAlias { get; set; } = string.Empty;
        public string ProviderName { get; set; } = string.Empty;
        public string ProviderModelId { get; set; } = string.Empty;
    }

    private string GetNextBudgetResetDate(string budgetDuration, DateTime? budgetStartDate)
    {
        if (string.IsNullOrEmpty(budgetDuration) || !budgetStartDate.HasValue)
            return "N/A";

        DateTime start = budgetStartDate.Value;
        DateTime now = DateTime.UtcNow;
        DateTime nextReset;

        switch (budgetDuration.ToLowerInvariant())
        {
            case "daily":
                nextReset = now.Date.AddDays(1);
                break;
            case "weekly":
                // Calculate days until next week starts from the original start day
                int daysUntilNextWeek = ((int)start.DayOfWeek - (int)now.DayOfWeek + 7) % 7;
                if (daysUntilNextWeek == 0) daysUntilNextWeek = 7; // If today is the reset day, move to next week
                nextReset = now.Date.AddDays(daysUntilNextWeek);
                break;
            case "monthly":
                // Calculate next month with same day
                int day = Math.Min(start.Day, DateTime.DaysInMonth(now.Year, now.Month));
                if (now.Day < day)
                    nextReset = new DateTime(now.Year, now.Month, day);
                else
                    nextReset = new DateTime(
                        now.Month == 12 ? now.Year + 1 : now.Year,
                        now.Month == 12 ? 1 : now.Month + 1,
                        Math.Min(start.Day, DateTime.DaysInMonth(
                            now.Month == 12 ? now.Year + 1 : now.Year,
                            now.Month == 12 ? 1 : now.Month + 1)));
                break;
            case "quarterly":
                // Calculate the current quarter
                int currentQuarter = (now.Month - 1) / 3;
                // Calculate the next quarter's first month
                int nextQuarterMonth = (currentQuarter + 1) * 3 + 1;
                int nextQuarterYear = now.Year;
                if (nextQuarterMonth > 12)
                {
                    nextQuarterMonth -= 12;
                    nextQuarterYear += 1;
                }
                nextReset = new DateTime(
                    nextQuarterYear,
                    nextQuarterMonth,
                    Math.Min(start.Day, DateTime.DaysInMonth(nextQuarterYear, nextQuarterMonth)));
                break;
            case "yearly":
                // Calculate next yearly reset
                if (now.Month < start.Month || (now.Month == start.Month && now.Day < start.Day))
                    nextReset = new DateTime(now.Year, start.Month, Math.Min(start.Day, DateTime.DaysInMonth(now.Year, start.Month)));
                else
                    nextReset = new DateTime(now.Year + 1, start.Month, Math.Min(start.Day, DateTime.DaysInMonth(now.Year + 1, start.Month)));
                break;
            default:
                return "N/A";
        }

        return nextReset.ToString("yyyy-MM-dd");
    }
}
