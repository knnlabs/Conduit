@page "/configuration"
@using System.Text.Json
@using Microsoft.EntityFrameworkCore
@using ConduitLLM.Configuration
@using ConduitLLM.Configuration.Entities
@using ConduitLLM.Providers.Configuration
@using ConduitLLM.WebUI.Services
@using Microsoft.Extensions.Logging
@using System.Collections.Generic
@using System.Linq
@using System.Threading.Tasks
@using Microsoft.JSInterop
@using MudBlazor

@inject NavigationManager NavigationManager
@inject ILogger<Configuration> Logger
@inject IDbContextFactory<ConduitLLM.Configuration.ConfigurationDbContext> DbContextFactory
@inject ConfigurationChangeNotifier ConfigChangeNotifier
@inject HttpRetryConfigurationService HttpRetryService
@inject HttpTimeoutConfigurationService HttpTimeoutService
@inject IJSRuntime JSRuntime
@inject ISnackbar Snackbar
@rendermode InteractiveServer

<MudContainer MaxWidth="MaxWidth.ExtraLarge">
    <MudText Typo="Typo.h3" Class="mb-4">Configuration Management</MudText>

    @if (!string.IsNullOrEmpty(deleteErrorMessage))
    {
        <MudAlert Severity="Severity.Error" Class="mb-4" Variant="Variant.Filled">@deleteErrorMessage</MudAlert>
    }

    <MudCard Elevation="2" Class="mb-6">
        <MudCardHeader>
            <CardHeaderContent>
                <MudText Typo="Typo.h5">LLM Providers</MudText>
            </CardHeaderContent>
            <CardHeaderActions>
                <MudMenu Icon="@Icons.Material.Filled.Add" Color="Color.Primary" 
                        AnchorOrigin="Origin.BottomRight" 
                        TransformOrigin="Origin.TopRight" 
                        Label="Add Provider"
                        Variant="Variant.Filled">
                    @foreach (var provider in _supportedProviders)
                    {
                        <MudMenuItem OnClick="() => LaunchGuidedSetup(provider)">@provider</MudMenuItem>
                    }
                </MudMenu>
            </CardHeaderActions>
        </MudCardHeader>
        
        <MudCardContent>
            @if (providerCredentials == null)
            {
                <MudProgressCircular Color="Color.Primary" Indeterminate="true" />
            }
            else if (!providerCredentials.Any())
            {
                <MudAlert Severity="Severity.Info" Class="mb-4" Variant="Variant.Outlined">
                    <MudText>No providers configured yet. Add an LLM provider to get started.</MudText>
                </MudAlert>

                <MudGrid>
                    @foreach (var provider in _supportedProviders)
                    {
                        <MudItem xs="12" sm="6" md="4">
                            <MudCard Elevation="1" Class="h-100">
                                <MudCardHeader>
                                    <CardHeaderContent>
                                        <MudText Typo="Typo.h6">@provider</MudText>
                                    </CardHeaderContent>
                                </MudCardHeader>
                                <MudCardContent>
                                    <MudText Typo="Typo.body2" Class="flex-grow-1">
                                        @GetProviderDescription(provider)
                                    </MudText>
                                </MudCardContent>
                                <MudCardActions>
                                    <MudButton Variant="Variant.Filled" Color="Color.Primary" 
                                             StartIcon="@Icons.Material.Filled.Add" 
                                             FullWidth="true"
                                             OnClick="() => LaunchGuidedSetup(provider)">
                                        Setup @provider
                                    </MudButton>
                                </MudCardActions>
                            </MudCard>
                        </MudItem>
                    }
                </MudGrid>
            }
            else
            {
                <MudTable Items="@providerCredentials" Hover="true" Striped="false" Dense="false" Elevation="0">
                    <HeaderContent>
                        <MudTh>Provider</MudTh>
                        <MudTh>API Key</MudTh>
                        <MudTh>Base URL</MudTh>
                        <MudTh>Actions</MudTh>
                    </HeaderContent>
                    <RowTemplate>
                        <MudTd DataLabel="Provider">@context.ProviderName</MudTd>
                        <MudTd DataLabel="API Key">
                            <MudText Color="Color.Secondary">@(string.IsNullOrEmpty(context.ApiKey) ? "Not set" : "••••••••")</MudText>
                        </MudTd>
                        <MudTd DataLabel="Base URL">@(string.IsNullOrEmpty(context.BaseUrl) ? "Default" : context.BaseUrl)</MudTd>
                        <MudTd>
                            <MudButtonGroup Size="Size.Small" Variant="Variant.Outlined">
                                <MudButton Color="Color.Primary" OnClick="() => EditProvider(context.Id)">Edit</MudButton>
                                <MudButton Color="Color.Error" OnClick="() => DeleteProvider(context.Id)">Delete</MudButton>
                            </MudButtonGroup>
                        </MudTd>
                    </RowTemplate>
                </MudTable>
            }
        </MudCardContent>
    </MudCard>

    <MudDivider Class="my-6" />

    <MudCard Elevation="2" Class="mb-6">
        <MudCardHeader>
            <CardHeaderContent>
                <MudText Typo="Typo.h5">Model Mappings</MudText>
            </CardHeaderContent>
        </MudCardHeader>
        
        <MudCardContent>
            <MudText Typo="Typo.body1" Class="mb-4">
                Map user-friendly model names to specific provider models. For example, you can map "gpt4" to OpenAI's "gpt-4-turbo-preview" model.
            </MudText>
            
            @if (modelMappings == null)
            {
                <MudProgressCircular Color="Color.Primary" Indeterminate="true" />
            }
            else if (!modelMappings.Any())
            {
                <MudAlert Severity="Severity.Info" Variant="Variant.Outlined" Class="mb-4">
                    No model mappings defined yet. Add one below.
                </MudAlert>
            }
            else
            {
                <MudTable Items="@modelMappings" Hover="true" Striped="true" Dense="false" Elevation="0" Class="mb-4">
                    <HeaderContent>
                        <MudTh>Model Alias</MudTh>
                        <MudTh>Provider</MudTh>
                        <MudTh>Provider Model</MudTh>
                        <MudTh>Actions</MudTh>
                    </HeaderContent>
                    <RowTemplate>
                        <MudTd DataLabel="Model Alias">@context.ModelAlias</MudTd>
                        <MudTd DataLabel="Provider">@context.ProviderCredential?.ProviderName</MudTd>
                        <MudTd DataLabel="Provider Model">@context.ProviderModelName</MudTd>
                        <MudTd>
                            <MudButtonGroup Size="Size.Small" Variant="Variant.Outlined">
                                <MudButton Color="Color.Primary" 
                                         StartIcon="@Icons.Material.Filled.Edit"
                                         OnClick="() => HandleEditMapping(context.Id)">Edit</MudButton>
                                <MudButton Color="Color.Error" 
                                         StartIcon="@Icons.Material.Filled.Delete"
                                         OnClick="() => DeleteMapping(context.Id)">Delete</MudButton>
                            </MudButtonGroup>
                        </MudTd>
                    </RowTemplate>
                </MudTable>
            }
            
            <MudButton Variant="Variant.Filled" 
                     Color="Color.Primary" 
                     StartIcon="@Icons.Material.Filled.Add" 
                     OnClick="() => { isEditingMapping = true; currentMapping = new ConduitLLM.Configuration.ModelProviderMapping { ModelAlias = string.Empty, ProviderName = string.Empty, ProviderModelId = string.Empty }; mappingErrorMessage = null; }">
                Add Model Mapping
            </MudButton>
        </MudCardContent>
    </MudCard>

    @if (isEditingMapping)
    {
        <MudCard Elevation="3" Class="mb-6">
            <MudCardHeader>
                <CardHeaderContent>
                    <MudText Typo="Typo.h6">@(currentMapping.ModelAlias == null ? "Add" : "Edit") Model Mapping</MudText>
                </CardHeaderContent>
            </MudCardHeader>
            <MudCardContent>
                @if (!string.IsNullOrEmpty(mappingErrorMessage))
                {
                    <MudAlert Severity="Severity.Error" Class="mb-4">@mappingErrorMessage</MudAlert>
                }
                
                <MudTextField T="string" Label="Model Alias" 
                            @bind-Value="currentMapping.ModelAlias"
                            Variant="Variant.Outlined"
                            HelperText="The friendly name you'll use in your code (e.g., 'gpt4', 'claude-latest')"
                            Class="mb-4" />
                
                <MudSelect T="string" Label="Provider" 
                         @bind-Value="currentMapping.ProviderName"
                         Variant="Variant.Outlined"
                         Class="mb-4">
                    <MudSelectItem Value="@string.Empty">-- Select Provider --</MudSelectItem>
                    @if (providerCredentials != null)
                    {
                        @foreach (var provider in providerCredentials.OrderBy(p => p.ProviderName))
                        {
                            <MudSelectItem Value="@provider.ProviderName">@provider.ProviderName</MudSelectItem>
                        }
                    }
                </MudSelect>
                
                <MudTextField T="string" Label="Provider Model ID" 
                            @bind-Value="currentMapping.ProviderModelId"
                            Variant="Variant.Outlined"
                            HelperText="The actual model ID used by the provider (e.g., 'gpt-4-turbo-preview', 'claude-3-opus-20240229')"
                            Class="mb-4" />
                
                <MudCardActions Class="d-flex justify-end">
                    <MudButton Variant="Variant.Outlined" Color="Color.Default" OnClick="() => isEditingMapping = false" Class="mr-2">Cancel</MudButton>
                    <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="SaveMapping">Save</MudButton>
                </MudCardActions>
            </MudCardContent>
        </MudCard>
    }

    <MudDivider Class="my-6" />

    <MudText Typo="Typo.h5" Class="mb-4">Global Settings</MudText>

    <MudGrid>
        <MudItem xs="12" md="6">
            <MudCard Elevation="2" Class="mb-4">
                <MudCardHeader>
                    <CardHeaderContent>
                        <MudText Typo="Typo.h6">Proxy Base URL</MudText>
                    </CardHeaderContent>
                </MudCardHeader>
                <MudCardContent>
                    <MudTextField T="string" 
                                @bind-Value="proxyBaseUrlInput"
                                Label="Conduit Proxy Base URL"
                                Placeholder="e.g., https://api.yourcompany.com/conduit"
                                HelperText="URL where your Conduit API is publicly accessible. Used for SDK clients."
                                Variant="Variant.Outlined"
                                Class="mb-3" />
                    
                    <MudButton Variant="Variant.Filled" 
                             Color="Color.Primary" 
                             OnClick="SaveProxyUrl"
                             Class="mt-2">
                        Save
                    </MudButton>
                    
                    @if (!string.IsNullOrEmpty(proxyUrlSaveMessage))
                    {
                        <MudAlert Severity="Severity.Success" Class="mt-3">
                            @proxyUrlSaveMessage
                        </MudAlert>
                    }
                </MudCardContent>
            </MudCard>
        </MudItem>
    </MudGrid>

    <MudGrid>
        <MudItem xs="12" md="6">
            <MudCard Elevation="2" Class="mb-6">
                <MudCardHeader>
                    <CardHeaderContent>
                        <MudText Typo="Typo.h6">HTTP Retry Settings</MudText>
                    </CardHeaderContent>
                </MudCardHeader>
                <MudCardContent>
                    <MudNumericField T="int" 
                                   @bind-Value="httpRetryOptions.MaxRetries"
                                   Label="Maximum Retry Attempts"
                                   Min="0" Max="10"
                                   Variant="Variant.Outlined"
                                   HelperText="Maximum number of times to retry HTTP requests on transient failures (0-10)"
                                   Class="mb-4" />
                                   
                    <MudNumericField T="int" 
                                   @bind-Value="httpRetryOptions.InitialDelaySeconds"
                                   Label="Initial Delay (seconds)"
                                   Min="0" Max="10"
                                   Variant="Variant.Outlined"
                                   HelperText="Initial delay before first retry attempt"
                                   Class="mb-4" />
                                   
                    <MudNumericField T="int" 
                                   @bind-Value="httpRetryOptions.MaxDelaySeconds"
                                   Label="Maximum Delay (seconds)"
                                   Min="1" Max="60"
                                   Variant="Variant.Outlined"
                                   HelperText="Maximum delay cap for any retry attempt"
                                   Class="mb-4" />
                                   
                    <MudSwitch @bind-Value="httpRetryOptions.EnableRetryLogging"
                             Label="Enable Retry Logging"
                             Color="Color.Primary"
                             Class="mb-4" />
                             
                    <MudButton Variant="Variant.Filled" Color="Color.Primary"
                             OnClick="async () => await SaveHttpRetryOptions()"
                             StartIcon="@Icons.Material.Filled.Save"
                             Class="mb-2">
                        Save Retry Settings
                    </MudButton>
                    
                    @if (!string.IsNullOrEmpty(httpRetryOptionsSaveMessage))
                    {
                        <MudAlert Severity="Severity.Success" Class="mt-3">
                            @httpRetryOptionsSaveMessage
                        </MudAlert>
                    }
                </MudCardContent>
            </MudCard>
        </MudItem>
        
        <MudItem xs="12" md="6">
            <MudCard Elevation="2" Class="mb-6">
                <MudCardHeader>
                    <CardHeaderContent>
                        <MudText Typo="Typo.h6">HTTP Timeout Settings</MudText>
                    </CardHeaderContent>
                </MudCardHeader>
                <MudCardContent>
                    <MudNumericField T="int" 
                                   @bind-Value="httpTimeoutOptions.TimeoutSeconds"
                                   Label="Timeout Duration (seconds)"
                                   Min="10" Max="600"
                                   Variant="Variant.Outlined"
                                   HelperText="Maximum time to wait for HTTP requests to complete before timing out (10-600 seconds)"
                                   Class="mb-4" />
                                   
                    <MudSwitch @bind-Value="httpTimeoutOptions.EnableTimeoutLogging"
                             Label="Enable Timeout Logging"
                             Color="Color.Primary"
                             Class="mb-4" />
                    <MudText Typo="Typo.caption" Color="Color.Secondary" Class="ml-4 mb-4">
                        Log detailed information about request timeouts
                    </MudText>
                             
                    <MudButton Variant="Variant.Filled" Color="Color.Primary"
                             OnClick="async () => await SaveHttpTimeoutOptions()"
                             StartIcon="@Icons.Material.Filled.Save"
                             Class="mb-2">
                        Save Timeout Settings
                    </MudButton>
                    
                    @if (!string.IsNullOrEmpty(httpTimeoutOptionsSaveMessage))
                    {
                        <MudAlert Severity="Severity.Success" Class="mt-3">
                            @httpTimeoutOptionsSaveMessage
                        </MudAlert>
                    }
                </MudCardContent>
            </MudCard>
        </MudItem>
    </MudGrid>

    <MudGrid>
        <MudItem xs="12" md="6">
            <MudCard Elevation="1" Class="mb-6">
                <MudCardHeader>
                    <CardHeaderContent>
                        <MudText Typo="Typo.h6">About HTTP Client Settings</MudText>
                    </CardHeaderContent>
                </MudCardHeader>
                <MudCardContent>
                    <MudText Typo="Typo.body2" Class="mb-3">
                        These settings control how ConduitLLM handles retry logic when communicating with LLM provider APIs.
                    </MudText>
                    <MudPaper Class="pa-4" Outlined="true">
                        <div class="d-flex align-center mb-3">
                            <MudIcon Icon="@Icons.Material.Filled.Refresh" Class="mr-3" />
                            <MudText>
                                <strong>Maximum Retry Attempts</strong>: Number of times the system will retry failed API calls that encounter transient errors.
                            </MudText>
                        </div>
                        <div class="d-flex align-center mb-3">
                            <MudIcon Icon="@Icons.Material.Filled.Timer" Class="mr-3" />
                            <MudText>
                                <strong>Initial Delay</strong>: How long to wait before the first retry attempt. Subsequent retries use exponential backoff with jitter.
                            </MudText>
                        </div>
                        <div class="d-flex align-center mb-3">
                            <MudIcon Icon="@Icons.Material.Filled.AccessTime" Class="mr-3" />
                            <MudText>
                                <strong>Maximum Delay</strong>: The maximum time to wait between retry attempts, regardless of the backoff calculation.
                            </MudText>
                        </div>
                        <div class="d-flex align-center">
                            <MudIcon Icon="@Icons.Material.Filled.Notifications" Class="mr-3" />
                            <MudText>
                                <strong>Enable Retry Logging</strong>: When enabled, detailed logs will be generated for each retry attempt, helping with troubleshooting.
                            </MudText>
                        </div>
                    </MudPaper>
                    <MudAlert Severity="Severity.Info" Class="mt-3" Variant="Variant.Outlined">
                        These settings apply to all provider clients and provide resilience against temporary API outages and rate limiting.
                    </MudAlert>
                </MudCardContent>
            </MudCard>
        </MudItem>
        <MudItem xs="12" md="6">
            <MudCard Elevation="1" Class="mb-6">
                <MudCardHeader>
                    <CardHeaderContent>
                        <MudText Typo="Typo.h6">About HTTP Timeout Settings</MudText>
                    </CardHeaderContent>
                </MudCardHeader>
                <MudCardContent>
                    <MudText Typo="Typo.body2" Class="mb-3">
                        These settings control how ConduitLLM handles timeouts when communicating with LLM provider APIs.
                    </MudText>
                    <MudPaper Class="pa-4" Outlined="true">
                        <div class="d-flex align-center mb-3">
                            <MudIcon Icon="@Icons.Material.Filled.AccessTime" Class="mr-3" />
                            <MudText>
                                <strong>Timeout Duration</strong>: Maximum time to wait for HTTP requests to complete before timing out.
                            </MudText>
                        </div>
                        <div class="d-flex align-center">
                            <MudIcon Icon="@Icons.Material.Filled.Notifications" Class="mr-3" />
                            <MudText>
                                <strong>Enable Timeout Logging</strong>: When enabled, detailed logs will be generated for each request timeout, helping with troubleshooting.
                            </MudText>
                        </div>
                    </MudPaper>
                    <MudAlert Severity="Severity.Info" Class="mt-3" Variant="Variant.Outlined">
                        These settings apply to all provider clients and provide resilience against slow or unresponsive APIs.
                    </MudAlert>
                </MudCardContent>
            </MudCard>
        </MudItem>
    </MudGrid>
</MudContainer>

@* Guided Setup Modal Components *@
<GuidedSetupWizard
    @ref="guidedSetupWizardInstance"
    IsOpen="isGuidedSetupOpen"
    OnSetupComplete="HandleSetupComplete"
    IsOpenChanged="(value) => { isGuidedSetupOpen = value; StateHasChanged(); }" />

@code {
    // --- Providers and Mappings State ---
    private List<ConduitLLM.Configuration.Entities.ProviderCredential> providerCredentials = new();
    private List<ConduitLLM.Configuration.Entities.ModelProviderMapping> modelMappings = new();
    private List<ConduitLLM.Configuration.Entities.GlobalSetting> globalSettings = new();

    // Provider form state
    private ConduitLLM.Configuration.Entities.ProviderCredential currentProvider = new();

    // Mapping form state
    private bool isEditingMapping = false;
    private ConduitLLM.Configuration.ModelProviderMapping currentMapping = new() 
    { 
        ModelAlias = "",
        ProviderName = "",
        ProviderModelId = ""
    };
    private string? mappingErrorMessage;

    // Settings state
    private ConduitLLM.Configuration.Entities.GlobalSetting currentSettings = new();
    
    // HTTP options state
    private string? proxyBaseUrlInput;
    private string? proxyUrlSaveMessage;
    private string? httpRetryOptionsSaveMessage;
    private string? httpTimeoutOptionsSaveMessage;
    private ConduitLLM.Providers.Configuration.RetryOptions httpRetryOptions = new();
    private ConduitLLM.Providers.Configuration.TimeoutOptions httpTimeoutOptions = new();
    
    // --- Guided Setup State ---
    private GuidedSetupWizard? guidedSetupWizardInstance;
    private bool isGuidedSetupOpen;
    private string? deleteErrorMessage;
    
    private readonly List<string> _supportedProviders = new List<string> {
        "OpenAI", "Anthropic", "Cohere", "Google", "Mistral", "Groq", "HuggingFace", "AWS", "Azure", "OpenRouter", "Cerebras"
    };
    
    protected override async Task OnInitializedAsync()
    {
        try
        {
            await LoadProvidersAsync();
            await LoadModelMappingsAsync();
            await LoadProxyUrlAsync();
            await LoadHttpRetryOptionsAsync();
            await LoadHttpTimeoutOptionsAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error initializing Configuration page");
        }
    }
    
    // --- Settings Loading Methods ---
    
    private async Task LoadProvidersAsync()
    {
        try
        {
            using var dbContext = await DbContextFactory.CreateDbContextAsync(); 
            providerCredentials = await dbContext.ProviderCredentials.ToListAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading provider credentials");
            providerCredentials = new List<ConduitLLM.Configuration.Entities.ProviderCredential>(); 
        }
    }
    
    private async Task LoadModelMappingsAsync()
    {
        try
        {
            using var dbContext = await DbContextFactory.CreateDbContextAsync(); 
            modelMappings = await dbContext.ModelProviderMappings
                .Include(m => m.ProviderCredential)
                .OrderBy(m => m.ModelAlias)
                .ToListAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading model mappings");
            modelMappings = new List<ConduitLLM.Configuration.Entities.ModelProviderMapping>();
        }
    }
    
    private async Task LoadProxyUrlAsync()
    {
        try
        {
            using var dbContext = await DbContextFactory.CreateDbContextAsync(); 
            var proxyUrlSetting = await dbContext.GlobalSettings.FirstOrDefaultAsync(s => s.Key == "ConduitSettings:ProxyBaseUrl");
            proxyBaseUrlInput = proxyUrlSetting?.Value;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading proxy URL setting");
        }
    }
    
    private async Task LoadHttpRetryOptionsAsync()
    {
        httpRetryOptions = HttpRetryService.GetRetryConfiguration() ?? new ConduitLLM.Providers.Configuration.RetryOptions();
        await Task.CompletedTask;
    }
    
    private async Task LoadHttpTimeoutOptionsAsync()
    {
        httpTimeoutOptions = HttpTimeoutService.GetTimeoutConfiguration() ?? new ConduitLLM.Providers.Configuration.TimeoutOptions();
        await Task.CompletedTask;
    }
    
    // --- Provider/Mapping Methods ---
    
    private void AddProvider()
    {
        NavigationManager.NavigateTo("/configuration/provider/edit");
    }

    private void EditProvider(int id)
    {
        NavigationManager.NavigateTo($"/configuration/provider/edit/{id}");
    }

    private async Task DeleteProvider(int id)
    {
        try
        {
            deleteErrorMessage = null;
            using var dbContext = await DbContextFactory.CreateDbContextAsync(); 
            var providerToDelete = await dbContext.ProviderCredentials.FindAsync(id);
            if (providerToDelete == null) return;

            bool confirmed = await JSRuntime.InvokeAsync<bool>("confirm",
                $"Are you sure you want to delete the provider '{providerToDelete.ProviderName}'? This cannot be undone.");

            if (!confirmed) return;

            var relatedMappings = await dbContext.ModelProviderMappings
                .Where(m => m.ProviderCredentialId == providerToDelete.Id)
                .ToListAsync();

            if (relatedMappings.Any())
            {
                dbContext.ModelProviderMappings.RemoveRange(relatedMappings);
            }

            dbContext.ProviderCredentials.Remove(providerToDelete);
            await dbContext.SaveChangesAsync(); 

            await LoadProvidersAsync(); 
            await LoadModelMappingsAsync();
            
            Snackbar.Add($"Provider '{providerToDelete.ProviderName}' deleted successfully", Severity.Success);
        }
        catch (Exception ex)
        {
            deleteErrorMessage = $"Error deleting provider: {ex.Message}";
            Logger.LogError(ex, "Error deleting provider");
            StateHasChanged();
        }
    }

    private void AddMapping()
    {
        NavigationManager.NavigateTo("/configuration/mapping/edit");
    }

    private void EditMapping(int id)
    {
        NavigationManager.NavigateTo($"/configuration/mapping/edit/{id}");
    }

    private async Task DeleteMapping(int id)
    {
        try
        {
            using var dbContext = await DbContextFactory.CreateDbContextAsync();
            var mapping = await dbContext.ModelProviderMappings.FindAsync(id);
            if (mapping == null)
            {
                Logger.LogError("No mapping found with ID {Id}", id);
                return;
            }

            dbContext.ModelProviderMappings.Remove(mapping);
            await dbContext.SaveChangesAsync();
            
            await LoadModelMappingsAsync();
            Snackbar.Add("Model mapping deleted successfully", Severity.Success);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error deleting mapping");
            Snackbar.Add($"Error deleting mapping: {ex.Message}", Severity.Error);
        }
    }

    private async Task LaunchGuidedSetup(string providerName) 
    {
        if (guidedSetupWizardInstance != null)
        {
             await guidedSetupWizardInstance.OpenForProvider(providerName); 
        }
        else
        {
             Logger.LogError("GuidedSetupWizard instance reference is null when trying to launch setup.");
             Snackbar.Add("Error launching guided setup", Severity.Error);
         }
    }

    private async Task HandleSetupComplete(ConduitLLM.Configuration.Entities.ProviderCredential newProvider) 
    {
        try
        {
            using var dbContext = await DbContextFactory.CreateDbContextAsync(); 
            await dbContext.ProviderCredentials.AddAsync(newProvider);
            await dbContext.SaveChangesAsync();

            await LoadProvidersAsync();
            await LoadModelMappingsAsync();
            
            Snackbar.Add($"Provider '{newProvider.ProviderName}' added successfully", Severity.Success);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error saving provider from guided setup");
            deleteErrorMessage = $"Error saving provider: {ex.Message}";
            StateHasChanged();
        }
    }

    private string GetProviderDescription(string provider)
    {
        return provider switch
        {
            "OpenAI" => "Connect to GPT-3.5, GPT-4, and other OpenAI models",
            "Anthropic" => "Connect to Claude models for advanced reasoning",
            "Cohere" => "Connect to Cohere's command models",
            "Google" => "Connect to Google AI models like Gemini",
            "Mistral" => "Connect to Mistral AI's models",
            "Groq" => "Connect to models running on Groq's LPU Inference Engine for high speed",
            "HuggingFace" => "Access models hosted on Hugging Face Inference Endpoints",
            "AWS" => "Connect to models via AWS Bedrock or SageMaker (Requires Base URL)",
            "Azure" => "Connect to models deployed on Azure OpenAI Service (Requires Base URL)",
            "OpenRouter" => "Route requests to various models through OpenRouter",
            "Cerebras" => "Connect to models running on Cerebras infrastructure",
            _ => "Connect to AI models through this provider"
        };
    }

    // --- Mapping form state ---
    private async Task HandleEditMapping(int id)
    {
        using var dbContext = await DbContextFactory.CreateDbContextAsync();
        
        var mapping = await dbContext.ModelProviderMappings
            .Include(m => m.ProviderCredential)
            .FirstOrDefaultAsync(m => m.Id == id);
            
        if (mapping != null)
        {
            currentMapping = new ConduitLLM.Configuration.ModelProviderMapping
            {
                ModelAlias = mapping.ModelAlias,
                ProviderName = mapping.ProviderCredential.ProviderName,
                ProviderModelId = mapping.ProviderModelName
            };
            isEditingMapping = true;
            mappingErrorMessage = null;
        }
    }

    private async Task SaveMapping()
    {
        mappingErrorMessage = null;

        if (string.IsNullOrWhiteSpace(currentMapping.ModelAlias))
        {
            mappingErrorMessage = "Model alias is required";
            return;
        }

        if (string.IsNullOrWhiteSpace(currentMapping.ProviderName))
        {
            mappingErrorMessage = "Provider is required";
            return;
        }

        if (string.IsNullOrWhiteSpace(currentMapping.ProviderModelId))
        {
            mappingErrorMessage = "Provider model is required";
            return;
        }

        using var dbContext = await DbContextFactory.CreateDbContextAsync();
        
        var provider = await dbContext.ProviderCredentials
            .FirstOrDefaultAsync(p => p.ProviderName == currentMapping.ProviderName);
            
        if (provider == null)
        {
            mappingErrorMessage = $"Provider {currentMapping.ProviderName} not found. Please add this provider first.";
            return;
        }
        
        var existingMapping = await dbContext.ModelProviderMappings
            .Include(m => m.ProviderCredential)
            .FirstOrDefaultAsync(m => m.ModelAlias == currentMapping.ModelAlias && 
                                     !(m.ModelAlias == currentMapping.ModelAlias && 
                                       m.ProviderCredential.ProviderName == currentMapping.ProviderName && 
                                       m.ProviderModelName == currentMapping.ProviderModelId));
                                     
        if (existingMapping != null)
        {
            mappingErrorMessage = $"A mapping with alias '{currentMapping.ModelAlias}' already exists";
            return;
        }

        try
        {
            var mappingToUpdate = await dbContext.ModelProviderMappings
                .FirstOrDefaultAsync(m => m.ModelAlias == currentMapping.ModelAlias);
                
            if (mappingToUpdate != null)
            {
                dbContext.ModelProviderMappings.Remove(mappingToUpdate);
                await dbContext.SaveChangesAsync();
            }
            
            var newMapping = new ConduitLLM.Configuration.Entities.ModelProviderMapping
            {
                ModelAlias = currentMapping.ModelAlias,
                ProviderModelName = currentMapping.ProviderModelId,
                ProviderCredentialId = provider.Id,
                IsEnabled = true,
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow
            };
            
            dbContext.ModelProviderMappings.Add(newMapping);
            await dbContext.SaveChangesAsync();
            
            isEditingMapping = false;
            currentMapping = new ConduitLLM.Configuration.ModelProviderMapping 
            { 
                ModelAlias = "",
                ProviderName = "",
                ProviderModelId = ""
            };
            await LoadModelMappingsAsync();
            mappingErrorMessage = null;
            
            Snackbar.Add("Model mapping saved successfully", Severity.Success);
        }
        catch (Exception ex)
        {
            mappingErrorMessage = $"Error saving mapping: {ex.Message}";
            Logger.LogError(ex, "Error saving mapping");
        }
    }

    private async Task SaveProxyUrl()
    {
        try
        {
            using var dbContext = await DbContextFactory.CreateDbContextAsync(); 
            var proxyUrlSetting = await dbContext.GlobalSettings.FirstOrDefaultAsync(s => s.Key == "ConduitSettings:ProxyBaseUrl");
            
            if (proxyUrlSetting == null)
            {
                proxyUrlSetting = new ConduitLLM.Configuration.Entities.GlobalSetting { Key = "ConduitSettings:ProxyBaseUrl", Value = proxyBaseUrlInput ?? string.Empty }; 
                dbContext.GlobalSettings.Add(proxyUrlSetting);
            }
            else
            {
                proxyUrlSetting.Value = proxyBaseUrlInput ?? string.Empty;
                dbContext.GlobalSettings.Update(proxyUrlSetting);
            }
            
            await dbContext.SaveChangesAsync();
            
            Snackbar.Add("Base URL saved successfully", Severity.Success);
            proxyUrlSaveMessage = "Base URL saved successfully";
            await Task.Delay(3000); 
            proxyUrlSaveMessage = null;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            proxyUrlSaveMessage = $"Error saving URL: {ex.Message}";
            Snackbar.Add($"Error saving URL: {ex.Message}", Severity.Error);
        }
    }
    
    private async Task SaveHttpRetryOptions()
    {
        try
        {
            await HttpRetryService.UpdateRetryConfigurationAsync(httpRetryOptions);
            httpRetryOptionsSaveMessage = "HTTP retry settings saved successfully.";
            Snackbar.Add("HTTP retry settings saved successfully", Severity.Success);
        }
        catch (Exception ex)
        {
            httpRetryOptionsSaveMessage = $"Error saving settings: {ex.Message}";
            Snackbar.Add($"Error saving settings: {ex.Message}", Severity.Error);
        }
    }

    private async Task SaveHttpTimeoutOptions()
    {
        try
        {
            await HttpTimeoutService.UpdateTimeoutConfigurationAsync(httpTimeoutOptions);
            httpTimeoutOptionsSaveMessage = "HTTP timeout settings saved successfully.";
            Snackbar.Add("HTTP timeout settings saved successfully", Severity.Success);
        }
        catch (Exception ex)
        {
            httpTimeoutOptionsSaveMessage = $"Error saving settings: {ex.Message}";
            Snackbar.Add($"Error saving settings: {ex.Message}", Severity.Error);
        }
    }

    private async Task<bool> CheckIfProviderHasMappings(string providerName)
    {
        try
        {
            await using var dbContext = await DbContextFactory.CreateDbContextAsync();
            return await dbContext.ModelProviderMappings
                .Include(m => m.ProviderCredential)
                .AnyAsync(m => m.ProviderCredential.ProviderName == providerName);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error checking if provider has mappings");
            return false;
        }
    }
}