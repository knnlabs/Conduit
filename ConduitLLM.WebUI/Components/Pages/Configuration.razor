@page "/configuration"
@using System.Text.Json
@using Microsoft.EntityFrameworkCore
@using ConduitLLM.Configuration
@using ConduitLLM.Configuration.Entities
@using ConduitLLM.Providers.Configuration
@using ConduitLLM.WebUI.Services
@using Microsoft.Extensions.Logging
@using System.Collections.Generic
@using System.Linq
@using System.Threading.Tasks
@using Microsoft.JSInterop

@inject NavigationManager NavigationManager
@inject ILogger<Configuration> Logger
@inject IDbContextFactory<ConduitLLM.Configuration.ConfigurationDbContext> DbContextFactory
@inject ConfigurationChangeNotifier ConfigChangeNotifier
@inject HttpRetryConfigurationService HttpRetryService
@inject HttpTimeoutConfigurationService HttpTimeoutService
@inject IJSRuntime JSRuntime
@rendermode InteractiveServer

<h1>Configuration Management</h1>

@if (!string.IsNullOrEmpty(deleteErrorMessage))
{
    <div class="alert alert-danger mt-2">@deleteErrorMessage</div>
}

<div class="mb-4">
    <div class="d-flex justify-content-between align-items-center mb-3">
        <h2>LLM Providers</h2>
        <div>
            <button class="btn btn-primary" @onclick="AddProvider">
                <i class="bi bi-plus-lg me-1"></i> Add Provider
            </button>
            <div class="dropdown d-inline-block ms-2">
                <button class="btn btn-outline-primary dropdown-toggle" type="button" id="quickSetupDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                    <i class="bi bi-magic me-1"></i> Quick Setup
                </button>
                <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="quickSetupDropdown">
                    @foreach (var provider in _supportedProviders)
                    {
                        <li><button class="dropdown-item" @onclick="() => LaunchGuidedSetup(provider)">@provider</button></li>
                    }
                </ul>
            </div>
        </div>
    </div>

    @if (providerCredentials == null)
    {
        <p><em>Loading credentials...</em></p>
    }
    else if (!providerCredentials.Any())
    {
        <div class="alert alert-info">
            <i class="bi bi-info-circle me-2"></i>
            <span>No providers configured yet. Add an LLM provider to get started.</span>
        </div>

        <div class="row row-cols-1 row-cols-md-3 g-4 mt-2">
            @foreach (var provider in _supportedProviders)
            {
                <div class="col">
                    <div class="card h-100 provider-card">
                        <div class="card-body d-flex flex-column">
                            <h5 class="card-title">@provider</h5>
                            <p class="card-text flex-grow-1">
                                @GetProviderDescription(provider)
                            </p>
                            <button class="btn btn-outline-primary" @onclick="() => LaunchGuidedSetup(provider)">
                                <i class="bi bi-magic me-1"></i> Setup @provider
                            </button>
                        </div>
                    </div>
                </div>
            }
        </div>
    }
    else
    {
        <div class="table-responsive">
            <table class="table table-hover">
                <thead>
                    <tr>
                        <th>Provider</th>
                        @*<th>Name</th>*@ @* Removed Name column *@
                        <th>API Key</th>
                        <th>Base URL</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody>
                    @foreach (var cred in providerCredentials)
                    {
                        <tr>
                            <td>@cred.ProviderName</td>
                            <td class="text-muted">@(string.IsNullOrEmpty(cred.ApiKey) ? "Not set" : "••••••••")</td>
                            <td>@(string.IsNullOrEmpty(cred.BaseUrl) ? "Default" : cred.BaseUrl)</td>
                            <td>
                                <div class="btn-group">
                                    <button class="btn btn-sm btn-outline-primary" @onclick="() => EditProvider(cred.Id)">Edit</button>
                                    <button class="btn btn-sm btn-outline-danger" @onclick="() => DeleteProvider(cred.Id)">Delete</button>
                                </div>
                            </td>
                        </tr>
                    }
                </tbody>
            </table>
        </div>
    }
</div>

<hr />

<h2>Model Mappings</h2>

<p>
    Map user-friendly model names to specific provider models. For example, you can map "gpt4" to OpenAI's "gpt-4-turbo-preview" model.
</p>

<div class="mb-4">
    <h2>Model Mappings</h2>
    <p>Configure which provider models map to friendly model aliases in your app.</p>
    
    @if (modelMappings == null)
    {
        <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
    }
    else if (!modelMappings.Any())
    {
        <div class="alert alert-info">
            No model mappings defined yet. Add one below.
        </div>
    }
    else
    {
        <table class="table table-striped">
            <thead>
                <tr>
                    <th>Model Alias</th>
                    <th>Provider</th>
                    <th>Provider Model</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var mapping in modelMappings)
                {
                    <tr>
                        <td>@mapping.ModelAlias</td>
                        <td>@mapping.ProviderCredential?.ProviderName</td>
                        <td>@mapping.ProviderModelName</td>
                        <td>
                            <button class="btn btn-sm btn-primary" @onclick="() => HandleEditMapping(mapping.Id)">
                                <span class="bi bi-pencil" aria-hidden="true"></span> Edit
                            </button>
                            <button class="btn btn-sm btn-danger" @onclick="() => DeleteMapping(mapping.Id)">
                                <span class="bi bi-trash" aria-hidden="true"></span> Delete
                            </button>
                        </td>
                    </tr>
                }
            </tbody>
        </table>
    }
    
    <button class="btn btn-primary" @onclick="() => { isEditingMapping = true; currentMapping = new ConduitLLM.Configuration.ModelProviderMapping { ModelAlias = string.Empty, ProviderName = string.Empty, ProviderModelId = string.Empty }; mappingErrorMessage = null; }">
        <span class="bi bi-plus-circle" aria-hidden="true"></span> Add Model Mapping
    </button>
</div>

@if (isEditingMapping)
{
    <div class="card mt-3 shadow-sm">
        <div class="card-header">
            <h5 class="mb-0">@(currentMapping.ModelAlias == null ? "Add" : "Edit") Model Mapping</h5>
        </div>
        <div class="card-body">
            @if (!string.IsNullOrEmpty(mappingErrorMessage))
            {
                <div class="alert alert-danger">@mappingErrorMessage</div>
            }
            
            <div class="mb-3">
                <label for="modelAlias" class="form-label">Model Alias</label>
                <input id="modelAlias" type="text" class="form-control" @bind="currentMapping.ModelAlias" />
                <div class="form-text">The friendly name you'll use in your code (e.g., "gpt4", "claude-latest")</div>
            </div>
            
            <div class="mb-3">
                <label for="providerName" class="form-label">Provider</label>
                <select id="providerName" class="form-select" @bind="currentMapping.ProviderName">
                    <option value="">-- Select Provider --</option>
                    @if (providerCredentials != null)
                    {
                        @foreach (var provider in providerCredentials.OrderBy(p => p.ProviderName))
                        {
                            <option value="@provider.ProviderName">@provider.ProviderName</option>
                        }
                    }
                </select>
            </div>
            
            <div class="mb-3">
                <label for="providerModelId" class="form-label">Provider Model ID</label>
                <input id="providerModelId" type="text" class="form-control" @bind="currentMapping.ProviderModelId" />
                <div class="form-text">The actual model ID used by the provider (e.g., "gpt-4-turbo-preview", "claude-3-opus-20240229")</div>
            </div>
            
            <div class="d-flex gap-2 justify-content-end">
                <button type="button" class="btn btn-secondary" @onclick="() => isEditingMapping = false">Cancel</button>
                <button type="button" class="btn btn-primary" @onclick="SaveMapping">Save</button>
            </div>
        </div>
    </div>
}

<hr />

<h2>Global Settings</h2>

<div class="row">
    <div class="col-md-6">
        <div class="mb-3">
            <label for="proxyUrl" class="form-label">Conduit Proxy Base URL:</label>
            <div class="input-group mb-3">
                <input type="text" class="form-control" id="proxyUrl" @bind="proxyBaseUrlInput" placeholder="e.g., https://api.yourcompany.com/conduit" />
                <button class="btn btn-outline-primary" @onclick="SaveProxyUrl">Save</button>
            </div>
            @if (!string.IsNullOrEmpty(proxyUrlSaveMessage))
            {
                <div class="alert alert-success mt-2" role="alert">
                    @proxyUrlSaveMessage
                </div>
            }
            <div class="form-text text-muted">
                URL where your Conduit API is publicly accessible. Used for SDK clients.
            </div>
        </div>
    </div>
</div>

<div class="row">
    <div class="col-md-6">
        <div class="card mb-3">
            <div class="card-header">
                <h5 class="mb-0">HTTP Retry Settings</h5>
            </div>
            <div class="card-body">
                <div class="mb-3">
                    <label for="maxRetries" class="form-label">Maximum Retry Attempts</label>
                    <input type="number" class="form-control" id="maxRetries" 
                           @bind="httpRetryOptions.MaxRetries" min="0" max="10" />
                    <div class="form-text">
                        Maximum number of times to retry HTTP requests on transient failures (0-10).
                    </div>
                </div>
                <div class="mb-3">
                    <label for="initialDelay" class="form-label">Initial Delay (seconds)</label>
                    <input type="number" class="form-control" id="initialDelay" 
                           @bind="httpRetryOptions.InitialDelaySeconds" min="0" max="10" step="0.5" />
                    <div class="form-text">
                        Initial delay before first retry attempt.
                    </div>
                </div>
                <div class="mb-3">
                    <label for="maxDelay" class="form-label">Maximum Delay (seconds)</label>
                    <input type="number" class="form-control" id="maxDelay" 
                           @bind="httpRetryOptions.MaxDelaySeconds" min="1" max="60" />
                    <div class="form-text">
                        Maximum delay cap for any retry attempt.
                    </div>
                </div>
                <div class="form-check mb-3">
                    <input class="form-check-input" type="checkbox" id="enableRetryLogging" 
                           @bind="httpRetryOptions.EnableRetryLogging" />
                    <label class="form-check-label" for="enableRetryLogging">
                        Enable Retry Logging
                    </label>
                    <div class="form-text">
                        Log detailed information about retry attempts.
                    </div>
                </div>
                <button class="btn btn-primary" @onclick="SaveHttpRetryOptions">
                    <i class="bi bi-save me-1"></i> Save Retry Settings
                </button>
                @if (!string.IsNullOrEmpty(httpRetryOptionsSaveMessage))
                {
                    <div class="alert alert-success mt-2" role="alert">
                        @httpRetryOptionsSaveMessage
                    </div>
                }
            </div>
        </div>
    </div>
    
    <div class="col-md-6">
        <div class="card mb-3">
            <div class="card-header">
                <h5 class="mb-0">HTTP Timeout Settings</h5>
            </div>
            <div class="card-body">
                <div class="mb-3">
                    <label for="timeoutSeconds" class="form-label">Timeout Duration (seconds)</label>
                    <input type="number" class="form-control" id="timeoutSeconds" 
                           @bind="httpTimeoutOptions.TimeoutSeconds" min="10" max="600" />
                    <div class="form-text">
                        Maximum time to wait for HTTP requests to complete before timing out (10-600 seconds).
                    </div>
                </div>
                <div class="form-check mb-3">
                    <input class="form-check-input" type="checkbox" id="enableTimeoutLogging" 
                           @bind="httpTimeoutOptions.EnableTimeoutLogging" />
                    <label class="form-check-label" for="enableTimeoutLogging">
                        Enable Timeout Logging
                    </label>
                    <div class="form-text">
                        Log detailed information about request timeouts.
                    </div>
                </div>
                <button class="btn btn-primary" @onclick="SaveHttpTimeoutOptions">
                    <i class="bi bi-save me-1"></i> Save Timeout Settings
                </button>
                @if (!string.IsNullOrEmpty(httpTimeoutOptionsSaveMessage))
                {
                    <div class="alert alert-success mt-2" role="alert">
                        @httpTimeoutOptionsSaveMessage
                    </div>
                }
            </div>
        </div>
    </div>
</div>

<div class="row">
    <div class="col-md-6">
        <div class="card mb-3">
            <div class="card-header">
                <h5 class="mb-0">About HTTP Client Settings</h5>
            </div>
            <div class="card-body">
                <p>
                    These settings control how ConduitLLM handles retry logic when communicating with LLM provider APIs.
                </p>
                <ul>
                    <li>
                        <strong>Maximum Retry Attempts</strong>: Number of times the system will retry failed API calls that encounter transient errors (such as network issues or rate limiting).
                    </li>
                    <li>
                        <strong>Initial Delay</strong>: How long to wait before the first retry attempt. Subsequent retries use exponential backoff with jitter.
                    </li>
                    <li>
                        <strong>Maximum Delay</strong>: The maximum time to wait between retry attempts, regardless of the backoff calculation.
                    </li>
                    <li>
                        <strong>Enable Retry Logging</strong>: When enabled, detailed logs will be generated for each retry attempt, helping with troubleshooting.
                    </li>
                </ul>
                <div class="alert alert-info">
                    <i class="bi bi-info-circle me-2"></i>
                    These settings apply to all provider clients and provide resilience against temporary API outages and rate limiting.
                </div>
            </div>
        </div>
    </div>
    <div class="col-md-6">
        <div class="card mb-3">
            <div class="card-header">
                <h5 class="mb-0">About HTTP Timeout Settings</h5>
            </div>
            <div class="card-body">
                <p>
                    These settings control how ConduitLLM handles timeouts when communicating with LLM provider APIs.
                </p>
                <ul>
                    <li>
                        <strong>Timeout Duration</strong>: Maximum time to wait for HTTP requests to complete before timing out.
                    </li>
                    <li>
                        <strong>Enable Timeout Logging</strong>: When enabled, detailed logs will be generated for each request timeout, helping with troubleshooting.
                    </li>
                </ul>
                <div class="alert alert-info">
                    <i class="bi bi-info-circle me-2"></i>
                    These settings apply to all provider clients and provide resilience against slow or unresponsive APIs.
                </div>
            </div>
        </div>
    </div>
</div>

@* Guided Setup Modal Components *@
<GuidedSetupWizard
    @ref="guidedSetupWizardInstance"
    IsOpen="isGuidedSetupOpen"
    OnSetupComplete="HandleSetupComplete"
    IsOpenChanged="(value) => { isGuidedSetupOpen = value; StateHasChanged(); }" />

@code {
    // --- Providers and Mappings State ---
    private List<ConduitLLM.Configuration.Entities.ProviderCredential> providerCredentials = new();
    private List<ConduitLLM.Configuration.Entities.ModelProviderMapping> modelMappings = new();
    private List<ConduitLLM.Configuration.Entities.GlobalSetting> globalSettings = new();

    // Provider form state
    private ConduitLLM.Configuration.Entities.ProviderCredential currentProvider = new();

    // Mapping form state
    private bool isEditingMapping = false;
    private ConduitLLM.Configuration.ModelProviderMapping currentMapping = new() 
    { 
        ModelAlias = "",
        ProviderName = "",
        ProviderModelId = ""
    };
    private string? mappingErrorMessage;

    // Settings state
    private ConduitLLM.Configuration.Entities.GlobalSetting currentSettings = new();
    
    // HTTP options state
    private string? proxyBaseUrlInput;
    private string? proxyUrlSaveMessage;
    private string? httpRetryOptionsSaveMessage;
    private string? httpTimeoutOptionsSaveMessage;
    private ConduitLLM.Providers.Configuration.RetryOptions httpRetryOptions = new();
    private ConduitLLM.Providers.Configuration.TimeoutOptions httpTimeoutOptions = new();
    
    // --- Guided Setup State ---
    private GuidedSetupWizard? guidedSetupWizardInstance;
    private bool isGuidedSetupOpen;
    private string? deleteErrorMessage;
    
    private readonly List<string> _supportedProviders = new List<string> {
        "OpenAI", "Anthropic", "Cohere", "Google", "Mistral", "Groq", "HuggingFace", "AWS", "Azure", "OpenRouter"
    };
    
    protected override async Task OnInitializedAsync()
    {
        try
        {
            await LoadProvidersAsync();
            await LoadModelMappingsAsync();
            await LoadProxyUrlAsync();
            await LoadHttpRetryOptionsAsync();
            await LoadHttpTimeoutOptionsAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error initializing Configuration page");
        }
    }
    
    // --- Settings Loading Methods ---
    
    private async Task LoadProvidersAsync()
    {
        try
        {
            using var dbContext = await DbContextFactory.CreateDbContextAsync(); 
            providerCredentials = await dbContext.ProviderCredentials.ToListAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading provider credentials");
            providerCredentials = new List<ConduitLLM.Configuration.Entities.ProviderCredential>(); 
        }
    }
    
    private async Task LoadModelMappingsAsync()
    {
        try
        {
            using var dbContext = await DbContextFactory.CreateDbContextAsync(); 
            modelMappings = await dbContext.ModelProviderMappings
                .Include(m => m.ProviderCredential)
                .OrderBy(m => m.ModelAlias)
                .ToListAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading model mappings");
            modelMappings = new List<ConduitLLM.Configuration.Entities.ModelProviderMapping>();
        }
    }
    
    private async Task LoadProxyUrlAsync()
    {
        try
        {
            using var dbContext = await DbContextFactory.CreateDbContextAsync(); 
            var proxyUrlSetting = await dbContext.GlobalSettings.FirstOrDefaultAsync(s => s.Key == "ConduitSettings:ProxyBaseUrl");
            proxyBaseUrlInput = proxyUrlSetting?.Value;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading proxy URL setting");
        }
    }
    
    private async Task LoadHttpRetryOptionsAsync()
    {
        httpRetryOptions = HttpRetryService.GetRetryConfiguration() ?? new ConduitLLM.Providers.Configuration.RetryOptions();
        await Task.CompletedTask;
    }
    
    private async Task LoadHttpTimeoutOptionsAsync()
    {
        httpTimeoutOptions = HttpTimeoutService.GetTimeoutConfiguration() ?? new ConduitLLM.Providers.Configuration.TimeoutOptions();
        await Task.CompletedTask;
    }
    
    // --- Provider/Mapping Methods ---
    
    private void AddProvider()
    {
        NavigationManager.NavigateTo("/configuration/provider/edit");
    }

    private void EditProvider(int id)
    {
        NavigationManager.NavigateTo($"/configuration/provider/edit/{id}");
    }

    private async Task DeleteProvider(int id)
    {
        try
        {
            deleteErrorMessage = null;
            using var dbContext = await DbContextFactory.CreateDbContextAsync(); 
            var providerToDelete = await dbContext.ProviderCredentials.FindAsync(id);
            if (providerToDelete == null) return;

            bool confirmed = await JSRuntime.InvokeAsync<bool>("confirm",
                $"Are you sure you want to delete the provider '{providerToDelete.ProviderName}'? This cannot be undone.");

            if (!confirmed) return;

            var relatedMappings = await dbContext.ModelProviderMappings
                .Where(m => m.ProviderCredentialId == providerToDelete.Id)
                .ToListAsync();

            if (relatedMappings.Any())
            {
                dbContext.ModelProviderMappings.RemoveRange(relatedMappings);
            }

            dbContext.ProviderCredentials.Remove(providerToDelete);
            await dbContext.SaveChangesAsync(); 

            await LoadProvidersAsync(); 
            await LoadModelMappingsAsync(); 
        }
        catch (Exception ex)
        {
            deleteErrorMessage = $"Error deleting provider: {ex.Message}";
            Logger.LogError(ex, "Error deleting provider");
            StateHasChanged();
        }
    }

    private void AddMapping()
    {
        NavigationManager.NavigateTo("/configuration/mapping/edit");
    }

    private void EditMapping(int id)
    {
        NavigationManager.NavigateTo($"/configuration/mapping/edit/{id}");
    }

    private async Task DeleteMapping(int id)
    {
        try
        {
            using var dbContext = await DbContextFactory.CreateDbContextAsync();
            var mapping = await dbContext.ModelProviderMappings.FindAsync(id);
            if (mapping == null)
            {
                Logger.LogError("No mapping found with ID {Id}", id);
                return;
            }

            dbContext.ModelProviderMappings.Remove(mapping);
            await dbContext.SaveChangesAsync();
            
            await LoadModelMappingsAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error deleting mapping");
        }
    }

    private async Task LaunchGuidedSetup(string providerName) 
    {
        if (guidedSetupWizardInstance != null)
        {
             await guidedSetupWizardInstance.OpenForProvider(providerName); 
        }
        else
        {
             Logger.LogError("GuidedSetupWizard instance reference is null when trying to launch setup.");
         }
    }

    private async Task HandleSetupComplete(ConduitLLM.Configuration.Entities.ProviderCredential newProvider) 
    {
        try
        {
            using var dbContext = await DbContextFactory.CreateDbContextAsync(); 
            await dbContext.ProviderCredentials.AddAsync(newProvider);
            await dbContext.SaveChangesAsync();

            await LoadProvidersAsync();
            await LoadModelMappingsAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error saving provider from guided setup");
            deleteErrorMessage = $"Error saving provider: {ex.Message}";
            StateHasChanged();
        }
    }

    private string GetProviderDescription(string provider)
    {
        return provider switch
        {
            "OpenAI" => "Connect to GPT-3.5, GPT-4, and other OpenAI models",
            "Anthropic" => "Connect to Claude models for advanced reasoning",
            "Cohere" => "Connect to Command models for enterprise applications",
            "Google" => "Connect to Google's Gemini models for multimodal capabilities",
            "Mistral" => "Connect to Mistral AI for Mixtral and Le Chat models",
            "Groq" => "Connect to Groq for ultra-fast inference on Llama/Mixtral",
            "HuggingFace" => "Connect to HuggingFace Hub for open-source models",
            "AWS" => "Connect to Amazon Bedrock for foundation models",
            "Azure" => "Connect to Azure Cognitive Services for enterprise-grade models",
            "OpenRouter" => "Connect to OpenRouter for access to multiple models through one API",
            _ => "Connect to AI models through this provider"
        };
    }

    // --- Mapping form state ---
    private async Task HandleEditMapping(int id)
    {
        using var dbContext = await DbContextFactory.CreateDbContextAsync();
        
        var mapping = await dbContext.ModelProviderMappings
            .Include(m => m.ProviderCredential)
            .FirstOrDefaultAsync(m => m.Id == id);
            
        if (mapping != null)
        {
            currentMapping = new ConduitLLM.Configuration.ModelProviderMapping
            {
                ModelAlias = mapping.ModelAlias,
                ProviderName = mapping.ProviderCredential.ProviderName,
                ProviderModelId = mapping.ProviderModelName
            };
            isEditingMapping = true;
            mappingErrorMessage = null;
        }
    }

    private async Task SaveMapping()
    {
        mappingErrorMessage = null;

        if (string.IsNullOrWhiteSpace(currentMapping.ModelAlias))
        {
            mappingErrorMessage = "Model alias is required";
            return;
        }

        if (string.IsNullOrWhiteSpace(currentMapping.ProviderName))
        {
            mappingErrorMessage = "Provider is required";
            return;
        }

        if (string.IsNullOrWhiteSpace(currentMapping.ProviderModelId))
        {
            mappingErrorMessage = "Provider model is required";
            return;
        }

        using var dbContext = await DbContextFactory.CreateDbContextAsync();
        
        var provider = await dbContext.ProviderCredentials
            .FirstOrDefaultAsync(p => p.ProviderName == currentMapping.ProviderName);
            
        if (provider == null)
        {
            mappingErrorMessage = $"Provider {currentMapping.ProviderName} not found. Please add this provider first.";
            return;
        }
        
        var existingMapping = await dbContext.ModelProviderMappings
            .Include(m => m.ProviderCredential)
            .FirstOrDefaultAsync(m => m.ModelAlias == currentMapping.ModelAlias && 
                                     !(m.ModelAlias == currentMapping.ModelAlias && 
                                       m.ProviderCredential.ProviderName == currentMapping.ProviderName && 
                                       m.ProviderModelName == currentMapping.ProviderModelId));
                                     
        if (existingMapping != null)
        {
            mappingErrorMessage = $"A mapping with alias '{currentMapping.ModelAlias}' already exists";
            return;
        }

        try
        {
            var mappingToUpdate = await dbContext.ModelProviderMappings
                .FirstOrDefaultAsync(m => m.ModelAlias == currentMapping.ModelAlias);
                
            if (mappingToUpdate != null)
            {
                dbContext.ModelProviderMappings.Remove(mappingToUpdate);
                await dbContext.SaveChangesAsync();
            }
            
            var newMapping = new ConduitLLM.Configuration.Entities.ModelProviderMapping
            {
                ModelAlias = currentMapping.ModelAlias,
                ProviderModelName = currentMapping.ProviderModelId,
                ProviderCredentialId = provider.Id,
                IsEnabled = true,
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow
            };
            
            dbContext.ModelProviderMappings.Add(newMapping);
            await dbContext.SaveChangesAsync();
            
            isEditingMapping = false;
            currentMapping = new ConduitLLM.Configuration.ModelProviderMapping 
            { 
                ModelAlias = "",
                ProviderName = "",
                ProviderModelId = ""
            };
            await LoadModelMappingsAsync();
            mappingErrorMessage = null;
        }
        catch (Exception ex)
        {
            mappingErrorMessage = $"Error saving mapping: {ex.Message}";
            Console.Error.WriteLine($"Error saving mapping: {ex.Message}");
        }
    }

    private async Task SaveProxyUrl()
    {
        try
        {
            using var dbContext = await DbContextFactory.CreateDbContextAsync(); 
            var proxyUrlSetting = await dbContext.GlobalSettings.FirstOrDefaultAsync(s => s.Key == "ConduitSettings:ProxyBaseUrl");
            
            if (proxyUrlSetting == null)
            {
                proxyUrlSetting = new ConduitLLM.Configuration.Entities.GlobalSetting { Key = "ConduitSettings:ProxyBaseUrl", Value = proxyBaseUrlInput ?? string.Empty }; 
                dbContext.GlobalSettings.Add(proxyUrlSetting);
            }
            else
            {
                proxyUrlSetting.Value = proxyBaseUrlInput ?? string.Empty;
                dbContext.GlobalSettings.Update(proxyUrlSetting);
            }
            
            await dbContext.SaveChangesAsync();
            
            proxyUrlSaveMessage = "Base URL saved successfully.";
            await Task.Delay(3000); 
            proxyUrlSaveMessage = null;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            proxyUrlSaveMessage = $"Error saving URL: {ex.Message}";
        }
    }
    
    private void SaveHttpRetryOptions()
    {
        try
        {
            httpRetryOptionsSaveMessage = null;
            httpRetryOptionsSaveMessage = "HTTP retry settings saved successfully.";
        }
        catch (Exception ex)
        {
            httpRetryOptionsSaveMessage = $"Error saving settings: {ex.Message}";
        }
    }

    private void SaveHttpTimeoutOptions()
    {
        try
        {
            httpTimeoutOptionsSaveMessage = null;
            httpTimeoutOptionsSaveMessage = "HTTP timeout settings saved successfully.";
        }
        catch (Exception ex)
        {
            httpTimeoutOptionsSaveMessage = $"Error saving settings: {ex.Message}";
        }
    }

    private async Task<bool> CheckIfProviderHasMappings(string providerName)
    {
        try
        {
            await using var dbContext = await DbContextFactory.CreateDbContextAsync();
            return await dbContext.ModelProviderMappings
                .Include(m => m.ProviderCredential)
                .AnyAsync(m => m.ProviderCredential.ProviderName == providerName);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error checking if provider has mappings");
            return false;
        }
    }
}
