@page "/configuration/mapping/edit"
@page "/configuration/mapping/edit/{id:int}"
@using Microsoft.EntityFrameworkCore
@using Microsoft.Extensions.Caching.Memory
@using System.ComponentModel.DataAnnotations
@using ConduitLLM.Configuration
@using ConduitLLM.Configuration.Entities
@using ConduitLLM.WebUI.Services
@using System.Text.Json
@using System.Net.Http
@using System.Net.Http.Headers
@using Microsoft.Extensions.Logging

@inject IDbContextFactory<ConduitLLM.Configuration.ConfigurationDbContext> DbContextFactory
@inject NavigationManager NavigationManager
@inject ILogger<MappingEdit> _logger
@inject IMemoryCache MemoryCache
@inject ConfigurationChangeNotifier ConfigChangeNotifier
@inject IHttpClientFactory HttpClientFactory
@inject VirtualKeyService VirtualKeyService
@rendermode InteractiveServer

<MudText Typo="Typo.h3" Class="mb-4">@(Id.HasValue ? "Edit Mapping" : "Add Mapping")</MudText>

@if (isLoadingPage)
{
    <MudProgressCircular Color="Color.Primary" Indeterminate="true" />
}
else if (Id.HasValue && dtoMapping == null)
{
    <MudAlert Severity="Severity.Error">Mapping not found or error loading.</MudAlert>
}
else
{
    <EditForm EditContext="editContext" OnValidSubmit="HandleValidSubmit" FormName="MappingForm"> @* Capture EditContext *@
        <DataAnnotationsValidator />
        @* Keep ValidationSummary for other potential errors *@
        <ValidationSummary />

        @* Display general errors above the form *@
        @if (!string.IsNullOrEmpty(errorMessage))
        {
            <MudAlert Severity="Severity.Error" Class="mb-4">@errorMessage</MudAlert>
        }

        <MudPaper Elevation="2" Class="pa-4 mb-4">
            <MudTextField 
                T="string" 
                Label="Model Alias" 
                @bind-Value="dtoMapping.ModelAlias" 
                For="@(() => dtoMapping.ModelAlias)"
                Variant="Variant.Outlined"
                Class="mb-4" />

            @if (availableProviders == null)
            {
                <MudProgressCircular Size="Size.Small" Indeterminate="true" />
                <MudText Class="ml-2">Loading providers...</MudText>
            }
            else
            {
                <MudSelect 
                    T="string" 
                    Label="Provider Name" 
                    Value="dtoMapping.ProviderName"
                    For="@(() => dtoMapping.ProviderName)"
                    Variant="Variant.Outlined"
                    Class="mb-4" 
                    ValueChanged="@(async (string val) => await ProviderSelectedAsync(val))">
                    <MudSelectItem Value="@("")">-- Select Provider --</MudSelectItem>
                    @foreach (var provider in availableProviders)
                    {
                        <MudSelectItem Value="@provider.ProviderName">@provider.ProviderName</MudSelectItem>
                    }
                </MudSelect>
            }

            <div class="d-flex align-center gap-2 mb-4">
                <div class="flex-grow-1">
                    <MudSelect T="string" 
                              Label="Provider Model ID" 
                              Value="dtoMapping.ProviderModelId"
                              For="@(() => dtoMapping.ProviderModelId)"
                              Variant="Variant.Outlined"
                              Disabled="@(isLoadingModels || string.IsNullOrEmpty(dtoMapping.ProviderName))"
                              ValueChanged="@((string val) => ProviderModelSelected(val))">
                        @if (isLoadingModels)
                        {
                            <MudSelectItem Disabled="true" Value="@string.Empty">
                                <div class="d-flex align-center">
                                    <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                                    Loading models...
                                </div>
                            </MudSelectItem>
                        }
                        else if (providerModels == null || !providerModels.Any())
                        {
                            <MudSelectItem Disabled="true" Value="@string.Empty">
                                @(string.IsNullOrEmpty(dtoMapping.ProviderName) ? "Select provider first" : "No models found or error")
                            </MudSelectItem>
                        }
                        else
                        {
                            <MudSelectItem Value="@string.Empty">-- Select Model --</MudSelectItem>
                            @foreach (var modelId in providerModels.OrderBy(m => m))
                            {
                                <MudSelectItem Value="@modelId">@modelId</MudSelectItem>
                            }
                        }
                    </MudSelect>
                    @if (!string.IsNullOrEmpty(modelLoadErrorMessage))
                    {
                        <MudText Typo="Typo.caption" Color="Color.Error" Class="mt-1">@modelLoadErrorMessage</MudText>
                    }
                </div>
                <MudButton 
                    Variant="Variant.Filled" 
                    Color="Color.Primary"
                    OnClick="@(() => RefreshModels(true))"
                    Disabled="@(isLoadingModels || string.IsNullOrEmpty(dtoMapping.ProviderName))"
                    StartIcon="@Icons.Material.Filled.Refresh"
                    Style="margin-top: 6px;">
                    @if (isLoadingModels)
                    {
                        <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                        <span class="d-none d-sm-inline">Loading...</span>
                    }
                    else
                    {
                        <span class="d-none d-sm-inline">Refresh Models</span>
                    }
                </MudButton>
            </div>

        </MudPaper>
            
        <div class="d-flex gap-2 mt-4">
            <MudButton 
                ButtonType="ButtonType.Submit" 
                Variant="Variant.Filled" 
                Color="Color.Primary" 
                Disabled="@isSaving"
                StartIcon="@Icons.Material.Filled.Save">
                @if (isSaving)
                {
                    <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                    <span>Saving...</span>
                }
                else
                {
                    <span>Save Mapping</span>
                }
            </MudButton>
            
            <MudButton 
                Variant="Variant.Outlined" 
                Color="Color.Secondary" 
                OnClick="Cancel" 
                Disabled="@isSaving">
                Cancel
            </MudButton>
        </div>

        @* General error message moved above the form *@
    </EditForm>
}

@code {
    [Parameter]
    public int? Id { get; set; }
    
    private ConduitLLM.Configuration.ModelProviderMapping dtoMapping = new() 
    { 
        ModelAlias = "",
        ProviderName = "",
        ProviderModelId = ""
    };
    
    private List<ConduitLLM.Configuration.Entities.ProviderCredential> availableProviders = new();
    private List<string> providerModels = new();
    private string? errorMessage; // General errors displayed at the form level
    private string? modelLoadErrorMessage; // Specific error for model loading
    private bool isLoadingModels = false; // Loading provider-specific models
    private bool isLoadingPage = true;
    private EditContext? editContext;
    private ValidationMessageStore? messageStore;
    private bool isSaving = false; // Saving the mapping

    protected override async Task OnInitializedAsync()
    {
        try
        {
            // Load available providers (from Config context)
            await using var dbContext = await DbContextFactory.CreateDbContextAsync(); 
            availableProviders = await dbContext.ProviderCredentials.ToListAsync();
            
            if (Id.HasValue) // Editing existing
            {
                var entityMapping = await dbContext.ModelProviderMappings
                    .Include(m => m.ProviderCredential)
                    .FirstOrDefaultAsync(m => m.Id == Id.Value);
                
                if (entityMapping != null)
                {
                    // Convert from entity to DTO
                    dtoMapping = new ConduitLLM.Configuration.ModelProviderMapping
                    {
                        ModelAlias = entityMapping.ModelAlias,
                        ProviderName = entityMapping.ProviderCredential?.ProviderName ?? "",
                        ProviderModelId = entityMapping.ProviderModelName ?? ""
                    };
                    
                    // Load provider models for the selected provider
                    if (!string.IsNullOrEmpty(dtoMapping.ProviderName))
                    {
                        await LoadProviderModelsAsync(dtoMapping.ProviderName);
                    }
                }
                else
                {
                    NavigationManager.NavigateTo("/configuration");
                }
            }
            else
            {
                dtoMapping = new ConduitLLM.Configuration.ModelProviderMapping
                {
                    ModelAlias = "",
                    ProviderName = "",
                    ProviderModelId = ""
                };
            }

            // Initialize EditContext with validation support
            editContext = new EditContext(dtoMapping);
            messageStore = new ValidationMessageStore(editContext);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error initializing mapping editor");
            errorMessage = ex.Message;
        }
        finally
        {
            isLoadingPage = false;
        }
    }

    private async Task LoadProviderModelsAsync(string providerName)
    {
        isLoadingModels = true;
        providerModels.Clear();
        modelLoadErrorMessage = null;
        StateHasChanged();

        try
        {
            // First check if we have a valid credential for this provider
            await using var dbContext = await DbContextFactory.CreateDbContextAsync();
            var provider = await dbContext.ProviderCredentials
                .FirstOrDefaultAsync(p => p.ProviderName == providerName);
                
            if (provider == null)
            {
                modelLoadErrorMessage = $"Provider '{providerName}' not found in the database";
                return;
            }
            
            // Use cache key based on provider name and last updated timestamp to ensure refreshed data
            string cacheKey = $"provider_models_{providerName}_{provider.UpdatedAt:yyyyMMddHHmmss}";
            
            // Check if we already have these models cached and force refresh wasn't requested
            if (!MemoryCache.TryGetValue(cacheKey, out List<string>? cachedModels))
            {
                // No valid cache, load from API
                cachedModels = LoadModelsFromApi(provider);
                
                if (cachedModels != null && cachedModels.Any())
                {
                    // Cache for 1 hour (adjust as needed)
                    MemoryCache.Set(cacheKey, cachedModels, TimeSpan.FromHours(1));
                }
            }
            
            // Update the model list
            if (cachedModels != null)
            {
                providerModels.AddRange(cachedModels);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error loading provider models");
            modelLoadErrorMessage = $"Error: {ex.Message}";
        }
        finally
        {
            isLoadingModels = false;
            StateHasChanged();
        }
    }

    private List<string> LoadModelsFromApi(ProviderCredential provider)
    {
        try
        {
            // Create a client using the factory
            using var client = HttpClientFactory.CreateClient();
            
            // TODO: Replace with actual model list API endpoint and authentication
            // This is a placeholder - need to implement actual provider-specific API calls
            
            // Mock implementation - in a real application, use provider-specific API client logic
            return new List<string>
            {
                // Common model examples across various providers
                "gpt-4o",
                "gpt-4-turbo",
                "gpt-3.5-turbo",
                "claude-3-opus",
                "claude-3-sonnet",
                "claude-3-haiku",
                "gemini-pro",
                "mistral-large",
                "mistral-medium",
                "mistral-small",
                $"{provider.ProviderName.ToLower()}-default-model",
                "custom-model-1",
                "custom-model-2",
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error calling provider API");
            throw; // Rethrow to be handled by caller
        }
    }

    private async Task ProviderSelectedAsync(string selectedProvider)
    {
        if (string.IsNullOrEmpty(selectedProvider))
        {
            // Clear provider models if no provider selected
            providerModels.Clear();
            return;
        }
        
        if (selectedProvider != dtoMapping.ProviderName)
        {
            // Update the DTO and clear the model ID since provider changed
            dtoMapping.ProviderName = selectedProvider;
            dtoMapping.ProviderModelId = ""; // Reset model selection
            
            // Load models for the selected provider
            await LoadProviderModelsAsync(selectedProvider);
        }
    }

    private void ProviderModelSelected(string selectedModel)
    {
        dtoMapping.ProviderModelId = selectedModel ?? "";
    }

    private async Task RefreshModels(bool forceRefresh)
    {
        if (!string.IsNullOrEmpty(dtoMapping.ProviderName))
        {
            // Force clear cache by invalidating the provider credential
            if (forceRefresh)
            {
                // Clear cached models for this provider
                await using var dbContext = await DbContextFactory.CreateDbContextAsync();
                var provider = await dbContext.ProviderCredentials
                    .FirstOrDefaultAsync(p => p.ProviderName == dtoMapping.ProviderName);
                    
                if (provider != null)
                {
                    // Update the timestamp to force cache key change
                    provider.UpdatedAt = DateTime.UtcNow;
                    await dbContext.SaveChangesAsync();
                }
            }
            
            // Load fresh models
            await LoadProviderModelsAsync(dtoMapping.ProviderName);
        }
    }

    private async Task HandleValidSubmit()
    {
        // Clear previous validation errors
        messageStore?.Clear();
        errorMessage = null;
        isSaving = true;
        StateHasChanged();
        
        try
        {
            // Validate required fields
            if (string.IsNullOrWhiteSpace(dtoMapping.ModelAlias) || 
                string.IsNullOrWhiteSpace(dtoMapping.ProviderName) ||
                string.IsNullOrWhiteSpace(dtoMapping.ProviderModelId))
            {
                errorMessage = "All fields are required";
                return;
            }
            
            // Check if model alias already exists (from Config context) and it's not the current one
            await using var dbContext = await DbContextFactory.CreateDbContextAsync();
            
            var provider = await dbContext.ProviderCredentials
                .FirstOrDefaultAsync(p => p.ProviderName == dtoMapping.ProviderName);
                
            if (provider == null)
            {
                errorMessage = $"Provider '{dtoMapping.ProviderName}' not found.";
                return;
            }
            
            // Check if alias exists, excluding the current mapping if editing
            bool aliasExists = await dbContext.ModelProviderMappings
                .AnyAsync(m => m.ModelAlias == dtoMapping.ModelAlias && 
                         (Id == null || m.Id != Id.Value));

            if (aliasExists)
            {
                 // Add validation message specifically for the ModelAlias field
                 messageStore?.Add(() => dtoMapping.ModelAlias, $"Model alias '{dtoMapping.ModelAlias}' already exists.");
                 editContext?.NotifyValidationStateChanged(); // Trigger UI update for validation messages
                 return; // Stop processing
            }

            // --- Database Operations (on Config context) ---
            if (Id.HasValue) // Update
            {
                var existingMapping = await dbContext.ModelProviderMappings.FindAsync(Id.Value);
                if (existingMapping != null)
                {
                    existingMapping.ModelAlias = dtoMapping.ModelAlias;
                    existingMapping.ProviderCredentialId = provider.Id;
                    existingMapping.ProviderModelName = dtoMapping.ProviderModelId;
                    dbContext.ModelProviderMappings.Update(existingMapping);
                }
                else
                {
                    errorMessage = "Error: Mapping not found during update.";
                    StateHasChanged();
                    return;
                }
            }
            else // Add
            {
                var newMapping = new ConduitLLM.Configuration.Entities.ModelProviderMapping
                {
                    ModelAlias = dtoMapping.ModelAlias,
                    ProviderCredentialId = provider.Id,
                    ProviderModelName = dtoMapping.ProviderModelId,
                    IsEnabled = true,
                    CreatedAt = DateTime.UtcNow,
                    UpdatedAt = DateTime.UtcNow
                };
                dbContext.ModelProviderMappings.Add(newMapping);
            }

            await dbContext.SaveChangesAsync();
            
            // Notify the Conduit HTTP proxy about configuration changes
            try
            {
                // Get the proxy base URL from global settings (from Config context)
                var proxyUrlSetting = await dbContext.GlobalSettings
                    .FirstOrDefaultAsync(s => s.Key == "ConduitSettings:ProxyBaseUrl");
                
                string proxyUrl = proxyUrlSetting?.Value ?? "http://localhost:5000";
                
                bool notificationSuccess = await ConfigChangeNotifier.NotifyConfigurationChangedAsync(proxyUrl);
                if (!notificationSuccess)
                {
                    _logger.LogWarning("Failed to notify proxy server about configuration changes. The server may need to be restarted.");
                    // We still proceed with navigation even if notification fails
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error notifying proxy server about configuration changes");
                // We still proceed with navigation even if notification fails
            }
            
            NavigationManager.NavigateTo("/configuration"); // Redirect back to the list
        }
        catch (DbUpdateException dbEx)
        {
            errorMessage = $"Database error saving mapping: {dbEx.InnerException?.Message ?? dbEx.Message}";
            // StateHasChanged(); // EditContext changes trigger state update
        }
        catch (Exception ex)
        {
            errorMessage = $"Error saving mapping: {ex.Message}";
        }
        finally
        {
            isSaving = false; // Reset saving flag
            StateHasChanged(); // Let framework handle UI update
        }
    }

    private void Cancel()
    {
        NavigationManager.NavigateTo("/configuration");
    }
}

