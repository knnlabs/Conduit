import { useQuery } from '@tanstack/react-query';\nimport { withAdminClient } from '@/lib/client/adminClient';\nimport type {\n  CostDashboardDto,\n  CostTrendDto,\n  DateRange,\n  ProviderCost,\n  ModelUsage,\n  DailyCost,\n  DetailedCostDataDto,\n  CostTrendDataDto,\n} from './types';\n\nexport function useTimeRangeUtils(timeRange: string) {\n  // Calculate date range based on timeRange\n  const getDateRange = (): DateRange => {\n    const now = new Date();\n    const startDate = new Date();\n    \n    switch (timeRange) {\n      case '7d':\n        startDate.setDate(now.getDate() - 7);\n        break;\n      case '30d':\n        startDate.setDate(now.getDate() - 30);\n        break;\n      case '90d':\n        startDate.setDate(now.getDate() - 90);\n        break;\n      default:\n        startDate.setDate(now.getDate() - 30);\n    }\n    \n    return {\n      startDate: startDate.toISOString().split('T')[0],\n      endDate: now.toISOString().split('T')[0],\n    };\n  };\n\n  return { getDateRange };\n}\n\nexport function useCostData(timeRange: string) {\n  const { getDateRange } = useTimeRangeUtils(timeRange);\n\n  // Fetch cost summary from Admin SDK\n  const { \n    data: costSummary, \n    isLoading: isLoadingSummary, \n    error: summaryError, \n    refetch: refetchSummary \n  } = useQuery<CostDashboardDto>({\n    queryKey: ['cost-summary', timeRange],\n    queryFn: async () => {\n      const { startDate, endDate } = getDateRange();\n      return withAdminClient(client => \n        client.analytics.getCostSummary('daily', startDate, endDate)\n      );\n    },\n    refetchInterval: 300000, // Refresh every 5 minutes\n  });\n\n  // Fetch cost trends from Admin SDK\n  const { \n    data: costTrends, \n    isLoading: isLoadingTrends, \n    error: trendsError, \n    refetch: refetchTrends \n  } = useQuery<CostTrendDto>({\n    queryKey: ['cost-trends', timeRange],\n    queryFn: async () => {\n      const { startDate, endDate } = getDateRange();\n      return withAdminClient(client => \n        client.analytics.getCostTrends('daily', startDate, endDate)\n      );\n    },\n    refetchInterval: 300000, // Refresh every 5 minutes\n  });\n\n  const isLoading = isLoadingSummary || isLoadingTrends;\n  const error = summaryError ?? trendsError;\n\n  return {\n    costSummary,\n    costTrends,\n    isLoading,\n    error,\n    refetch: async () => {\n      await Promise.all([refetchSummary(), refetchTrends()]);\n    },\n    getDateRange,\n  };\n}\n\nexport function useTransformedData(costSummary: CostDashboardDto | undefined, costTrends: CostTrendDto | undefined, timeRange: string) {\n  // Calculate derived metrics\n  const totalSpend = costSummary?.totalCost ?? 0;\n  const last7DaysCost = costSummary?.last7DaysCost ?? 0;\n  const last30DaysCost = costSummary?.last30DaysCost ?? 0;\n  \n  // Calculate average daily cost based on the time range\n  let daysInRange: number;\n  if (timeRange === '7d') {\n    daysInRange = 7;\n  } else if (timeRange === '30d') {\n    daysInRange = 30;\n  } else {\n    daysInRange = 90;\n  }\n  const averageDailyCost = totalSpend / daysInRange;\n  \n  // Calculate projected monthly spend\n  const daysInMonth = 30;\n  const projectedMonthlySpend = averageDailyCost * daysInMonth;\n  \n  // Calculate trend (comparing last 7 days to previous 7 days)\n  const projectedTrend = last7DaysCost > 0 && last30DaysCost > 0\n    ? ((last7DaysCost - (last30DaysCost - last7DaysCost) / 3) / ((last30DaysCost - last7DaysCost) / 3)) * 100\n    : 0;\n\n  // Transform provider costs\n  const providerCosts: ProviderCost[] = costSummary?.topProvidersBySpend?.map((provider: DetailedCostDataDto) => ({\n    provider: provider.name,\n    cost: provider.cost,\n    usage: provider.percentage,\n    trend: 0, // Trend calculation would require historical data\n  })) ?? [];\n\n  // Transform model usage\n  const modelUsage: ModelUsage[] = costSummary?.topModelsBySpend?.map((model: DetailedCostDataDto) => ({\n    model: model.name,\n    provider: model.name.includes('/') ? model.name.split('/')[0] : 'unknown',\n    requests: model.requestCount,\n    tokensIn: 0, // Not available in cost summary\n    tokensOut: 0, // Not available in cost summary\n    cost: model.cost,\n  })) ?? [];\n\n  // Transform daily costs from trends - flatten providers for chart compatibility\n  const dailyCosts: DailyCost[] = costTrends?.data?.map((trend: CostTrendDataDto) => {\n    const result: DailyCost = {\n      date: trend.date,\n      cost: trend.cost,\n    };\n    \n    // Add provider costs as separate fields for chart compatibility\n    costSummary?.topProvidersBySpend?.forEach((provider: DetailedCostDataDto) => {\n      result[provider.name] = (trend.cost * provider.percentage) / 100;\n    });\n\n    return result;\n  }) ?? [];\n\n  // Calculate budget utilization (if we had budget data)\n  const monthlyBudget: number | null = null; // Budget feature not yet implemented\n  const budgetUtilization = monthlyBudget !== null ? (projectedMonthlySpend / monthlyBudget) * 100 : null;\n  const isOverBudget = budgetUtilization !== null ? budgetUtilization > 100 : false;\n\n  return {\n    totalSpend,\n    last7DaysCost,\n    last30DaysCost,\n    averageDailyCost,\n    projectedMonthlySpend,\n    projectedTrend,\n    providerCosts,\n    modelUsage,\n    dailyCosts,\n    monthlyBudget,\n    budgetUtilization,\n    isOverBudget,\n  };\n}"