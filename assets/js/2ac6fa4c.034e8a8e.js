"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7075],{8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var a=t(6540);const s={},r=a.createContext(s);function o(e){const n=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),a.createElement(r.Provider,{value:n},e.children)}},9331:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"media/async-processing","title":"Async Processing","description":"Master asynchronous media generation with real-time updates, webhooks, and task management","source":"@site/docs/media/async-processing.md","sourceDirName":"media","slug":"/media/async-processing","permalink":"/Conduit/docs/media/async-processing","draft":false,"unlisted":false,"editUrl":"https://github.com/knnlabs/Conduit/tree/main/website/docs/media/async-processing.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Async Processing","description":"Master asynchronous media generation with real-time updates, webhooks, and task management"},"sidebar":"docsSidebar","previous":{"title":"Video Generation","permalink":"/Conduit/docs/media/video-generation"},"next":{"title":"Admin API Overview","permalink":"/Conduit/docs/admin/admin-api-overview"}}');var s=t(4848),r=t(8453);const o={sidebar_position:4,title:"Async Processing",description:"Master asynchronous media generation with real-time updates, webhooks, and task management"},i="Async Processing",l={},d=[{value:"Async Processing Overview",id:"async-processing-overview",level:2},{value:"Why Async Processing?",id:"why-async-processing",level:3},{value:"Task Lifecycle",id:"task-lifecycle",level:3},{value:"Basic Async Operations",id:"basic-async-operations",level:2},{value:"Starting Async Video Generation",id:"starting-async-video-generation",level:3},{value:"Checking Task Status",id:"checking-task-status",level:3},{value:"Polling for Completion",id:"polling-for-completion",level:3},{value:"Webhook Integration",id:"webhook-integration",level:2},{value:"Setting Up Webhook Endpoints",id:"setting-up-webhook-endpoints",level:3},{value:"Webhook Retry and Reliability",id:"webhook-retry-and-reliability",level:3},{value:"SignalR Real-Time Updates",id:"signalr-real-time-updates",level:2},{value:"Client-Side SignalR Integration",id:"client-side-signalr-integration",level:3},{value:"Advanced Task Management",id:"advanced-task-management",level:2},{value:"Task Queue Management",id:"task-queue-management",level:3},{value:"Error Handling and Recovery",id:"error-handling-and-recovery",level:2},{value:"Comprehensive Error Management",id:"comprehensive-error-management",level:3},{value:"Next Steps",id:"next-steps",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"async-processing",children:"Async Processing"})}),"\n",(0,s.jsx)(n.p,{children:"Conduit's async processing system handles long-running media generation tasks efficiently, providing real-time progress updates, reliable task management, and multiple notification methods to keep you informed throughout the generation process."}),"\n",(0,s.jsx)(n.h2,{id:"async-processing-overview",children:"Async Processing Overview"}),"\n",(0,s.jsx)(n.h3,{id:"why-async-processing",children:"Why Async Processing?"}),"\n",(0,s.jsx)(n.p,{children:"Media generation tasks can take anywhere from 30 seconds to 10 minutes depending on:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Model complexity"})," - DALL-E 3 vs. MiniMax Image"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Resolution"})," - Higher resolution = longer processing time"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Queue load"})," - Provider capacity and current demand"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Content complexity"})," - Detailed prompts may take longer"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"task-lifecycle",children:"Task Lifecycle"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Request \u2192 Validation \u2192 Queue \u2192 Processing \u2192 Storage \u2192 Notification\n    \u2193         \u2193         \u2193         \u2193          \u2193          \u2193\n  Task ID   Parameters  RabbitMQ  Provider    S3      Webhook/SignalR\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Task States:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"queued"})," - Task waiting for processing"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"processing"})," - Generation in progress"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"completed"})," - Generation successful"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"failed"})," - Generation failed"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"cancelled"})," - Task cancelled by user"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"basic-async-operations",children:"Basic Async Operations"}),"\n",(0,s.jsx)(n.h3,{id:"starting-async-video-generation",children:"Starting Async Video Generation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// Start async video generation\nconst response = await fetch('https://api.conduit.yourdomain.com/v1/videos/generations/async', {\n  method: 'POST',\n  headers: {\n    'Authorization': 'Bearer condt_your_virtual_key',\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify({\n    model: 'video-01',\n    prompt: 'A futuristic cityscape at sunset with flying cars',\n    resolution: '720x480',\n    webhook_url: 'https://yourapp.com/webhooks/conduit' // Optional\n  })\n});\n\nconst task = await response.json();\nconsole.log('Task started:', task.taskId);\nconsole.log('Estimated completion:', task.estimatedCompletionTime);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"checking-task-status",children:"Checking Task Status"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"async function checkTaskStatus(taskId) {\n  const response = await fetch(`https://api.conduit.yourdomain.com/v1/videos/generations/tasks/${taskId}`, {\n    headers: {\n      'Authorization': 'Bearer condt_your_virtual_key'\n    }\n  });\n\n  const task = await response.json();\n  \n  console.log('Task Status:', task.status);\n  console.log('Progress:', task.progress || 0);\n  \n  if (task.status === 'completed') {\n    console.log('Result:', task.videoResponse);\n    return task.videoResponse;\n  } else if (task.status === 'failed') {\n    console.log('Error:', task.error);\n    throw new Error(task.error);\n  }\n  \n  return null; // Still processing\n}\n\n// Usage\nconst result = await checkTaskStatus(task.taskId);\nif (result) {\n  console.log('Video URL:', result.data[0].url);\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"polling-for-completion",children:"Polling for Completion"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class TaskPoller {\n  constructor(apiKey, pollInterval = 2000) {\n    this.apiKey = apiKey;\n    this.pollInterval = pollInterval;\n    this.activeTasks = new Map();\n  }\n\n  async waitForCompletion(taskId, onProgress = null) {\n    return new Promise((resolve, reject) => {\n      const poll = async () => {\n        try {\n          const response = await fetch(`https://api.conduit.yourdomain.com/v1/tasks/${taskId}`, {\n            headers: {\n              'Authorization': `Bearer ${this.apiKey}`\n            }\n          });\n\n          const task = await response.json();\n          \n          // Call progress callback if provided\n          if (onProgress) {\n            onProgress(task);\n          }\n\n          switch (task.status) {\n            case 'completed':\n              this.activeTasks.delete(taskId);\n              resolve(task.result);\n              return;\n              \n            case 'failed':\n              this.activeTasks.delete(taskId);\n              reject(new Error(task.error));\n              return;\n              \n            case 'cancelled':\n              this.activeTasks.delete(taskId);\n              reject(new Error('Task was cancelled'));\n              return;\n              \n            default:\n              // Continue polling\n              setTimeout(poll, this.pollInterval);\n          }\n        } catch (error) {\n          console.error('Polling error:', error);\n          // Retry with exponential backoff\n          setTimeout(poll, this.pollInterval * 2);\n        }\n      };\n\n      this.activeTasks.set(taskId, { resolve, reject });\n      poll();\n    });\n  }\n\n  async waitForMultiple(taskIds, onProgress = null) {\n    const promises = taskIds.map(taskId => \n      this.waitForCompletion(taskId, onProgress)\n    );\n\n    try {\n      const results = await Promise.allSettled(promises);\n      \n      return results.map((result, index) => ({\n        taskId: taskIds[index],\n        success: result.status === 'fulfilled',\n        result: result.status === 'fulfilled' ? result.value : null,\n        error: result.status === 'rejected' ? result.reason.message : null\n      }));\n    } catch (error) {\n      throw new Error('Multiple task polling failed: ' + error.message);\n    }\n  }\n\n  cancelAllTasks() {\n    this.activeTasks.forEach(({ reject }, taskId) => {\n      reject(new Error('Polling cancelled'));\n    });\n    this.activeTasks.clear();\n  }\n}\n\n// Usage\nconst poller = new TaskPoller('condt_your_virtual_key', 3000);\n\n// Wait for single task with progress updates\nconst result = await poller.waitForCompletion(taskId, (task) => {\n  console.log(`Progress: ${task.progress}% - Stage: ${task.stage}`);\n});\n\nconsole.log('Generation completed:', result.url);\n\n// Wait for multiple tasks\nconst taskIds = ['task1', 'task2', 'task3'];\nconst results = await poller.waitForMultiple(taskIds, (task) => {\n  console.log(`Task ${task.task_id}: ${task.progress}%`);\n});\n\nresults.forEach(result => {\n  if (result.success) {\n    console.log(`${result.taskId}: ${result.result.url}`);\n  } else {\n    console.log(`${result.taskId}: Failed - ${result.error}`);\n  }\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"webhook-integration",children:"Webhook Integration"}),"\n",(0,s.jsx)(n.h3,{id:"setting-up-webhook-endpoints",children:"Setting Up Webhook Endpoints"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import express from 'express';\nimport crypto from 'crypto';\n\nconst app = express();\napp.use(express.json());\n\n// Webhook signature verification\nfunction verifyWebhookSignature(payload, signature, secret) {\n  const expectedSignature = crypto\n    .createHmac('sha256', secret)\n    .update(JSON.stringify(payload))\n    .digest('hex');\n  \n  return signature === `sha256=${expectedSignature}`;\n}\n\n// Webhook endpoint\napp.post('/webhooks/conduit', (req, res) => {\n  const signature = req.headers['x-conduit-signature'];\n  const payload = req.body;\n\n  // Verify signature (optional but recommended)\n  if (!verifyWebhookSignature(payload, signature, process.env.WEBHOOK_SECRET)) {\n    return res.status(401).send('Invalid signature');\n  }\n\n  // Process the event\n  try {\n    handleWebhookEvent(payload);\n    res.status(200).send('OK');\n  } catch (error) {\n    console.error('Webhook processing error:', error);\n    res.status(500).send('Processing failed');\n  }\n});\n\nfunction handleWebhookEvent(event) {\n  console.log('Received webhook:', event.type);\n\n  switch (event.type) {\n    case 'image.generation.started':\n      handleImageGenerationStarted(event.data);\n      break;\n      \n    case 'image.generation.progress':\n      handleImageGenerationProgress(event.data);\n      break;\n      \n    case 'image.generation.completed':\n      handleImageGenerationCompleted(event.data);\n      break;\n      \n    case 'image.generation.failed':\n      handleImageGenerationFailed(event.data);\n      break;\n      \n    case 'video.generation.started':\n      handleVideoGenerationStarted(event.data);\n      break;\n      \n    case 'video.generation.progress':\n      handleVideoGenerationProgress(event.data);\n      break;\n      \n    case 'video.generation.completed':\n      handleVideoGenerationCompleted(event.data);\n      break;\n      \n    case 'video.generation.failed':\n      handleVideoGenerationFailed(event.data);\n      break;\n      \n    default:\n      console.log('Unknown event type:', event.type);\n  }\n}\n\nfunction handleImageGenerationCompleted(data) {\n  console.log(`Image completed: ${data.task_id}`);\n  console.log(`URL: ${data.image_url}`);\n  console.log(`Generation time: ${data.generation_time}ms`);\n\n  // Update database\n  updateTaskInDatabase(data.task_id, {\n    status: 'completed',\n    image_url: data.image_url,\n    completed_at: new Date()\n  });\n\n  // Notify user (push notification, email, etc.)\n  notifyUser(data.user_id, {\n    type: 'image_ready',\n    task_id: data.task_id,\n    image_url: data.image_url\n  });\n}\n\nfunction handleVideoGenerationProgress(data) {\n  console.log(`Video progress: ${data.task_id} - ${data.progress}%`);\n  \n  // Update real-time dashboard\n  updateProgressInDatabase(data.task_id, data.progress, data.stage);\n  \n  // Send to connected WebSocket clients\n  notifyWebSocketClients(data.task_id, {\n    progress: data.progress,\n    stage: data.stage,\n    estimated_time_remaining: data.estimated_time_remaining\n  });\n}\n\napp.listen(3000, () => {\n  console.log('Webhook server listening on port 3000');\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"webhook-retry-and-reliability",children:"Webhook Retry and Reliability"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class WebhookHandler {\n  constructor() {\n    this.processedEvents = new Set(); // For idempotency\n    this.retryAttempts = new Map(); // Track retry attempts\n  }\n\n  async handleWebhook(req, res) {\n    const eventId = req.headers['x-conduit-event-id'];\n    const signature = req.headers['x-conduit-signature'];\n    const payload = req.body;\n\n    try {\n      // Idempotency check\n      if (this.processedEvents.has(eventId)) {\n        console.log(`Event ${eventId} already processed, skipping`);\n        return res.status(200).send('Already processed');\n      }\n\n      // Verify signature\n      if (!this.verifySignature(payload, signature)) {\n        return res.status(401).send('Invalid signature');\n      }\n\n      // Process event\n      await this.processEvent(payload);\n      \n      // Mark as processed\n      this.processedEvents.add(eventId);\n      \n      // Clean up old events (prevent memory leak)\n      if (this.processedEvents.size > 10000) {\n        const eventsArray = Array.from(this.processedEvents);\n        this.processedEvents = new Set(eventsArray.slice(-5000));\n      }\n\n      res.status(200).send('OK');\n    } catch (error) {\n      console.error('Webhook processing error:', error);\n      \n      // Track retry attempts\n      const attempts = this.retryAttempts.get(eventId) || 0;\n      this.retryAttempts.set(eventId, attempts + 1);\n\n      // Return appropriate status code for retry logic\n      if (attempts < 3) {\n        res.status(500).send('Temporary error, please retry');\n      } else {\n        res.status(400).send('Permanent error, stop retrying');\n        this.retryAttempts.delete(eventId);\n      }\n    }\n  }\n\n  async processEvent(event) {\n    const handlers = {\n      'image.generation.completed': this.handleImageCompleted.bind(this),\n      'video.generation.completed': this.handleVideoCompleted.bind(this),\n      'image.generation.failed': this.handleImageFailed.bind(this),\n      'video.generation.failed': this.handleVideoFailed.bind(this)\n    };\n\n    const handler = handlers[event.type];\n    if (handler) {\n      await handler(event.data);\n    } else {\n      console.log(`No handler for event type: ${event.type}`);\n    }\n  }\n\n  async handleImageCompleted(data) {\n    try {\n      // Update database\n      await this.updateTaskStatus(data.task_id, 'completed', {\n        image_url: data.image_url,\n        file_size: data.file_size,\n        generation_time: data.generation_time\n      });\n\n      // Send notification\n      await this.sendNotification(data.user_id, {\n        type: 'image_ready',\n        task_id: data.task_id,\n        image_url: data.image_url,\n        title: 'Your image is ready!',\n        message: 'Your AI-generated image has been created successfully.'\n      });\n\n      // Process any follow-up actions\n      await this.processFollowUpActions(data.task_id);\n      \n    } catch (error) {\n      console.error('Error handling image completion:', error);\n      throw error; // Propagate for retry logic\n    }\n  }\n\n  async updateTaskStatus(taskId, status, metadata = {}) {\n    // Database update implementation\n    console.log(`Updating task ${taskId} to status: ${status}`);\n    // await database.tasks.update(taskId, { status, ...metadata });\n  }\n\n  async sendNotification(userId, notification) {\n    // Notification service implementation\n    console.log(`Sending notification to user ${userId}:`, notification);\n    // await notificationService.send(userId, notification);\n  }\n\n  verifySignature(payload, signature) {\n    const secret = process.env.WEBHOOK_SECRET;\n    if (!secret) return true; // Skip verification if no secret set\n\n    const expectedSignature = crypto\n      .createHmac('sha256', secret)\n      .update(JSON.stringify(payload))\n      .digest('hex');\n    \n    return signature === `sha256=${expectedSignature}`;\n  }\n}\n\n// Usage\nconst webhookHandler = new WebhookHandler();\n\napp.post('/webhooks/conduit', (req, res) => {\n  webhookHandler.handleWebhook(req, res);\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"signalr-real-time-updates",children:"SignalR Real-Time Updates"}),"\n",(0,s.jsx)(n.h3,{id:"client-side-signalr-integration",children:"Client-Side SignalR Integration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { HubConnectionBuilder, LogLevel } from '@microsoft/signalr';\n\nclass MediaGenerationClient {\n  constructor(apiKey) {\n    this.apiKey = apiKey;\n    this.activeTasks = new Map();\n    this.setupSignalR();\n  }\n\n  setupSignalR() {\n    this.connection = new HubConnectionBuilder()\n      .withUrl('https://api.conduit.yourdomain.com/hubs/media-generation', {\n        accessTokenFactory: () => this.apiKey,\n        skipNegotiation: true,\n        transport: 1 // WebSockets\n      })\n      .withAutomaticReconnect({\n        nextRetryDelayInMilliseconds: (retryContext) => {\n          // Exponential backoff: 2s, 4s, 8s, 16s, 30s max\n          return Math.min(30000, Math.pow(2, retryContext.previousRetryCount) * 1000);\n        }\n      })\n      .configureLogging(LogLevel.Information)\n      .build();\n\n    // Connection events\n    this.connection.onreconnecting((error) => {\n      console.log('SignalR reconnecting...', error);\n      this.showConnectionStatus('reconnecting');\n    });\n\n    this.connection.onreconnected((connectionId) => {\n      console.log('SignalR reconnected:', connectionId);\n      this.showConnectionStatus('connected');\n    });\n\n    this.connection.onclose((error) => {\n      console.log('SignalR connection closed:', error);\n      this.showConnectionStatus('disconnected');\n    });\n\n    // Media generation events\n    this.connection.on('ImageGenerationStarted', (data) => {\n      this.handleImageGenerationStarted(data);\n    });\n\n    this.connection.on('ImageGenerationProgress', (data) => {\n      this.handleImageGenerationProgress(data);\n    });\n\n    this.connection.on('ImageGenerationCompleted', (data) => {\n      this.handleImageGenerationCompleted(data);\n    });\n\n    this.connection.on('ImageGenerationFailed', (data) => {\n      this.handleImageGenerationFailed(data);\n    });\n\n    this.connection.on('VideoGenerationStarted', (data) => {\n      this.handleVideoGenerationStarted(data);\n    });\n\n    this.connection.on('VideoGenerationProgress', (data) => {\n      this.handleVideoGenerationProgress(data);\n    });\n\n    this.connection.on('VideoGenerationCompleted', (data) => {\n      this.handleVideoGenerationCompleted(data);\n    });\n\n    this.connection.on('VideoGenerationFailed', (data) => {\n      this.handleVideoGenerationFailed(data);\n    });\n  }\n\n  async start() {\n    try {\n      await this.connection.start();\n      console.log('SignalR connection established');\n      this.showConnectionStatus('connected');\n    } catch (error) {\n      console.error('SignalR connection failed:', error);\n      this.showConnectionStatus('error');\n    }\n  }\n\n  async generateImage(prompt, options = {}) {\n    const response = await fetch('https://api.conduit.yourdomain.com/v1/images/generations', {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${this.apiKey}`,\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        model: 'dall-e-3',\n        prompt: prompt,\n        async: true,\n        ...options\n      })\n    });\n\n    const task = await response.json();\n    \n    // Track the task\n    this.activeTasks.set(task.task_id, {\n      type: 'image',\n      prompt: prompt,\n      startTime: Date.now(),\n      status: 'queued'\n    });\n\n    // Create UI element for this task\n    this.createTaskUI(task.task_id, 'image', prompt);\n\n    return task.task_id;\n  }\n\n  async generateVideo(prompt, options = {}) {\n    const response = await fetch('https://api.conduit.yourdomain.com/v1/video/generations', {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${this.apiKey}`,\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        model: 'minimax-video',\n        prompt: prompt,\n        duration: 5,\n        ...options\n      })\n    });\n\n    const task = await response.json();\n    \n    this.activeTasks.set(task.task_id, {\n      type: 'video',\n      prompt: prompt,\n      startTime: Date.now(),\n      status: 'queued'\n    });\n\n    this.createTaskUI(task.task_id, 'video', prompt);\n\n    return task.task_id;\n  }\n\n  handleImageGenerationStarted(data) {\n    const task = this.activeTasks.get(data.taskId);\n    if (task) {\n      task.status = 'processing';\n      this.updateTaskUI(data.taskId, { status: 'processing', progress: 0 });\n    }\n  }\n\n  handleImageGenerationProgress(data) {\n    const task = this.activeTasks.get(data.taskId);\n    if (task) {\n      task.progress = data.progress;\n      task.stage = data.stage;\n      this.updateTaskUI(data.taskId, { \n        progress: data.progress, \n        stage: data.stage,\n        estimatedTimeRemaining: data.estimatedTimeRemaining \n      });\n    }\n  }\n\n  handleImageGenerationCompleted(data) {\n    const task = this.activeTasks.get(data.taskId);\n    if (task) {\n      task.status = 'completed';\n      task.completedAt = Date.now();\n      task.imageUrl = data.imageUrl;\n      task.generationTime = task.completedAt - task.startTime;\n\n      this.updateTaskUI(data.taskId, {\n        status: 'completed',\n        imageUrl: data.imageUrl,\n        generationTime: task.generationTime\n      });\n\n      // Show notification\n      this.showNotification('Image Ready!', `Your image \"${task.prompt.substring(0, 50)}...\" is ready.`);\n    }\n  }\n\n  handleVideoGenerationCompleted(data) {\n    const task = this.activeTasks.get(data.taskId);\n    if (task) {\n      task.status = 'completed';\n      task.completedAt = Date.now();\n      task.videoUrl = data.videoUrl;\n      task.thumbnailUrl = data.thumbnailUrl;\n      task.generationTime = task.completedAt - task.startTime;\n\n      this.updateTaskUI(data.taskId, {\n        status: 'completed',\n        videoUrl: data.videoUrl,\n        thumbnailUrl: data.thumbnailUrl,\n        generationTime: task.generationTime\n      });\n\n      this.showNotification('Video Ready!', `Your video \"${task.prompt.substring(0, 50)}...\" is ready.`);\n    }\n  }\n\n  createTaskUI(taskId, type, prompt) {\n    const container = document.getElementById('tasks-container');\n    \n    const taskElement = document.createElement('div');\n    taskElement.id = `task-${taskId}`;\n    taskElement.className = 'task-item';\n    taskElement.innerHTML = `\n      <div class=\"task-header\">\n        <span class=\"task-type\">${type.toUpperCase()}</span>\n        <span class=\"task-prompt\">${prompt.substring(0, 100)}...</span>\n      </div>\n      <div class=\"task-status\">\n        <div class=\"status-text\">Queued...</div>\n        <div class=\"progress-container\">\n          <div class=\"progress-bar\" style=\"width: 0%\">0%</div>\n        </div>\n      </div>\n      <div class=\"task-result\" style=\"display: none;\"></div>\n    `;\n    \n    container.appendChild(taskElement);\n  }\n\n  updateTaskUI(taskId, data) {\n    const taskElement = document.getElementById(`task-${taskId}`);\n    if (!taskElement) return;\n\n    const statusText = taskElement.querySelector('.status-text');\n    const progressBar = taskElement.querySelector('.progress-bar');\n    const resultContainer = taskElement.querySelector('.task-result');\n\n    if (data.status === 'processing') {\n      statusText.textContent = `Processing... (${data.progress || 0}%)`;\n      if (data.stage) {\n        statusText.textContent += ` - ${data.stage}`;\n      }\n    }\n\n    if (data.progress !== undefined) {\n      progressBar.style.width = `${data.progress}%`;\n      progressBar.textContent = `${data.progress}%`;\n    }\n\n    if (data.status === 'completed') {\n      statusText.textContent = `Completed in ${(data.generationTime / 1000).toFixed(1)}s`;\n      progressBar.style.width = '100%';\n      progressBar.textContent = 'Complete';\n      \n      if (data.imageUrl) {\n        resultContainer.innerHTML = `\n          <img src=\"${data.imageUrl}\" alt=\"Generated image\" style=\"max-width: 100%; height: auto;\">\n          <div class=\"result-actions\">\n            <a href=\"${data.imageUrl}\" download>Download</a>\n            <button onclick=\"shareImage('${data.imageUrl}')\">Share</button>\n          </div>\n        `;\n        resultContainer.style.display = 'block';\n      }\n\n      if (data.videoUrl) {\n        resultContainer.innerHTML = `\n          <video controls poster=\"${data.thumbnailUrl}\" style=\"max-width: 100%; height: auto;\">\n            <source src=\"${data.videoUrl}\" type=\"video/mp4\">\n            Your browser does not support the video tag.\n          </video>\n          <div class=\"result-actions\">\n            <a href=\"${data.videoUrl}\" download>Download Video</a>\n            <button onclick=\"shareVideo('${data.videoUrl}')\">Share</button>\n          </div>\n        `;\n        resultContainer.style.display = 'block';\n      }\n    }\n\n    if (data.status === 'failed') {\n      statusText.textContent = `Failed: ${data.error}`;\n      taskElement.classList.add('task-failed');\n    }\n  }\n\n  showConnectionStatus(status) {\n    const statusElement = document.getElementById('connection-status');\n    if (statusElement) {\n      statusElement.textContent = status;\n      statusElement.className = `connection-status ${status}`;\n    }\n  }\n\n  showNotification(title, message) {\n    if ('Notification' in window && Notification.permission === 'granted') {\n      new Notification(title, { body: message });\n    } else {\n      // Fallback to in-app notification\n      const notification = document.createElement('div');\n      notification.className = 'app-notification';\n      notification.innerHTML = `\n        <strong>${title}</strong>\n        <p>${message}</p>\n      `;\n      document.body.appendChild(notification);\n      \n      setTimeout(() => {\n        notification.remove();\n      }, 5000);\n    }\n  }\n\n  getTaskStatistics() {\n    const stats = {\n      total: this.activeTasks.size,\n      queued: 0,\n      processing: 0,\n      completed: 0,\n      failed: 0\n    };\n\n    this.activeTasks.forEach(task => {\n      stats[task.status]++;\n    });\n\n    return stats;\n  }\n}\n\n// Usage\nconst mediaClient = new MediaGenerationClient('condt_your_virtual_key');\n\n// Request notification permission\nif ('Notification' in window && Notification.permission === 'default') {\n  Notification.requestPermission();\n}\n\n// Start SignalR connection\nawait mediaClient.start();\n\n// Generate media with real-time updates\nconst imageTaskId = await mediaClient.generateImage(\n  'A beautiful sunset over mountains with a crystal-clear lake reflection'\n);\n\nconst videoTaskId = await mediaClient.generateVideo(\n  'A time-lapse of clouds moving over a cityscape at golden hour'\n);\n\n// Monitor statistics\nsetInterval(() => {\n  const stats = mediaClient.getTaskStatistics();\n  console.log('Media Generation Stats:', stats);\n}, 10000);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"advanced-task-management",children:"Advanced Task Management"}),"\n",(0,s.jsx)(n.h3,{id:"task-queue-management",children:"Task Queue Management"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class MediaTaskQueue {\n  constructor(apiKey, options = {}) {\n    this.apiKey = apiKey;\n    this.baseUrl = 'https://api.conduit.yourdomain.com/v1';\n    this.maxConcurrentTasks = options.maxConcurrentTasks || 5;\n    this.retryAttempts = options.retryAttempts || 3;\n    this.retryDelay = options.retryDelay || 5000;\n    \n    this.queue = [];\n    this.activeTasks = new Map();\n    this.completedTasks = new Map();\n    this.failedTasks = new Map();\n    this.processing = false;\n  }\n\n  async addTask(type, prompt, options = {}) {\n    const task = {\n      id: crypto.randomUUID(),\n      type: type, // 'image' or 'video'\n      prompt: prompt,\n      options: options,\n      status: 'queued',\n      attempts: 0,\n      createdAt: Date.now(),\n      priority: options.priority || 5 // 1-10, higher = more important\n    };\n\n    this.queue.push(task);\n    this.sortQueue();\n    \n    console.log(`Task ${task.id} added to queue (${this.queue.length} queued)`);\n    \n    if (!this.processing) {\n      this.processQueue();\n    }\n\n    return task.id;\n  }\n\n  sortQueue() {\n    // Sort by priority (higher first), then by creation time (older first)\n    this.queue.sort((a, b) => {\n      if (a.priority !== b.priority) {\n        return b.priority - a.priority;\n      }\n      return a.createdAt - b.createdAt;\n    });\n  }\n\n  async processQueue() {\n    if (this.processing) return;\n    this.processing = true;\n\n    console.log('Starting queue processing...');\n\n    while (this.queue.length > 0 || this.activeTasks.size > 0) {\n      // Start new tasks if we have capacity\n      while (this.queue.length > 0 && this.activeTasks.size < this.maxConcurrentTasks) {\n        const task = this.queue.shift();\n        this.startTask(task);\n      }\n\n      // Wait a bit before checking again\n      await new Promise(resolve => setTimeout(resolve, 1000));\n    }\n\n    this.processing = false;\n    console.log('Queue processing completed');\n  }\n\n  async startTask(task) {\n    console.log(`Starting task ${task.id}: ${task.type} - ${task.prompt.substring(0, 50)}...`);\n    \n    task.status = 'starting';\n    task.startedAt = Date.now();\n    this.activeTasks.set(task.id, task);\n\n    try {\n      const endpoint = task.type === 'image' ? '/images/generations' : '/video/generations';\n      \n      const response = await fetch(`${this.baseUrl}${endpoint}`, {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${this.apiKey}`,\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          model: task.type === 'image' ? 'dall-e-3' : 'minimax-video',\n          prompt: task.prompt,\n          async: true,\n          ...task.options\n        })\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      const result = await response.json();\n      task.conduitTaskId = result.task_id;\n      task.status = 'processing';\n      \n      console.log(`Task ${task.id} started with Conduit task ID: ${result.task_id}`);\n      \n      // Monitor the task\n      this.monitorTask(task);\n      \n    } catch (error) {\n      console.error(`Failed to start task ${task.id}:`, error.message);\n      await this.handleTaskFailure(task, error);\n    }\n  }\n\n  async monitorTask(task) {\n    const pollInterval = 5000; // 5 seconds\n    \n    const poll = async () => {\n      try {\n        const response = await fetch(`${this.baseUrl}/tasks/${task.conduitTaskId}`, {\n          headers: {\n            'Authorization': `Bearer ${this.apiKey}`\n          }\n        });\n\n        const conduitTask = await response.json();\n        \n        task.progress = conduitTask.progress || 0;\n        task.stage = conduitTask.stage;\n\n        switch (conduitTask.status) {\n          case 'completed':\n            await this.handleTaskCompletion(task, conduitTask.result);\n            return;\n            \n          case 'failed':\n            await this.handleTaskFailure(task, new Error(conduitTask.error));\n            return;\n            \n          default:\n            // Continue monitoring\n            setTimeout(poll, pollInterval);\n        }\n      } catch (error) {\n        console.error(`Error monitoring task ${task.id}:`, error);\n        setTimeout(poll, pollInterval * 2); // Retry with longer delay\n      }\n    };\n\n    poll();\n  }\n\n  async handleTaskCompletion(task, result) {\n    console.log(`Task ${task.id} completed successfully`);\n    \n    task.status = 'completed';\n    task.completedAt = Date.now();\n    task.result = result;\n    task.duration = task.completedAt - task.startedAt;\n\n    this.activeTasks.delete(task.id);\n    this.completedTasks.set(task.id, task);\n\n    // Call completion callback if provided\n    if (task.onComplete) {\n      try {\n        await task.onComplete(task);\n      } catch (error) {\n        console.error('Error in completion callback:', error);\n      }\n    }\n\n    this.emitEvent('taskCompleted', task);\n  }\n\n  async handleTaskFailure(task, error) {\n    console.error(`Task ${task.id} failed:`, error.message);\n    \n    task.attempts++;\n    task.lastError = error.message;\n\n    if (task.attempts < this.retryAttempts) {\n      console.log(`Retrying task ${task.id} (attempt ${task.attempts + 1}/${this.retryAttempts})`);\n      \n      // Add back to queue with delay\n      setTimeout(() => {\n        task.status = 'queued';\n        this.queue.unshift(task); // Add to front for retry priority\n        this.sortQueue();\n      }, this.retryDelay * task.attempts); // Exponential backoff\n      \n    } else {\n      console.log(`Task ${task.id} failed permanently after ${task.attempts} attempts`);\n      \n      task.status = 'failed';\n      task.failedAt = Date.now();\n      \n      this.failedTasks.set(task.id, task);\n      \n      // Call failure callback if provided\n      if (task.onFailure) {\n        try {\n          await task.onFailure(task, error);\n        } catch (callbackError) {\n          console.error('Error in failure callback:', callbackError);\n        }\n      }\n\n      this.emitEvent('taskFailed', task);\n    }\n\n    this.activeTasks.delete(task.id);\n  }\n\n  async cancelTask(taskId) {\n    // Cancel queued task\n    const queueIndex = this.queue.findIndex(task => task.id === taskId);\n    if (queueIndex !== -1) {\n      const task = this.queue.splice(queueIndex, 1)[0];\n      task.status = 'cancelled';\n      console.log(`Cancelled queued task ${taskId}`);\n      return true;\n    }\n\n    // Cancel active task\n    const activeTask = this.activeTasks.get(taskId);\n    if (activeTask && activeTask.conduitTaskId) {\n      try {\n        await fetch(`${this.baseUrl}/tasks/${activeTask.conduitTaskId}/cancel`, {\n          method: 'POST',\n          headers: {\n            'Authorization': `Bearer ${this.apiKey}`\n          }\n        });\n        \n        activeTask.status = 'cancelled';\n        this.activeTasks.delete(taskId);\n        console.log(`Cancelled active task ${taskId}`);\n        return true;\n      } catch (error) {\n        console.error(`Failed to cancel task ${taskId}:`, error);\n        return false;\n      }\n    }\n\n    return false;\n  }\n\n  getQueueStatus() {\n    return {\n      queued: this.queue.length,\n      active: this.activeTasks.size,\n      completed: this.completedTasks.size,\n      failed: this.failedTasks.size,\n      processing: this.processing,\n      nextTask: this.queue.length > 0 ? {\n        id: this.queue[0].id,\n        type: this.queue[0].type,\n        priority: this.queue[0].priority\n      } : null\n    };\n  }\n\n  emitEvent(eventName, data) {\n    // Emit events for external listeners\n    if (this.eventListeners && this.eventListeners[eventName]) {\n      this.eventListeners[eventName].forEach(listener => {\n        try {\n          listener(data);\n        } catch (error) {\n          console.error('Error in event listener:', error);\n        }\n      });\n    }\n  }\n\n  addEventListener(eventName, listener) {\n    if (!this.eventListeners) {\n      this.eventListeners = {};\n    }\n    \n    if (!this.eventListeners[eventName]) {\n      this.eventListeners[eventName] = [];\n    }\n    \n    this.eventListeners[eventName].push(listener);\n  }\n}\n\n// Usage\nconst taskQueue = new MediaTaskQueue('condt_your_virtual_key', {\n  maxConcurrentTasks: 3,\n  retryAttempts: 2,\n  retryDelay: 3000\n});\n\n// Add event listeners\ntaskQueue.addEventListener('taskCompleted', (task) => {\n  console.log(`\u2705 Task completed: ${task.id}`);\n  console.log(`Result: ${task.result.url || task.result.video_url}`);\n});\n\ntaskQueue.addEventListener('taskFailed', (task) => {\n  console.log(`\u274c Task failed: ${task.id} - ${task.lastError}`);\n});\n\n// Add tasks to queue\nconst task1 = await taskQueue.addTask('image', 'A serene mountain landscape', {\n  priority: 8,\n  quality: 'hd'\n});\n\nconst task2 = await taskQueue.addTask('video', 'A cat playing with a ball', {\n  priority: 5,\n  duration: 4\n});\n\nconst task3 = await taskQueue.addTask('image', 'A futuristic cityscape', {\n  priority: 9,\n  style: 'vivid'\n});\n\n// Monitor queue status\nsetInterval(() => {\n  const status = taskQueue.getQueueStatus();\n  console.log('Queue Status:', status);\n}, 5000);\n\n// Cancel a task if needed\n// await taskQueue.cancelTask(task2);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"error-handling-and-recovery",children:"Error Handling and Recovery"}),"\n",(0,s.jsx)(n.h3,{id:"comprehensive-error-management",children:"Comprehensive Error Management"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class AsyncMediaProcessor {\n  constructor(apiKey) {\n    this.apiKey = apiKey;\n    this.baseUrl = 'https://api.conduit.yourdomain.com/v1';\n    this.errorHandlers = new Map();\n    this.setupDefaultErrorHandlers();\n  }\n\n  setupDefaultErrorHandlers() {\n    // Content policy violation\n    this.errorHandlers.set('content_policy_violation', async (task, error) => {\n      console.log('Content policy violation, attempting to sanitize prompt...');\n      \n      const sanitizedPrompt = this.sanitizePrompt(task.prompt);\n      if (sanitizedPrompt !== task.prompt) {\n        console.log(`Original: ${task.prompt}`);\n        console.log(`Sanitized: ${sanitizedPrompt}`);\n        \n        // Retry with sanitized prompt\n        return await this.retryWithNewPrompt(task, sanitizedPrompt);\n      }\n      \n      throw new Error('Unable to sanitize prompt for content policy compliance');\n    });\n\n    // Rate limit exceeded\n    this.errorHandlers.set('rate_limit_exceeded', async (task, error) => {\n      const waitTime = this.extractWaitTime(error.message) || 60000; // Default 1 minute\n      console.log(`Rate limited, waiting ${waitTime}ms before retry...`);\n      \n      await new Promise(resolve => setTimeout(resolve, waitTime));\n      return await this.retryTask(task);\n    });\n\n    // Model overloaded\n    this.errorHandlers.set('model_overloaded', async (task, error) => {\n      console.log('Model overloaded, trying alternative model...');\n      \n      const alternativeModel = this.getAlternativeModel(task.model);\n      if (alternativeModel) {\n        console.log(`Switching from ${task.model} to ${alternativeModel}`);\n        return await this.retryWithNewModel(task, alternativeModel);\n      }\n      \n      // Wait and retry with same model\n      await new Promise(resolve => setTimeout(resolve, 30000));\n      return await this.retryTask(task);\n    });\n\n    // Insufficient quota\n    this.errorHandlers.set('insufficient_quota', async (task, error) => {\n      console.log('Insufficient quota, trying cheaper alternative...');\n      \n      const cheaperModel = this.getCheaperModel(task.model);\n      if (cheaperModel) {\n        console.log(`Switching to cheaper model: ${cheaperModel}`);\n        return await this.retryWithNewModel(task, cheaperModel);\n      }\n      \n      throw new Error('No quota available and no cheaper alternatives');\n    });\n\n    // Network errors\n    this.errorHandlers.set('network_error', async (task, error) => {\n      console.log('Network error, retrying with exponential backoff...');\n      \n      const retryCount = task.retryCount || 0;\n      const backoffTime = Math.min(Math.pow(2, retryCount) * 1000, 30000);\n      \n      await new Promise(resolve => setTimeout(resolve, backoffTime));\n      \n      task.retryCount = retryCount + 1;\n      return await this.retryTask(task);\n    });\n  }\n\n  async processWithErrorHandling(task) {\n    let lastError;\n    \n    for (let attempt = 1; attempt <= 3; attempt++) {\n      try {\n        console.log(`Processing task ${task.id}, attempt ${attempt}/3`);\n        \n        const result = await this.processTask(task);\n        return result;\n        \n      } catch (error) {\n        lastError = error;\n        console.error(`Attempt ${attempt} failed:`, error.message);\n        \n        // Try to handle the error\n        const errorCode = this.extractErrorCode(error);\n        const handler = this.errorHandlers.get(errorCode);\n        \n        if (handler && attempt < 3) {\n          try {\n            console.log(`Applying error handler for: ${errorCode}`);\n            const handlerResult = await handler(task, error);\n            \n            if (handlerResult) {\n              return handlerResult; // Handler succeeded\n            }\n          } catch (handlerError) {\n            console.error('Error handler failed:', handlerError.message);\n            // Continue to next attempt\n          }\n        }\n        \n        // Wait before next attempt (if not the last one)\n        if (attempt < 3) {\n          const waitTime = attempt * 2000; // 2s, 4s\n          await new Promise(resolve => setTimeout(resolve, waitTime));\n        }\n      }\n    }\n    \n    // All attempts failed\n    throw new Error(`Task failed after 3 attempts. Last error: ${lastError.message}`);\n  }\n\n  async processTask(task) {\n    const endpoint = task.type === 'image' ? '/images/generations' : '/video/generations';\n    \n    const response = await fetch(`${this.baseUrl}${endpoint}`, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${this.apiKey}`,\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        model: task.model,\n        prompt: task.prompt,\n        async: true,\n        ...task.options\n      })\n    });\n\n    if (!response.ok) {\n      const errorData = await response.json();\n      const error = new Error(errorData.error?.message || 'Unknown error');\n      error.code = errorData.error?.code;\n      error.type = errorData.error?.type;\n      throw error;\n    }\n\n    const taskResult = await response.json();\n    \n    // Monitor for completion\n    return await this.monitorTaskCompletion(taskResult.task_id);\n  }\n\n  async monitorTaskCompletion(conduitTaskId) {\n    const pollInterval = 3000;\n    const maxWaitTime = 600000; // 10 minutes\n    const startTime = Date.now();\n    \n    while (Date.now() - startTime < maxWaitTime) {\n      try {\n        const response = await fetch(`${this.baseUrl}/tasks/${conduitTaskId}`, {\n          headers: {\n            'Authorization': `Bearer ${this.apiKey}`\n          }\n        });\n\n        const task = await response.json();\n        \n        switch (task.status) {\n          case 'completed':\n            return task.result;\n            \n          case 'failed':\n            const error = new Error(task.error);\n            error.code = task.error_code;\n            throw error;\n            \n          default:\n            // Still processing, continue polling\n            await new Promise(resolve => setTimeout(resolve, pollInterval));\n        }\n      } catch (error) {\n        if (error.code) {\n          throw error; // Task-specific error\n        }\n        \n        // Network error, retry polling\n        console.error('Polling error:', error.message);\n        await new Promise(resolve => setTimeout(resolve, pollInterval));\n      }\n    }\n    \n    throw new Error('Task monitoring timed out after 10 minutes');\n  }\n\n  sanitizePrompt(prompt) {\n    // Remove potentially problematic content\n    const problematicPatterns = [\n      /\\b(violence|violent|gore|blood|weapon|gun|knife)\\b/gi,\n      /\\b(nude|naked|explicit|sexual|nsfw)\\b/gi,\n      /\\b(drug|cocaine|heroin|marijuana)\\b/gi,\n      /\\b(hitler|nazi|terrorist|bomb)\\b/gi\n    ];\n\n    let sanitized = prompt;\n    problematicPatterns.forEach(pattern => {\n      sanitized = sanitized.replace(pattern, '');\n    });\n\n    // Clean up extra spaces and add safe qualifiers\n    sanitized = sanitized.replace(/\\s+/g, ' ').trim();\n    \n    if (sanitized.length < prompt.length * 0.5) {\n      // Too much was removed, add safe context\n      sanitized = `family-friendly, safe content: ${sanitized}`;\n    }\n\n    return sanitized;\n  }\n\n  getAlternativeModel(model) {\n    const alternatives = {\n      'dall-e-3': 'dall-e-2',\n      'runway-gen3': 'minimax-video',\n      'pika-1': 'minimax-video'\n    };\n    \n    return alternatives[model] || null;\n  }\n\n  getCheaperModel(model) {\n    const cheaper = {\n      'dall-e-3': 'dall-e-2',\n      'dall-e-2': 'minimax-image',\n      'runway-gen3': 'runway-gen2',\n      'runway-gen2': 'minimax-video'\n    };\n    \n    return cheaper[model] || null;\n  }\n\n  extractErrorCode(error) {\n    return error.code || error.type || 'unknown_error';\n  }\n\n  extractWaitTime(errorMessage) {\n    const match = errorMessage.match(/retry after (\\d+) seconds?/i);\n    return match ? parseInt(match[1]) * 1000 : null;\n  }\n\n  async retryTask(task) {\n    return await this.processTask(task);\n  }\n\n  async retryWithNewPrompt(task, newPrompt) {\n    const modifiedTask = { ...task, prompt: newPrompt };\n    return await this.processTask(modifiedTask);\n  }\n\n  async retryWithNewModel(task, newModel) {\n    const modifiedTask = { ...task, model: newModel };\n    return await this.processTask(modifiedTask);\n  }\n}\n\n// Usage\nconst processor = new AsyncMediaProcessor('condt_your_virtual_key');\n\n// Process a task with comprehensive error handling\nconst task = {\n  id: 'task-123',\n  type: 'image',\n  model: 'dall-e-3',\n  prompt: 'A beautiful landscape with mountains and lakes',\n  options: {\n    size: '1024x1024',\n    quality: 'hd'\n  }\n};\n\ntry {\n  const result = await processor.processWithErrorHandling(task);\n  console.log('Task completed successfully:', result.url);\n} catch (error) {\n  console.error('Task failed permanently:', error.message);\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Real-Time Updates"}),": Integrate ",(0,s.jsx)(n.a,{href:"../realtime/overview",children:"SignalR and webhooks"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Storage Configuration"}),": Set up ",(0,s.jsx)(n.a,{href:"storage-configuration",children:"media storage"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Image Generation"}),": Master ",(0,s.jsx)(n.a,{href:"image-generation",children:"synchronous image generation"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Video Generation"}),": Create ",(0,s.jsx)(n.a,{href:"video-generation",children:"dynamic video content"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Integration Examples"}),": See complete ",(0,s.jsx)(n.a,{href:"../clients/overview",children:"client patterns"})]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);