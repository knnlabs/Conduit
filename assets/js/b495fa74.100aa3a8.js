"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[557],{5570:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"realtime/overview","title":"Real-Time Communication Overview","description":"Complete guide to real-time updates in Conduit using webhooks, SignalR, and polling","source":"@site/docs/realtime/overview.md","sourceDirName":"realtime","slug":"/realtime/overview","permalink":"/Conduit/docs/realtime/overview","draft":false,"unlisted":false,"editUrl":"https://github.com/knnlabs/Conduit/tree/main/website/docs/realtime/overview.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"Real-Time Communication Overview","description":"Complete guide to real-time updates in Conduit using webhooks, SignalR, and polling"}}');var s=t(4848),r=t(8453);const o={sidebar_position:1,title:"Real-Time Communication Overview",description:"Complete guide to real-time updates in Conduit using webhooks, SignalR, and polling"},a="Real-Time Communication Overview",l={},c=[{value:"Communication Methods",id:"communication-methods",level:2},{value:"Decision Matrix",id:"decision-matrix",level:2},{value:"Architecture Overview",id:"architecture-overview",level:2},{value:"Event Flow",id:"event-flow",level:3},{value:"Supported Events",id:"supported-events",level:3},{value:"Quick Start Examples",id:"quick-start-examples",level:2},{value:"Webhooks (Recommended for Production)",id:"webhooks-recommended-for-production",level:3},{value:"SignalR (Recommended for Web UIs)",id:"signalr-recommended-for-web-uis",level:3},{value:"Polling (Simple Integration)",id:"polling-simple-integration",level:3},{value:"Method Comparison",id:"method-comparison",level:2},{value:"Performance Characteristics",id:"performance-characteristics",level:3},{value:"Reliability Features",id:"reliability-features",level:3},{value:"Scalability Considerations",id:"scalability-considerations",level:3},{value:"Use Case Scenarios",id:"use-case-scenarios",level:2},{value:"Real-Time Dashboard",id:"real-time-dashboard",level:3},{value:"Mobile Application",id:"mobile-application",level:3},{value:"Batch Processing System",id:"batch-processing-system",level:3},{value:"Legacy System Integration",id:"legacy-system-integration",level:3},{value:"Implementation Guidelines",id:"implementation-guidelines",level:2},{value:"When to Use Each Method",id:"when-to-use-each-method",level:3},{value:"Hybrid Approaches",id:"hybrid-approaches",level:3},{value:"Error Handling and Reliability",id:"error-handling-and-reliability",level:2},{value:"Connection Recovery",id:"connection-recovery",level:3},{value:"Webhook Reliability",id:"webhook-reliability",level:3},{value:"Security Considerations",id:"security-considerations",level:2},{value:"Virtual Key Authentication",id:"virtual-key-authentication",level:3},{value:"Network Security",id:"network-security",level:3},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"real-time-communication-overview",children:"Real-Time Communication Overview"})}),"\n",(0,s.jsx)(n.p,{children:"Conduit provides multiple real-time communication methods to keep your applications updated with task progress, completion notifications, and system events. Choose the right approach based on your architecture, requirements, and technical constraints."}),"\n",(0,s.jsx)(n.h2,{id:"communication-methods",children:"Communication Methods"}),"\n",(0,s.jsx)(n.p,{children:"Conduit supports three primary real-time communication patterns:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Webhooks"}),": HTTP callbacks for server-to-server communication"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"SignalR"}),": WebSocket-based real-time updates for web applications"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Polling"}),": Simple HTTP requests for basic integrations"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"decision-matrix",children:"Decision Matrix"}),"\n",(0,s.jsx)(n.p,{children:"Use this matrix to choose the best communication method for your use case:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Use Case"}),(0,s.jsx)(n.th,{children:"Primary Method"}),(0,s.jsx)(n.th,{children:"Alternative"}),(0,s.jsx)(n.th,{children:"Reason"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Web Dashboard"})}),(0,s.jsx)(n.td,{children:"SignalR"}),(0,s.jsx)(n.td,{children:"Polling"}),(0,s.jsx)(n.td,{children:"Real-time UI updates, WebSocket efficiency"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Mobile Applications"})}),(0,s.jsx)(n.td,{children:"Webhooks"}),(0,s.jsx)(n.td,{children:"Polling"}),(0,s.jsx)(n.td,{children:"Push notifications, battery optimization"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Server-to-Server"})}),(0,s.jsx)(n.td,{children:"Webhooks"}),(0,s.jsx)(n.td,{children:"Polling"}),(0,s.jsx)(n.td,{children:"Reliable delivery, retry mechanisms"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Development/Testing"})}),(0,s.jsx)(n.td,{children:"Polling"}),(0,s.jsx)(n.td,{children:"SignalR"}),(0,s.jsx)(n.td,{children:"Simple implementation, no infrastructure"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"High-Frequency Updates"})}),(0,s.jsx)(n.td,{children:"SignalR"}),(0,s.jsx)(n.td,{children:"Webhooks"}),(0,s.jsx)(n.td,{children:"Low latency, persistent connections"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Batch Processing"})}),(0,s.jsx)(n.td,{children:"Webhooks"}),(0,s.jsx)(n.td,{children:"Polling"}),(0,s.jsx)(n.td,{children:"Efficient for bulk operations"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Legacy Systems"})}),(0,s.jsx)(n.td,{children:"Polling"}),(0,s.jsx)(n.td,{children:"Webhooks"}),(0,s.jsx)(n.td,{children:"Compatible with older architectures"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Microservices"})}),(0,s.jsx)(n.td,{children:"Webhooks"}),(0,s.jsx)(n.td,{children:"SignalR"}),(0,s.jsx)(n.td,{children:"Service decoupling, scalability"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,s.jsx)(n.h3,{id:"event-flow",children:"Event Flow"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Conduit Core API \u2192 Event Bus \u2192 Real-Time Dispatcher \u2192 Multiple Channels\n                                        \u2193\n                   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                   \u2193                     \u2193                     \u2193\n               Webhooks              SignalR               Polling\n                   \u2193                     \u2193                     \u2193\n            External APIs         Web Applications      Any HTTP Client\n"})}),"\n",(0,s.jsx)(n.h3,{id:"supported-events",children:"Supported Events"}),"\n",(0,s.jsx)(n.p,{children:"All communication methods support the same event types:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Event Category"}),(0,s.jsx)(n.th,{children:"Event Types"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Image Generation"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"image.started"}),", ",(0,s.jsx)(n.code,{children:"image.completed"}),", ",(0,s.jsx)(n.code,{children:"image.failed"})]}),(0,s.jsx)(n.td,{children:"Async image generation events"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Video Generation"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"video.started"}),", ",(0,s.jsx)(n.code,{children:"video.progress"}),", ",(0,s.jsx)(n.code,{children:"video.completed"}),", ",(0,s.jsx)(n.code,{children:"video.failed"})]}),(0,s.jsx)(n.td,{children:"Async video generation events"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Audio Processing"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"audio.transcription.completed"}),", ",(0,s.jsx)(n.code,{children:"audio.synthesis.completed"})]}),(0,s.jsx)(n.td,{children:"Audio processing events"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Virtual Key Events"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"key.disabled"}),", ",(0,s.jsx)(n.code,{children:"key.budget.exceeded"}),", ",(0,s.jsx)(n.code,{children:"key.rate_limited"})]}),(0,s.jsx)(n.td,{children:"Virtual key status changes"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"System Events"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"provider.health_changed"}),", ",(0,s.jsx)(n.code,{children:"system.maintenance"})]}),(0,s.jsx)(n.td,{children:"System-wide notifications"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"quick-start-examples",children:"Quick Start Examples"}),"\n",(0,s.jsx)(n.h3,{id:"webhooks-recommended-for-production",children:"Webhooks (Recommended for Production)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// Configure webhook endpoint\napp.post('/webhooks/conduit', (req, res) => {\n  const event = req.body;\n  \n  switch (event.type) {\n    case 'image.completed':\n      console.log('Image generated:', event.data.imageUrl);\n      // Process completed image\n      break;\n    case 'video.progress':\n      console.log('Video progress:', event.data.progress);\n      // Update progress bar\n      break;\n  }\n  \n  res.status(200).send('OK');\n});\n\n// Start async image generation with webhook\nconst response = await fetch('https://api.conduit.yourdomain.com/v1/images/generations', {\n  method: 'POST',\n  headers: {\n    'Authorization': 'Bearer condt_your_virtual_key',\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify({\n    prompt: 'A beautiful sunset over mountains',\n    model: 'dall-e-3',\n    async: true,\n    webhook_url: 'https://yourapp.com/webhooks/conduit'\n  })\n});\n\nconst task = await response.json();\nconsole.log('Task started:', task.task_id);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"signalr-recommended-for-web-uis",children:"SignalR (Recommended for Web UIs)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { HubConnectionBuilder } from '@microsoft/signalr';\n\n// Connect to SignalR hub\nconst connection = new HubConnectionBuilder()\n  .withUrl('https://api.conduit.yourdomain.com/hubs/image-generation', {\n    accessTokenFactory: () => 'condt_your_virtual_key'\n  })\n  .build();\n\n// Listen for image generation events\nconnection.on('ImageGenerationStarted', (data) => {\n  console.log('Generation started:', data.taskId);\n  showProgressIndicator(data.taskId);\n});\n\nconnection.on('ImageGenerationCompleted', (data) => {\n  console.log('Image completed:', data.imageUrl);\n  displayImage(data.imageUrl);\n  hideProgressIndicator(data.taskId);\n});\n\nconnection.on('ImageGenerationFailed', (data) => {\n  console.log('Generation failed:', data.error);\n  showError(data.error);\n  hideProgressIndicator(data.taskId);\n});\n\n// Start connection\nawait connection.start();\n\n// Start async image generation (automatically sends updates via SignalR)\nconst response = await fetch('https://api.conduit.yourdomain.com/v1/images/generations', {\n  method: 'POST',\n  headers: {\n    'Authorization': 'Bearer condt_your_virtual_key',\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify({\n    prompt: 'A beautiful sunset over mountains',\n    model: 'dall-e-3',\n    async: true\n  })\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"polling-simple-integration",children:"Polling (Simple Integration)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class TaskPoller {\n  constructor(apiKey, baseUrl) {\n    this.apiKey = apiKey;\n    this.baseUrl = baseUrl;\n    this.activeTasks = new Set();\n  }\n\n  async startImageGeneration(prompt, options = {}) {\n    const response = await fetch(`${this.baseUrl}/v1/images/generations`, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${this.apiKey}`,\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        prompt,\n        async: true,\n        ...options\n      })\n    });\n\n    const task = await response.json();\n    this.activeTasks.add(task.task_id);\n    this.pollTask(task.task_id);\n    \n    return task.task_id;\n  }\n\n  async pollTask(taskId) {\n    const pollInterval = 2000; // 2 seconds\n    \n    const poll = async () => {\n      try {\n        const response = await fetch(`${this.baseUrl}/v1/tasks/${taskId}`, {\n          headers: {\n            'Authorization': `Bearer ${this.apiKey}`\n          }\n        });\n\n        const task = await response.json();\n        \n        switch (task.status) {\n          case 'completed':\n            this.onTaskCompleted(task);\n            this.activeTasks.delete(taskId);\n            return;\n          case 'failed':\n            this.onTaskFailed(task);\n            this.activeTasks.delete(taskId);\n            return;\n          case 'processing':\n            this.onTaskProgress(task);\n            break;\n        }\n        \n        // Continue polling\n        setTimeout(poll, pollInterval);\n      } catch (error) {\n        console.error('Polling error:', error);\n        setTimeout(poll, pollInterval * 2); // Backoff on error\n      }\n    };\n\n    poll();\n  }\n\n  onTaskCompleted(task) {\n    console.log('Task completed:', task.result);\n  }\n\n  onTaskFailed(task) {\n    console.log('Task failed:', task.error);\n  }\n\n  onTaskProgress(task) {\n    console.log('Task progress:', task.progress);\n  }\n}\n\n// Usage\nconst poller = new TaskPoller('condt_your_virtual_key', 'https://api.conduit.yourdomain.com');\nconst taskId = await poller.startImageGeneration('A beautiful sunset over mountains');\n"})}),"\n",(0,s.jsx)(n.h2,{id:"method-comparison",children:"Method Comparison"}),"\n",(0,s.jsx)(n.h3,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Method"}),(0,s.jsx)(n.th,{children:"Latency"}),(0,s.jsx)(n.th,{children:"Throughput"}),(0,s.jsx)(n.th,{children:"Resource Usage"}),(0,s.jsx)(n.th,{children:"Complexity"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"SignalR"})}),(0,s.jsx)(n.td,{children:"50-200ms"}),(0,s.jsx)(n.td,{children:"Very High"}),(0,s.jsx)(n.td,{children:"Medium"}),(0,s.jsx)(n.td,{children:"Medium"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Webhooks"})}),(0,s.jsx)(n.td,{children:"100-500ms"}),(0,s.jsx)(n.td,{children:"High"}),(0,s.jsx)(n.td,{children:"Low"}),(0,s.jsx)(n.td,{children:"Medium"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Polling"})}),(0,s.jsx)(n.td,{children:"2-30s"}),(0,s.jsx)(n.td,{children:"Low"}),(0,s.jsx)(n.td,{children:"High"}),(0,s.jsx)(n.td,{children:"Low"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"reliability-features",children:"Reliability Features"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Feature"}),(0,s.jsx)(n.th,{children:"SignalR"}),(0,s.jsx)(n.th,{children:"Webhooks"}),(0,s.jsx)(n.th,{children:"Polling"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Guaranteed Delivery"})}),(0,s.jsx)(n.td,{children:"No"}),(0,s.jsx)(n.td,{children:"Yes"}),(0,s.jsx)(n.td,{children:"Yes"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Automatic Retry"})}),(0,s.jsx)(n.td,{children:"Yes"}),(0,s.jsx)(n.td,{children:"Yes"}),(0,s.jsx)(n.td,{children:"Manual"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Message Ordering"})}),(0,s.jsx)(n.td,{children:"Yes"}),(0,s.jsx)(n.td,{children:"Yes"}),(0,s.jsx)(n.td,{children:"No"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Connection Recovery"})}),(0,s.jsx)(n.td,{children:"Yes"}),(0,s.jsx)(n.td,{children:"N/A"}),(0,s.jsx)(n.td,{children:"N/A"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Backpressure Handling"})}),(0,s.jsx)(n.td,{children:"Yes"}),(0,s.jsx)(n.td,{children:"Yes"}),(0,s.jsx)(n.td,{children:"Manual"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"scalability-considerations",children:"Scalability Considerations"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Aspect"}),(0,s.jsx)(n.th,{children:"SignalR"}),(0,s.jsx)(n.th,{children:"Webhooks"}),(0,s.jsx)(n.th,{children:"Polling"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Horizontal Scaling"})}),(0,s.jsx)(n.td,{children:"Redis Backplane"}),(0,s.jsx)(n.td,{children:"Load Balancer"}),(0,s.jsx)(n.td,{children:"Any"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Connection Limits"})}),(0,s.jsx)(n.td,{children:"10,000+ per instance"}),(0,s.jsx)(n.td,{children:"Unlimited"}),(0,s.jsx)(n.td,{children:"Unlimited"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Memory Usage"})}),(0,s.jsx)(n.td,{children:"Per-connection"}),(0,s.jsx)(n.td,{children:"Per-request"}),(0,s.jsx)(n.td,{children:"Minimal"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Network Efficiency"})}),(0,s.jsx)(n.td,{children:"High"}),(0,s.jsx)(n.td,{children:"Medium"}),(0,s.jsx)(n.td,{children:"Low"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"use-case-scenarios",children:"Use Case Scenarios"}),"\n",(0,s.jsx)(n.h3,{id:"real-time-dashboard",children:"Real-Time Dashboard"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Recommended: SignalR"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class RealTimeDashboard {\n  constructor() {\n    this.connection = new HubConnectionBuilder()\n      .withUrl('/hubs/navigation-state', {\n        accessTokenFactory: () => this.getAuthToken()\n      })\n      .build();\n    \n    this.setupEventHandlers();\n  }\n\n  setupEventHandlers() {\n    // Provider health updates\n    this.connection.on('ProviderHealthChanged', (data) => {\n      this.updateProviderStatus(data.provider, data.status);\n    });\n\n    // Real-time usage metrics\n    this.connection.on('UsageMetricsUpdated', (data) => {\n      this.updateUsageCharts(data.metrics);\n    });\n\n    // Task completion notifications\n    this.connection.on('TaskCompleted', (data) => {\n      this.showTaskNotification(data);\n    });\n  }\n\n  async start() {\n    await this.connection.start();\n    console.log('Dashboard connected to real-time updates');\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"mobile-application",children:"Mobile Application"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Recommended: Webhooks \u2192 Push Notifications"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// Server-side webhook handler\napp.post('/webhooks/conduit', async (req, res) => {\n  const event = req.body;\n  \n  if (event.type === 'image.completed') {\n    // Send push notification to mobile app\n    await sendPushNotification({\n      userId: event.data.userId,\n      title: 'Image Generated',\n      message: 'Your AI-generated image is ready!',\n      data: {\n        imageUrl: event.data.imageUrl,\n        taskId: event.data.taskId\n      }\n    });\n  }\n  \n  res.status(200).send('OK');\n});\n\n// Mobile app push notification handler\nfunction handlePushNotification(notification) {\n  if (notification.data.imageUrl) {\n    // Download and display image\n    showGeneratedImage(notification.data.imageUrl);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"batch-processing-system",children:"Batch Processing System"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Recommended: Webhooks"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class BatchProcessor {\n  constructor() {\n    this.pendingTasks = new Map();\n    this.completedTasks = new Map();\n  }\n\n  async processBatch(prompts) {\n    const tasks = [];\n    \n    // Start all generations\n    for (const prompt of prompts) {\n      const response = await fetch('/v1/images/generations', {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${this.apiKey}`,\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          prompt,\n          async: true,\n          webhook_url: 'https://yourapp.com/webhooks/conduit'\n        })\n      });\n\n      const task = await response.json();\n      tasks.push(task.task_id);\n      this.pendingTasks.set(task.task_id, prompt);\n    }\n\n    return tasks;\n  }\n\n  handleWebhook(event) {\n    const taskId = event.data.taskId;\n    \n    if (event.type === 'image.completed') {\n      const prompt = this.pendingTasks.get(taskId);\n      this.completedTasks.set(taskId, event.data);\n      this.pendingTasks.delete(taskId);\n      \n      console.log(`Completed: ${prompt} \u2192 ${event.data.imageUrl}`);\n      \n      // Check if batch is complete\n      if (this.pendingTasks.size === 0) {\n        this.onBatchComplete();\n      }\n    }\n  }\n\n  onBatchComplete() {\n    console.log('Batch processing complete!');\n    console.log('Results:', Array.from(this.completedTasks.values()));\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"legacy-system-integration",children:"Legacy System Integration"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Recommended: Polling"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// Simple polling for systems that can't receive webhooks\nclass LegacyIntegration {\n  constructor(apiKey) {\n    this.apiKey = apiKey;\n    this.checkInterval = 5000; // 5 seconds\n  }\n\n  async generateAndWait(prompt) {\n    // Start generation\n    const response = await this.makeRequest('/v1/images/generations', {\n      prompt,\n      async: true\n    });\n\n    const taskId = response.task_id;\n    \n    // Poll until complete\n    return new Promise((resolve, reject) => {\n      const check = async () => {\n        try {\n          const status = await this.makeRequest(`/v1/tasks/${taskId}`);\n          \n          if (status.status === 'completed') {\n            resolve(status.result);\n          } else if (status.status === 'failed') {\n            reject(new Error(status.error));\n          } else {\n            setTimeout(check, this.checkInterval);\n          }\n        } catch (error) {\n          reject(error);\n        }\n      };\n      \n      check();\n    });\n  }\n\n  async makeRequest(path, body = null) {\n    const options = {\n      headers: {\n        'Authorization': `Bearer ${this.apiKey}`,\n        'Content-Type': 'application/json'\n      }\n    };\n\n    if (body) {\n      options.method = 'POST';\n      options.body = JSON.stringify(body);\n    }\n\n    const response = await fetch(`https://api.conduit.yourdomain.com${path}`, options);\n    return await response.json();\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"implementation-guidelines",children:"Implementation Guidelines"}),"\n",(0,s.jsx)(n.h3,{id:"when-to-use-each-method",children:"When to Use Each Method"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Use SignalR when:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Building interactive web applications"}),"\n",(0,s.jsx)(n.li,{children:"Need real-time UI updates"}),"\n",(0,s.jsx)(n.li,{children:"Users expect immediate feedback"}),"\n",(0,s.jsx)(n.li,{children:"Handling multiple concurrent tasks"}),"\n",(0,s.jsx)(n.li,{children:"Building dashboards or monitoring interfaces"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Use Webhooks when:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Building server-to-server integrations"}),"\n",(0,s.jsx)(n.li,{children:"Need guaranteed delivery"}),"\n",(0,s.jsx)(n.li,{children:"Processing batch operations"}),"\n",(0,s.jsx)(n.li,{children:"Building mobile applications (via push notifications)"}),"\n",(0,s.jsx)(n.li,{children:"Integration with external systems"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Use Polling when:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Simple integration requirements"}),"\n",(0,s.jsx)(n.li,{children:"Working with legacy systems"}),"\n",(0,s.jsx)(n.li,{children:"Can't receive incoming HTTP requests"}),"\n",(0,s.jsx)(n.li,{children:"Development and testing"}),"\n",(0,s.jsx)(n.li,{children:"Low-frequency updates are acceptable"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"hybrid-approaches",children:"Hybrid Approaches"}),"\n",(0,s.jsx)(n.p,{children:"Many applications benefit from combining methods:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class HybridNotificationSystem {\n  constructor() {\n    this.signalRConnection = this.setupSignalR();\n    this.webhookFallback = true;\n    this.pollingBackup = true;\n  }\n\n  async startTask(params) {\n    const options = {\n      ...params,\n      async: true\n    };\n\n    // Try SignalR first for real-time updates\n    if (this.signalRConnection.state === 'Connected') {\n      return await this.startWithSignalR(options);\n    }\n    \n    // Fallback to webhooks if available\n    if (this.webhookFallback && this.webhookUrl) {\n      options.webhook_url = this.webhookUrl;\n      return await this.startWithWebhook(options);\n    }\n    \n    // Final fallback to polling\n    if (this.pollingBackup) {\n      return await this.startWithPolling(options);\n    }\n    \n    throw new Error('No communication method available');\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"error-handling-and-reliability",children:"Error Handling and Reliability"}),"\n",(0,s.jsx)(n.h3,{id:"connection-recovery",children:"Connection Recovery"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class ResilientConnection {\n  constructor(hubUrl, accessToken) {\n    this.hubUrl = hubUrl;\n    this.accessToken = accessToken;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 10;\n    this.setupConnection();\n  }\n\n  setupConnection() {\n    this.connection = new HubConnectionBuilder()\n      .withUrl(this.hubUrl, {\n        accessTokenFactory: () => this.accessToken\n      })\n      .withAutomaticReconnect({\n        nextRetryDelayInMilliseconds: (retryContext) => {\n          // Exponential backoff: 2s, 4s, 8s, 16s, 30s max\n          return Math.min(30000, Math.pow(2, retryContext.previousRetryCount) * 1000);\n        }\n      })\n      .build();\n\n    this.connection.onreconnecting((error) => {\n      console.log('Connection lost, reconnecting...', error);\n      this.onConnectionLost();\n    });\n\n    this.connection.onreconnected((connectionId) => {\n      console.log('Reconnected:', connectionId);\n      this.reconnectAttempts = 0;\n      this.onConnectionRestored();\n    });\n\n    this.connection.onclose((error) => {\n      console.log('Connection closed:', error);\n      this.onConnectionClosed();\n    });\n  }\n\n  onConnectionLost() {\n    // Switch to polling as backup\n    this.startPollingBackup();\n  }\n\n  onConnectionRestored() {\n    // Stop polling backup\n    this.stopPollingBackup();\n  }\n\n  startPollingBackup() {\n    if (this.pollingInterval) return;\n    \n    this.pollingInterval = setInterval(() => {\n      this.pollForUpdates();\n    }, 5000);\n  }\n\n  stopPollingBackup() {\n    if (this.pollingInterval) {\n      clearInterval(this.pollingInterval);\n      this.pollingInterval = null;\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"webhook-reliability",children:"Webhook Reliability"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// Webhook endpoint with reliability features\napp.post('/webhooks/conduit', async (req, res) => {\n  const event = req.body;\n  const signature = req.headers['x-conduit-signature'];\n  \n  try {\n    // Verify webhook signature\n    if (!verifyWebhookSignature(event, signature)) {\n      return res.status(401).send('Invalid signature');\n    }\n\n    // Idempotency check\n    if (await isDuplicateEvent(event.id)) {\n      return res.status(200).send('Already processed');\n    }\n\n    // Process event\n    await processEvent(event);\n    \n    // Mark as processed\n    await markEventProcessed(event.id);\n    \n    res.status(200).send('OK');\n  } catch (error) {\n    console.error('Webhook processing error:', error);\n    \n    // Return 500 to trigger retry\n    res.status(500).send('Processing failed');\n  }\n});\n\nfunction verifyWebhookSignature(payload, signature) {\n  const expectedSignature = crypto\n    .createHmac('sha256', process.env.WEBHOOK_SECRET)\n    .update(JSON.stringify(payload))\n    .digest('hex');\n  \n  return signature === `sha256=${expectedSignature}`;\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,s.jsx)(n.h3,{id:"virtual-key-authentication",children:"Virtual Key Authentication"}),"\n",(0,s.jsx)(n.p,{children:"All real-time communication methods support virtual key authentication:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// SignalR with virtual key\nconst connection = new HubConnectionBuilder()\n  .withUrl('/hubs/image-generation', {\n    accessTokenFactory: () => 'condt_your_virtual_key'\n  })\n  .build();\n\n// Webhooks with signature verification\napp.post('/webhooks', (req, res) => {\n  const signature = req.headers['x-conduit-signature'];\n  const isValid = verifySignature(req.body, signature, webhookSecret);\n  \n  if (!isValid) {\n    return res.status(401).send('Unauthorized');\n  }\n  \n  // Process webhook\n});\n\n// Polling with virtual key\nconst response = await fetch('/v1/tasks/task-id', {\n  headers: {\n    'Authorization': 'Bearer condt_your_virtual_key'\n  }\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"network-security",children:"Network Security"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// HTTPS enforcement\napp.use((req, res, next) => {\n  if (req.header('x-forwarded-proto') !== 'https') {\n    res.redirect(`https://${req.header('host')}${req.url}`);\n  } else {\n    next();\n  }\n});\n\n// Rate limiting for webhooks\nconst webhookLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 1000, // Limit each IP to 1000 requests per windowMs\n  message: 'Too many webhook requests'\n});\n\napp.use('/webhooks', webhookLimiter);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Webhooks"}),": Implement reliable ",(0,s.jsx)(n.a,{href:"webhooks",children:"webhook endpoints"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"SignalR"}),": Build real-time web applications with ",(0,s.jsx)(n.a,{href:"signalr",children:"SignalR integration"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Polling"}),": Set up simple ",(0,s.jsx)(n.a,{href:"polling",children:"polling patterns"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Media Generation"}),": Apply real-time updates to ",(0,s.jsx)(n.a,{href:"../media/async-processing",children:"async media generation"})]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var i=t(6540);const s={},r=i.createContext(s);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);