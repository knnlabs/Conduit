name: TUI NuGet Tool Publish

on:
  push:
    branches:
      - dev
      - master
    paths:
      - 'ConduitLLM.TUI/**'
      - 'Clients/DotNet/ConduitLLM.AdminClient/**'
      - 'Clients/DotNet/ConduitLLM.CoreClient/**'
      - 'ConduitLLM.Configuration/**'
      - 'Directory.Build.props'
      - '!**/*.md'
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Version increment type (master branch only)'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major
      force_run:
        description: 'Force run even without changes'
        required: false
        default: false
        type: boolean

env:
  DOTNET_VERSION: '9.0.x'
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true
  DOTNET_NOLOGO: true

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      tui-changed: ${{ steps.changes.outputs.tui }}
      should-run: ${{ steps.should-run.outputs.result }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Detect TUI changes
        id: changes
        run: |
          echo "Analyzing changes between HEAD~1 and HEAD..."
          
          # Check for TUI changes
          if git diff --name-only HEAD~1 HEAD | grep -E '^ConduitLLM\.TUI/|^Clients/DotNet/ConduitLLM\.(AdminClient|CoreClient)/|^ConduitLLM\.Configuration/' | grep -v '\.md$'; then
            echo "tui=true" >> $GITHUB_OUTPUT
            echo "üñ•Ô∏è TUI or its dependencies changed"
          else
            echo "tui=false" >> $GITHUB_OUTPUT
          fi
          
          # Check for Directory.Build.props changes
          if git diff --name-only HEAD~1 HEAD | grep -E '^Directory\.Build\.props$'; then
            echo "Directory.Build.props changed, affecting TUI"
            echo "tui=true" >> $GITHUB_OUTPUT
          fi

      - name: Should run workflow
        id: should-run
        run: |
          if [[ "${{ steps.changes.outputs.tui }}" == "true" || "${{ github.event.inputs.force_run }}" == "true" ]]; then
            echo "result=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Changes detected, will proceed with TUI publishing"
          else
            echo "result=false" >> $GITHUB_OUTPUT
            echo "‚è≠Ô∏è No relevant changes detected, skipping workflow"
          fi

  build-and-publish:
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.should-run == 'true'
    permissions:
      contents: write
      packages: write
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Configure Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: Determine version strategy
        id: strategy
        run: |
          BRANCH_NAME=${GITHUB_REF#refs/heads/}
          echo "branch=$BRANCH_NAME" >> $GITHUB_OUTPUT
          
          # Get current version from Directory.Build.props
          CURRENT_VERSION=$(grep -oP '<Version>\K[^<]+' Directory.Build.props | head -1)
          echo "current-version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "üìã Current version: $CURRENT_VERSION"
          
          if [[ "$BRANCH_NAME" == "dev" ]]; then
            # For dev: create prerelease with timestamp
            BUILD_NUMBER=$(date +%Y%m%d%H%M%S)
            if [[ "$CURRENT_VERSION" =~ -dev ]]; then
              # Already a dev version, increment
              BASE_VERSION=$(echo "$CURRENT_VERSION" | cut -d'-' -f1)
              NEW_VERSION="$BASE_VERSION-dev.$BUILD_NUMBER"
            else
              # Convert stable to dev version
              NEW_VERSION="$CURRENT_VERSION-dev.$BUILD_NUMBER"
            fi
            echo "version-type=prerelease" >> $GITHUB_OUTPUT
            echo "nuget-source=github" >> $GITHUB_OUTPUT
            echo "commit-back=false" >> $GITHUB_OUTPUT
          elif [[ "$BRANCH_NAME" == "master" ]]; then
            # For master: semantic versioning
            if echo "${{ github.event.head_commit.message }}" | grep -iE "breaking|major|BREAKING"; then
              VERSION_TYPE="major"
            elif echo "${{ github.event.head_commit.message }}" | grep -iE "feat|feature|minor"; then
              VERSION_TYPE="minor"
            else
              VERSION_TYPE="${{ github.event.inputs.version_type || 'patch' }}"
            fi
            
            # Parse current version and increment
            IFS='.' read -ra VERSION_PARTS <<< "${CURRENT_VERSION%%-*}"
            MAJOR=${VERSION_PARTS[0]}
            MINOR=${VERSION_PARTS[1]:-0}
            PATCH=${VERSION_PARTS[2]:-0}
            
            case $VERSION_TYPE in
              major)
                MAJOR=$((MAJOR + 1))
                MINOR=0
                PATCH=0
                ;;
              minor)
                MINOR=$((MINOR + 1))
                PATCH=0
                ;;
              patch)
                PATCH=$((PATCH + 1))
                ;;
            esac
            
            NEW_VERSION="$MAJOR.$MINOR.$PATCH"
            echo "version-type=$VERSION_TYPE" >> $GITHUB_OUTPUT
            echo "nuget-source=nuget" >> $GITHUB_OUTPUT
            echo "commit-back=true" >> $GITHUB_OUTPUT
          fi
          
          echo "new-version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "üéØ New version: $NEW_VERSION"

      - name: Update version in Directory.Build.props
        run: |
          NEW_VERSION="${{ steps.strategy.outputs.new-version }}"
          echo "üîÑ Updating Directory.Build.props to version $NEW_VERSION"
          
          # Update version in Directory.Build.props
          # For assembly versions, use numeric-only version (strip prerelease suffix)
          NUMERIC_VERSION=$(echo "$NEW_VERSION" | sed 's/-.*$//')
          
          sed -i "s|<Version>[^<]*</Version>|<Version>$NEW_VERSION</Version>|g" Directory.Build.props
          sed -i "s|<AssemblyVersion>[^<]*</AssemblyVersion>|<AssemblyVersion>$NUMERIC_VERSION</AssemblyVersion>|g" Directory.Build.props
          sed -i "s|<FileVersion>[^<]*</FileVersion>|<FileVersion>$NUMERIC_VERSION</FileVersion>|g" Directory.Build.props
          sed -i "s|<InformationalVersion>[^<]*</InformationalVersion>|<InformationalVersion>$NEW_VERSION</InformationalVersion>|g" Directory.Build.props
          
          echo "‚úÖ Version updated in Directory.Build.props"
          grep -A2 -B2 "<Version>" Directory.Build.props

      - name: Restore dependencies
        run: dotnet restore ConduitLLM.TUI/ConduitLLM.TUI.csproj

      - name: Build TUI
        run: |
          echo "üî® Building TUI project..."
          dotnet build ConduitLLM.TUI/ConduitLLM.TUI.csproj \
            --configuration Release \
            --no-restore \
            --verbosity normal

      - name: Test TUI build
        run: |
          echo "üß™ Testing TUI build..."
          # Test that the TUI can be executed (basic smoke test)
          dotnet run --project ConduitLLM.TUI/ConduitLLM.TUI.csproj \
            --configuration Release \
            --no-build \
            -- --version || echo "Version command not implemented yet"

      - name: Pack NuGet tool
        run: |
          echo "üì¶ Creating NuGet tool package..."
          
          dotnet pack ConduitLLM.TUI/ConduitLLM.TUI.csproj \
            --configuration Release \
            --no-build \
            --output ./nupkgs \
            --verbosity normal
          
          echo "üìã Package created:"
          ls -la ./nupkgs/

      - name: Validate package
        run: |
          echo "üîç Validating NuGet package..."
          
          # Check that the package was created
          if ls ./nupkgs/ConduitLLM.TUI.*.nupkg 1> /dev/null 2>&1; then
            echo "‚úÖ Package file found"
            
            # Show package contents
            echo "üì¶ Package contents:"
            unzip -l ./nupkgs/ConduitLLM.TUI.*.nupkg | head -20
          else
            echo "‚ùå Package file not found!"
            exit 1
          fi

      - name: Commit version changes
        if: steps.strategy.outputs.commit-back == 'true'
        run: |
          # Check if there are any changes to commit
          if git diff --quiet; then
            echo "No changes to commit"
            exit 0
          fi
          
          NEW_VERSION="${{ steps.strategy.outputs.new-version }}"
          VERSION_TYPE="${{ steps.strategy.outputs.version-type }}"
          
          # Prepare commit message
          COMMIT_MSG="chore: bump TUI tool to v$NEW_VERSION ($VERSION_TYPE) [skip ci]"
          
          # Stage and commit
          git add Directory.Build.props
          git commit -m "$COMMIT_MSG"
          
          # Push with retry logic
          for i in {1..3}; do
            if git push; then
              echo "‚úÖ Version changes committed and pushed"
              break
            else
              echo "‚ö†Ô∏è Push failed, attempt $i/3. Checking for remote changes..."
              # Try to fast-forward only, fail if not possible
              if ! git pull --ff-only; then
                echo "‚ùå Cannot fast-forward merge. Manual intervention required."
                echo "Another commit was pushed to the branch during versioning."
                echo "Please resolve conflicts manually."
                exit 1
              fi
              if [[ $i == 3 ]]; then
                echo "‚ùå Failed to push after 3 attempts"
                exit 1
              fi
            fi
          done

      - name: Publish to GitHub Packages (dev branch)
        if: steps.strategy.outputs.nuget-source == 'github'
        run: |
          echo "üì§ Publishing to GitHub Packages..."
          
          dotnet nuget add source \
            --username ${{ github.actor }} \
            --password ${{ secrets.GITHUB_TOKEN }} \
            --store-password-in-clear-text \
            --name github \
            "https://nuget.pkg.github.com/${{ github.repository_owner }}/index.json"
          
          for package in ./nupkgs/ConduitLLM.TUI.*.nupkg; do
            echo "Publishing $package to GitHub Packages..."
            dotnet nuget push "$package" \
              --source "github" \
              --api-key ${{ secrets.GITHUB_TOKEN }} \
              --skip-duplicate
          done
          
          echo "‚úÖ TUI tool published to GitHub Packages"

      - name: Publish to NuGet.org (master branch)
        if: steps.strategy.outputs.nuget-source == 'nuget'
        run: |
          echo "üì§ Publishing to NuGet.org..."
          
          if [[ -z "${{ secrets.NUGET_API_KEY }}" ]]; then
            echo "‚ùå NUGET_API_KEY secret not found. Cannot publish to NuGet.org."
            echo "To enable NuGet.org publishing, add your API key as a repository secret."
            # Fail for master branch as we expect to publish to NuGet.org
            exit 1
          fi
          
          for package in ./nupkgs/ConduitLLM.TUI.*.nupkg; do
            echo "Publishing $package to NuGet.org..."
            dotnet nuget push "$package" \
              --source https://api.nuget.org/v3/index.json \
              --api-key ${{ secrets.NUGET_API_KEY }} \
              --skip-duplicate
          done
          
          echo "‚úÖ TUI tool published to NuGet.org"

      - name: Create GitHub Release (master branch only)
        if: steps.strategy.outputs.commit-back == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          NEW_VERSION="${{ steps.strategy.outputs.new-version }}"
          VERSION_TYPE="${{ steps.strategy.outputs.version-type }}"
          
          # Create release notes
          RELEASE_NOTES=$'## Conduit LLM TUI v'"$NEW_VERSION"$'\n\n'
          RELEASE_NOTES+=$'### Changes\n'
          RELEASE_NOTES+=$'- Auto-generated release for TUI .NET tool\n'
          RELEASE_NOTES+=$'- Version type: '"$VERSION_TYPE"$'\n\n'
          RELEASE_NOTES+=$'### Installation\n'
          RELEASE_NOTES+=$'```bash\n'
          RELEASE_NOTES+=$'# Install globally\n'
          RELEASE_NOTES+=$'dotnet tool install --global ConduitLLM.TUI --version '"$NEW_VERSION"$'\n\n'
          RELEASE_NOTES+=$'# Or update existing installation\n'
          RELEASE_NOTES+=$'dotnet tool update --global ConduitLLM.TUI --version '"$NEW_VERSION"$'\n\n'
          RELEASE_NOTES+=$'# Use the tool\n'
          RELEASE_NOTES+=$'conduit-tui --help\n'
          RELEASE_NOTES+=$'```\n\n'
          RELEASE_NOTES+=$'### Usage\n'
          RELEASE_NOTES+=$'The TUI provides a terminal interface for:\n'
          RELEASE_NOTES+=$'- Managing Conduit LLM virtual keys\n'
          RELEASE_NOTES+=$'- Monitoring system performance\n'
          RELEASE_NOTES+=$'- Configuring providers and models\n'
          RELEASE_NOTES+=$'- Real-time chat and generation monitoring\n\n'
          RELEASE_NOTES+=$'For more information, see the [project documentation](https://github.com/knnlabs/Conduit).'
          
          # Create the release using GitHub CLI
          gh release create "tui-v$NEW_VERSION" \
            --title "TUI v$NEW_VERSION" \
            --notes "$RELEASE_NOTES" \
            --target "${{ github.sha }}" \
            ./nupkgs/ConduitLLM.TUI.*.nupkg

      - name: Workflow Summary
        run: |
          echo "üéâ TUI .NET Tool Publishing Complete!"
          echo ""
          echo "üìä Summary:"
          echo "  Branch: ${{ steps.strategy.outputs.branch }}"
          echo "  Version: ${{ steps.strategy.outputs.new-version }}"
          echo "  Type: ${{ steps.strategy.outputs.version-type }}"
          echo "  Published to: ${{ steps.strategy.outputs.nuget-source }}"
          echo ""
          echo "üñ•Ô∏è TUI Tool:"
          echo "  - ConduitLLM.TUI v${{ steps.strategy.outputs.new-version }}"
          echo "  - Command: conduit-tui"
          echo ""
          echo "üí° Installation:"
          if [[ "${{ steps.strategy.outputs.nuget-source }}" == "github" ]]; then
            echo "  # Add GitHub Packages source first:"
            echo "  dotnet nuget add source https://nuget.pkg.github.com/${{ github.repository_owner }}/index.json -n github"
            echo ""
            echo "  # Install tool:"
            echo "  dotnet tool install --global ConduitLLM.TUI --version ${{ steps.strategy.outputs.new-version }} --add-source github"
          else
            echo "  # Install from NuGet.org:"
            echo "  dotnet tool install --global ConduitLLM.TUI --version ${{ steps.strategy.outputs.new-version }}"
            echo ""
            echo "  # Or update existing:"
            echo "  dotnet tool update --global ConduitLLM.TUI --version ${{ steps.strategy.outputs.new-version }}"
          fi
          echo ""
          echo "üöÄ Usage:"
          echo "  conduit-tui --help"